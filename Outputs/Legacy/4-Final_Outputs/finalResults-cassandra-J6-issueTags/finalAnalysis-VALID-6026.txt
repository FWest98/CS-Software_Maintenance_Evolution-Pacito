Pattern changes caused by commit: 9ca84786b5be14b0a881268e3649b697f7f893b9

From: Abstract Factory-3
To:   Abstract Factory-2

From: Factory Method-3
To:   Factory Method-2

From: Facade-1
To:   Facade-0

From: Flyweight-3
To:   Flyweight-4


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-6026.txt 

commit 9ca84786b5be14b0a881268e3649b697f7f893b9
Author: Jonathan Ellis <jbellis@apache.org>

    fix race between cleanup and flush on secondary index CFSes
    patch by yukim and jbellis for CASSANDRA-3712



==================================
 Issue CASSANDRA-3712 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-3712] Can't cleanup after I moved a token.
-----------------

-----------------
Summary: Can't cleanup after I moved a token.
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Mon, 9 Jan 2012 14:37:09 +0000
-----------------

-----------------
Resolved at: Mon, 13 Feb 2012 23:30:35 +0000
-----------------

-----------------
Assigned to: Yuki Morishita
-----------------

-----------------
Description: 

Before cleanup failed, I moved one node's token.<br/>My cluster had 10GB data on 2 nodes.
Data repartition was bad, tokens were 165<span class="error">&#91;...&#93;</span> and
155<span class="error">&#91;...&#93;</span>.<br/>I moved 155 to 075<span
class="error">&#91;...&#93;</span>, then adjusted to 076<span
class="error">&#91;...&#93;</span>. The moves were correctly processed, with no
exception.<br/>But then, when I wanted to cleanup, it failed and keeps failing, on both
nodes.

Other maintenance procedures like repair, compact or scrub work.<br/>All the data
is in the URLs CF.

Example session log:<br/>nodetool cleanup fails:<br/>$ ./nodetool
--host cnode1 cleanup<br/>Error occured during
cleanup<br/>java.util.concurrent.ExecutionException: java.lang.AssertionError<br/> at
java.util.concurrent.FutureTask$Sync.innerGet(FutureTask.java:222)<br/> at
java.util.concurrent.FutureTask.get(FutureTask.java:83)<br/> at
org.apache.cassandra.db.compaction.CompactionManager.performAllSSTableOperation(CompactionManager.java:203)<br/>
at
org.apache.cassandra.db.compaction.CompactionManager.performCleanup(CompactionManager.java:237)<br/>
at org.apache.cassandra.db.ColumnFamilyStore.forceCleanup(ColumnFamilyStore.java:958)<br/>
at
org.apache.cassandra.service.StorageService.forceTableCleanup(StorageService.java:1604)<br/>
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br/> at
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)<br/> at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)<br/>
at java.lang.reflect.Method.invoke(Method.java:597)<br/> at
com.sun.jmx.mbeanserver.StandardMBeanIntrospector.invokeM2(StandardMBeanIntrospector.java:93)<br/>
at
com.sun.jmx.mbeanserver.StandardMBeanIntrospector.invokeM2(StandardMBeanIntrospector.java:27)<br/>
at com.sun.jmx.mbeanserver.MBeanIntrospector.invokeM(MBeanIntrospector.java:208)<br/> at
com.sun.jmx.mbeanserver.PerInterface.invoke(PerInterface.java:120)<br/> at
com.sun.jmx.mbeanserver.MBeanSupport.invoke(MBeanSupport.java:262)<br/> at
com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:836)<br/>
at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:761)<br/> at
javax.management.remote.rmi.RMIConnectionImpl.doOperation(RMIConnectionImpl.java:1427)<br/>
at
javax.management.remote.rmi.RMIConnectionImpl.access$200(RMIConnectionImpl.java:72)<br/>
at
javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(RMIConnectionImpl.java:1265)<br/>
at
javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(RMIConnectionImpl.java:1360)<br/>
at javax.management.remote.rmi.RMIConnectionImpl.invoke(RMIConnectionImpl.java:788)<br/>
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br/> at
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)<br/> at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)<br/>
at java.lang.reflect.Method.invoke(Method.java:597)<br/> at
sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:305)<br/> at
sun.rmi.transport.Transport$1.run(Transport.java:159)<br/> at
java.security.AccessController.doPrivileged(Native Method)<br/> at
sun.rmi.transport.Transport.serviceCall(Transport.java:155)<br/> at
sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:535)<br/> at
sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:790)<br/> at
sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:649)<br/> at
java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)<br/>
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)<br/> at
java.lang.Thread.run(Thread.java:662)<br/>Caused by: java.lang.AssertionError<br/> at
org.apache.cassandra.db.Memtable.put(Memtable.java:136)<br/> at
org.apache.cassandra.db.ColumnFamilyStore.apply(ColumnFamilyStore.java:780)<br/> at
org.apache.cassandra.db.index.keys.KeysIndex.deleteColumn(KeysIndex.java:82)<br/> at
org.apache.cassandra.db.index.SecondaryIndexManager.deleteFromIndexes(SecondaryIndexManager.java:438)<br/>
at
org.apache.cassandra.db.compaction.CompactionManager.doCleanupCompaction(CompactionManager.java:754)<br/>
at
org.apache.cassandra.db.compaction.CompactionManager.access$300(CompactionManager.java:63)<br/>
at
org.apache.cassandra.db.compaction.CompactionManager$5.perform(CompactionManager.java:241)<br/>
at
org.apache.cassandra.db.compaction.CompactionManager$2.call(CompactionManager.java:182)<br/>
at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)<br/> at
java.util.concurrent.FutureTask.run(FutureTask.java:138)<br/> ... 3 more

The server log
looks like this:<br/> INFO <span class="error">&#91;CompactionExecutor:260&#93;</span>
2012-01-09 14:08:41,716 CompactionManager.java (line 702) Cleaning up
SSTableReader(path='/ke/cassandra/data/kev3/URLs-hc-457-Data.db')<br/> INFO <span
class="error">&#91;OptionalTasks:1&#93;</span> 2012-01-09 14:08:47,220 MeteredFlusher.java
(line 62) flushing high-traffic column family CFS(Keyspace='kev3', ColumnFamily='URLs')
(estimated 156787206 bytes)<br/> INFO <span class="error">&#91;OptionalTasks:1&#93;</span>
2012-01-09 14:08:47,226 ColumnFamilyStore.java (line 692) Enqueuing flush of
Memtable-URLs.URLs_1_idx@1347180703(16324791/156973287 serialized/live bytes, 173288
ops)<br/> INFO <span class="error">&#91;FlushWriter:23&#93;</span> 2012-01-09 14:08:47,236
Memtable.java (line 240) Writing Memtable-URLs.URLs_1_idx@1347180703(16324791/156973287
serialized/live bytes, 173288 ops)<br/> INFO <span
class="error">&#91;pool-1-thread-1&#93;</span> 2012-01-09 14:08:51,003 Memtable.java (line
180) CFS(Keyspace='kev3', ColumnFamily='URLs.URLs_1_idx') liveRatio is 7.692510757866615
(just-counted was 4.512127842861816).  calculation took 8648ms for 97329 columns<br/> INFO
<span class="error">&#91;FlushWriter:23&#93;</span> 2012-01-09 14:08:54,360 Memtable.java
(line 277) Completed flushing /ke/cassandra/data/kev3/URLs.URLs_1_idx-hc-143-Data.db
(26375495 bytes)<br/> INFO <span class="error">&#91;ScheduledTasks:1&#93;</span>
2012-01-09 14:08:55,566 GCInspector.java (line 123) GC for ParNew: 206 ms for 1
collections, 934108624 used; max is 2034237440<br/> INFO <span
class="error">&#91;OptionalTasks:1&#93;</span> 2012-01-09 14:08:57,289 MeteredFlusher.java
(line 62) flushing high-traffic column family CFS(Keyspace='kev3', ColumnFamily='URLs')
(estimated 188842513 bytes)<br/> INFO <span class="error">&#91;OptionalTasks:1&#93;</span>
2012-01-09 14:08:57,297 ColumnFamilyStore.java (line 692) Enqueuing flush of
Memtable-URLs.URLs_1_idx@164871630(19662738/189069779 serialized/live bytes, 208494
ops)<br/> INFO <span class="error">&#91;FlushWriter:23&#93;</span> 2012-01-09 14:08:57,297
Memtable.java (line 240) Writing Memtable-URLs.URLs_1_idx@164871630(19662738/189069779
serialized/live bytes, 208494 ops)<br/> INFO <span
class="error">&#91;ScheduledTasks:1&#93;</span> 2012-01-09 14:08:57,619 GCInspector.java
(line 123) GC for ParNew: 402 ms for 2 collections, 981893424 used; max is 2034237440<br/>
INFO <span class="error">&#91;FlushWriter:23&#93;</span> 2012-01-09 14:09:05,944
Memtable.java (line 277) Completed flushing
/ke/cassandra/data/kev3/URLs.URLs_1_idx-hc-144-Data.db (31755390 bytes)<br/> INFO <span
class="error">&#91;OptionalTasks:1&#93;</span> 2012-01-09 14:09:06,447 MeteredFlusher.java
(line 62) flushing high-traffic column family CFS(Keyspace='kev3', ColumnFamily='URLs')
(estimated 174605041 bytes)<br/> INFO <span class="error">&#91;OptionalTasks:1&#93;</span>
2012-01-09 14:09:06,447 ColumnFamilyStore.java (line 692) Enqueuing flush of
Memtable-URLs.URLs_1_idx@284469330(18158445/174605041 serialized/live bytes, 192702
ops)<br/> INFO <span class="error">&#91;FlushWriter:23&#93;</span> 2012-01-09 14:09:06,447
Memtable.java (line 240) Writing Memtable-URLs.URLs_1_idx@284469330(18158445/174605041
serialized/live bytes, 192702 ops)<br/>ERROR <span
class="error">&#91;CompactionExecutor:260&#93;</span> 2012-01-09 14:09:06,448
AbstractCassandraDaemon.java (line 133) Fatal exception in thread Thread<span
class="error">&#91;CompactionExecutor:260,1,RMI
Runtime&#93;</span><br/>java.lang.AssertionError<br/>	at
org.apache.cassandra.db.Memtable.put(Memtable.java:136)<br/>	at
org.apache.cassandra.db.ColumnFamilyStore.apply(ColumnFamilyStore.java:780)<br/>	at
org.apache.cassandra.db.index.keys.KeysIndex.deleteColumn(KeysIndex.java:82)<br/>	at
org.apache.cassandra.db.index.SecondaryIndexManager.deleteFromIndexes(SecondaryIndexManager.java:438)<br/>	at
org.apache.cassandra.db.compaction.CompactionManager.doCleanupCompaction(CompactionManager.java:754)<br/>	at
org.apache.cassandra.db.compaction.CompactionManager.access$300(CompactionManager.java:63)<br/>	at
org.apache.cassandra.db.compaction.CompactionManager$5.perform(CompactionManager.java:241)<br/>	at
org.apache.cassandra.db.compaction.CompactionManager$2.call(CompactionManager.java:182)<br/>	at
java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)<br/>	at
java.util.concurrent.FutureTask.run(FutureTask.java:138)<br/>	at
java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)<br/>	at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)<br/>	at
java.lang.Thread.run(Thread.java:662)
 

-----------------

-----------------
Comments: 

New Comment: 
We'll look into the root cause, but in the meantime, restarting the node should fix this. 


New Comment: 
I restarted my nodes, but it didn't fix this. 


New Comment: 
Then you'll probably need to drop your indexes, then rebuild after the cleanup. 


New Comment: 
Thanks, that fixed cleanup. 


New Comment: 
When updating/deleting CFS backed secondary index, currently it doesn't acquire Memtable
lock. So when flush and cleanup occurred at the same time on indexed column family, there
is a chance of getting this AssertionError.Test case attached to reproduce the same error.
Note that test does not fail always, so you may run several times to see the error.To fix
this, I added CFS#applyDirect method which just acquire and release lock before/after CFS
update, and call it from KeysIndex.Both patches are for 1.0 branch. 


New Comment: 
A couple comments:<ul class="alternate" type="square">	<li>I can't get the new test to
fail after a dozen tries. If there isn't a way to make it more robust (say, with explicit
sleeps) maybe we should just leave that out.</li>	<li>Currently the switch locking is done
by the callers of the SIM methods, i.e., Table.apply and Table.indexRow. Locking at the
column level is not sufficient there, but doing it in both places is redundant. So maybe
the right place to lock here would be in the doCleanupCompaction method.</li></ul> 


New Comment: 
<blockquote>I can't get the new test to fail after a dozen tries. If there isn't a way to
make it more robust (say, with explicit sleeps) maybe we should just leave that
out.</blockquote>In my env, it fails 1/3 or 1/4 try. I cannot think of better test
program, so you can leave it out.<blockquote>Currently the switch locking is done by the
callers of the SIM methods, i.e., Table.apply and Table.indexRow. Locking at the column
level is not sufficient there, but doing it in both places is redundant. So maybe the
right place to lock here would be in the doCleanupCompaction method.</blockquote>You are
right. Previous patch acquires lock too often. I placed lock/unlock inside
doCleanupCompaction in newer patch.<br/>In order to do that, I have to expose
Table.switchlock to public, but I don't know if that is the right way. 


New Comment: 
The new patch acquires the switchlock for the entire cleanup, so no flushes can happen. 
For large sstables this could cause a problem.  How about attached v3, is that sufficient
for it to be safe? 


New Comment: 
I ran my unit test enough and I see no error.<br/>+1 


