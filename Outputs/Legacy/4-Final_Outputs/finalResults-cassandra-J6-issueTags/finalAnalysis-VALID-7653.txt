Pattern changes caused by commit: 936302cb3876df87e6afb45c775850eb851e9b18

From: Decorator-2
To:   Decorator-1

From: Flyweight-2
To:   Flyweight-1

From: Mediator-3
To:   Mediator-1

From: Strategy-0
To:   Strategy-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-7653.txt 

commit 936302cb3876df87e6afb45c775850eb851e9b18
Author: Jonathan Ellis <jbellis@apache.org>

    Wait for writes on synchronous read digest mismatch
    patch by Niklas Ekstrom; reviewed by jbellis and vijay for CASSANDRA-4792



==================================
 Issue CASSANDRA-4792 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-4792] Digest mismatch doesn't wait for writes as intended
-----------------

-----------------
Summary: Digest mismatch doesn't wait for writes as intended
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Thu, 11 Oct 2012 14:54:01 +0000
-----------------

-----------------
Resolved at: Thu, 11 Oct 2012 20:07:31 +0000
-----------------

-----------------
Assigned to: Jonathan Ellis
-----------------

-----------------
Description: 

As reported by Niklas Ekström on the dev list:

I’m looking in the file StorageProxy.java
(Cassandra 1.1.5), and line 766 seems odd to me.

FBUtilities.waitOnFutures() is called
with the repairResults from the RowRepairResolver resolver.

The problem though is that
repairResults is only assigned when the object is created at line 737 in
StorageProxy.java, and there it is assigned to Collections.emptyList(), and in the
resolve() method in RowRepairResolver, which is indirectly called from line 771 in
StorageProxy.java, that is, after the call to FBUtilities.waitOnFutures().

So the effect
is that line 766 in StorageProxy.java is essentially a no-op.
 

-----------------

-----------------
Comments: 

New Comment: 
patch attached. 


New Comment: 
+1 


New Comment: 
committed 


New Comment: 
Is this bug's practical effect summarizable as :"Because read repair didn't actually wait
around for repair writes to ack, there was a non-zero chance of multiple concurrent read
requests to a needing-repair key triggering multiple repair writes?" 


