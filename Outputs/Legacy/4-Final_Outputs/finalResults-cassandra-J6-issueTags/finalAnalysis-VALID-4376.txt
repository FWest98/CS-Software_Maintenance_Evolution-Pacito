Pattern changes caused by commit: 1f75bfa1a854fdf9a6a635cba6ff6abd9d9dd814

From: Mediator-2
To:   Mediator-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-4376.txt 

commit 1f75bfa1a854fdf9a6a635cba6ff6abd9d9dd814
Author: Sylvain Lebresne <slebresne@apache.org>

    Fix scan wrongly throwing assertion errors
    patch by slebresne; reviewed by jbellis for CASSANDRA-2653



==================================
 Issue CASSANDRA-2653 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-2653] index scan errors out when zero columns are requested
-----------------

-----------------
Summary: index scan errors out when zero columns are requested
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Sat, 14 May 2011 15:02:08 +0000
-----------------

-----------------
Resolved at: Wed, 29 Jun 2011 19:41:51 +0000
-----------------

-----------------
Assigned to: Sylvain Lebresne
-----------------

-----------------
Description: 

As reported by Tyler Hobbs as an addendum to <a
href="https://issues.apache.org/jira/browse/CASSANDRA-2401" title="getColumnFamily()
return null, which is not checked in ColumnFamilyStore.java scan() method, causing Timeout
Exception in query" class="issue-link"
data-issue-key="CASSANDRA-2401"><del>CASSANDRA-2401</del></a>,
<div class="preformatted
panel" style="border-width: 1px;"><div class="preformattedContent panelContent"><pre>ERROR
16:13:38,864 Fatal exception in thread
Thread[ReadStage:16,5,main]java.lang.AssertionError: No data found for
SliceQueryFilter(start=java.nio.HeapByteBuffer[pos=10 lim=10 cap=30],
finish=java.nio.HeapByteBuffer[pos=17 lim=17 cap=30], reversed=false, count=0] in
DecoratedKey(81509516161424251288255223397843705139,
6b657931):QueryPath(columnFamilyName='cf', superColumnName='null', columnName='null')
(original filter SliceQueryFilter(start=java.nio.HeapByteBuffer[pos=10 lim=10 cap=30],
finish=java.nio.HeapByteBuffer[pos=17 lim=17 cap=30], reversed=false, count=0]) from
expression 'cf.626972746864617465 EQ 1'	at
org.apache.cassandra.db.ColumnFamilyStore.scan(ColumnFamilyStore.java:1517)	at
org.apache.cassandra.service.IndexScanVerbHandler.doVerb(IndexScanVerbHandler.java:42)	at
org.apache.cassandra.net.MessageDeliveryTask.run(MessageDeliveryTask.java:72)	at
java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)	at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)	at
java.lang.Thread.run(Thread.java:662)</pre></div></div> 

-----------------

-----------------
Comments: 

New Comment: 
Attached testcase reproduces the error every timeRun like:ant long-test
-Dtest.name=IndexCorruptionTest 


New Comment: 
<div class="preformatted panel" style="border-width: 1px;"><div class="preformattedContent
panelContent"><pre>long-test:     [echo] running long tests    [junit] WARNING: multiple
versions of ant detected in path for junit     [junit]         
jar:file:/usr/share/ant/lib/ant.jar!/org/apache/tools/ant/Project.class    [junit]     
and
jar:file:/Users/jake/workspace/cassandra-git/build/lib/jars/ant-1.6.5.jar!/org/apache/tools/ant/Project.class
   [junit] Testsuite: org.apache.cassandra.db.IndexCorruptionTest    [junit] Tests run: 1,
Failures: 0, Errors: 1, Time elapsed: 247.427 sec    [junit]     [junit] -------------
Standard Error -----------------    [junit] ERROR 16:31:03,330 Fatal exception in thread
Thread[ReadStage:5,5,main]    [junit] java.lang.AssertionError: No data found for
NamesQueryFilter(columns=java.nio.HeapByteBuffer[pos=12 lim=16 cap=17]) in
DecoratedKey(Token(bytes[004600460048004d00540049005900590048005400460059004a0048004b0055004e00550048004b00530055005400480055004b004f004b004a00460058004600000001000100010001000100010001000100e3000100010001000100e3000100010001000100e3000100010001000100e30001000100010001000100010001000100010001000100010000000100010001000100010001000100010003000100010001000100030001000100010001000300010001000100010003000100010001000100010001000100010001000100010001]),
30303237623366662d326230662d343235632d386332352d616362326335393534306530):QueryPath(columnFamilyName='inode',
superColumnName='null', columnName='null') (original filter
NamesQueryFilter(columns=java.nio.HeapByteBuffer[pos=12 lim=16 cap=17])) from expression
'inode.73656e74696e656c EQ 78'    [junit] 	at
org.apache.cassandra.db.ColumnFamilyStore.scan(ColumnFamilyStore.java:1517)    [junit] 	at
org.apache.cassandra.service.IndexScanVerbHandler.doVerb(IndexScanVerbHandler.java:42)   
[junit] 	at org.apache.cassandra.net.MessageDeliveryTask.run(MessageDeliveryTask.java:72) 
  [junit] 	at
java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)   
[junit] 	at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)    [junit]
	at java.lang.Thread.run(Thread.java:680)    [junit] ------------- ----------------
---------------    [junit] Testcase:
runTest(org.apache.cassandra.db.IndexCorruptionTest):	Caused an ERROR    [junit]
TimedOutException()    [junit] java.io.IOException: TimedOutException()    [junit] 	at
org.apache.cassandra.db.IndexCorruptionTest.listDeepSubPaths(IndexCorruptionTest.java:107)
   [junit] 	at
org.apache.cassandra.db.IndexCorruptionTest.runTest(IndexCorruptionTest.java:64)   
[junit] Caused by: TimedOutException()    [junit] 	at
org.apache.cassandra.thrift.Cassandra$get_indexed_slices_result.read(Cassandra.java:13801)
   [junit] 	at
org.apache.cassandra.thrift.Cassandra$Client.recv_get_indexed_slices(Cassandra.java:810)  
 [junit] 	at
org.apache.cassandra.thrift.Cassandra$Client.get_indexed_slices(Cassandra.java:782)   
[junit] 	at
org.apache.cassandra.db.IndexCorruptionTest.listDeepSubPaths(IndexCorruptionTest.java:90) 
  [junit]     [junit]     [junit] Test org.apache.cassandra.db.IndexCorruptionTest
FAILEDBUILD FAILED/Users/jake/workspace/cassandra-git/build.xml:1082: The following error
occurred while executing this line:/Users/jake/workspace/cassandra-git/build.xml:1037:
Some long test(s) failed.Total time: 4 minutes 14 seconds</pre></div></div> 


New Comment: 
Definitely related to compaction...The memtable flushes minute and the test fails &gt; 4If
you change the min compaction thresh to 2 it fails &gt; 2 


New Comment: 
This is indeed compaction related (but not related to secondary indexing at<br/>all). The
problem is that compaction may lose some rows.Because of the way the ReducingIterator
works, when we create a new{Pre|Lazy|Echoed}CompactedRow, we have already decoded the next
row key and<br/>the file pointer if after that next row key. Both PreCompactedRow
and<br/>LazyCompactedRow handle this correctly by "resetting"
their<br/>SSTableIdentityIterator before reading
(SSTII.getColumnFamilyWithColumns()<br/>does it for PreCompactedRow and LazilyCompactedRow
calls SSTII.reset()<br/>directly). But EchoedRow doesn't handle this correctly. Hence
when<br/>EchoedRow.isEmpty() is called, it will call SSTII.hasNext(), that will
compare<br/>the current file pointer to the finishedAt value of the iterator. The
pointer<br/>being on the next row, this test will always fail and the row will be
skipped.Attaching a patch against 0.8 with a (smaller) unit test.Note that luckily this
doesn't affect 0.7, because it only uses EchoedRow for<br/>cleanup compactions and clean
compactions does not use ReducingIterator (and<br/>thus, the underlying SSTII won't have
changed when the EchoedRow is built).<br/>I would still be in favor of committing the
patch there too, just to make sure<br/>we don't hit this later. 


New Comment: 
+1 for 0.7 / 0.8 


New Comment: 
Integrated in Cassandra-0.7 #500 (See <a
href="https://builds.apache.org/hudson/job/Cassandra-0.7/500/" class="external-link"
rel="nofollow">https://builds.apache.org/hudson/job/Cassandra-0.7/500/</a>)<br/>    Reset
SSTII in EchoedRow iterator (see <a
href="https://issues.apache.org/jira/browse/CASSANDRA-2653" title="index scan errors out
when zero columns are requested" class="issue-link"
data-issue-key="CASSANDRA-2653"><del>CASSANDRA-2653</del></a>)slebresne : <a
href="http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&amp;view=rev&amp;rev=1129151"
class="external-link"
rel="nofollow">http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&amp;view=rev&amp;rev=1129151</a><br/>Files
:
<ul>	<li>/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/CompactionsTest.java</li>	<li>/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/CompactionManager.java</li></ul> 


New Comment: 
Is this actually fixed for the zero-columns-requested original problem? 


New Comment: 
This really primarily fixes the error from Jake's test cases. I'll have to admit that's
the only I looked. I did not realize the original problem was not necessarily related and
so it is very possible (even likely) this does not fix the zero-columns-requested problem. 


New Comment: 
reopening to fix "the tyler issue." 


New Comment: 
The "Tyler" problem is actually not limited to 0 column query. The problem is that when we
query the rows for data, we use whatever filter the user provided (there's a number of
optimiziation in the case we have more than 1 clause but that doesn't really matter for
our problem). The thing is, there is no guarantee that whatever that filter is, it will
include the column of the primary clause (having a column count of 0 is just one case
where we're sure it won't include it). Thus the assertion that something will be returned
is bogus.Attaching a patch (against 0.8) to fix. Note that this mean we have no way to
assert the sanity of the index during a read, unless we force the querying of the primary
index clause, but this will have a performance impact (and a non negligible one in cases
this would force us to do a new query just for that). 


New Comment: 
This also affects 0.7 actually so attaching a patch for 0.7. 


New Comment: 
Is there a way we can keep a sanity check here?  <a
href="https://issues.apache.org/jira/browse/CASSANDRA-2401" title="getColumnFamily()
return null, which is not checked in ColumnFamilyStore.java scan() method, causing Timeout
Exception in query" class="issue-link"
data-issue-key="CASSANDRA-2401"><del>CASSANDRA-2401</del></a> was not so long ago. 


New Comment: 
As I said earlier, I think the only way to keep one would be to force the querying of the
primary index clause column name. In some cases, when we already do a NameQuery, either as
part of the first data query or because we need a query for the extraFilter, this won't be
a big deal. If it's a slice query and the primary index clause name is part of the return,
we're good to. But otherwise, we'll have to do a specific query to validate the assert.
Maybe the cases where we'll have to do an extra query are considered low enough than we
think it's worth. But then there is the other problem.The other problem is that this
assertion is not thread safe, because the query to the index and the data is not atomic. 


New Comment: 
<blockquote>I think the only way to keep one would be to force the querying of the primary
index clause column name... but this will have a performance impact</blockquote>I think we
should take the impact.  (The common query that we want to be fast is name-based and this
won't affect that.) 


New Comment: 
I actually agree with taking the impact. Especially given that there is actually very
little cases where it will make an actual difference anyway.Attaching patch (2653_v2,
based on 0.7) that implement the idea and add back the sanity check. 


New Comment: 
doesn't this assert still have the "the query to the index and the data is not atomic"
problem? 


New Comment: 
<blockquote>doesn't this assert still have the "the query to the index and the data is not
atomic" problem?</blockquote>No you're right, I focused on adding back the assert
forgetting it wasn't safe in the first place. Attaching v3 based on v2, but instead of
asserting that the row return contains the primary clause column, it skips the row if it
doesn't contain it. That is, instead of asserting the non-corruption of the index, it
ignores any possible corruption. But more importantly (one could hope we don't have a bug
that corrupt indexes), it will avoid returning incoherent result to the user in the event
of a race between reads and writes.Trying to prevent the race from happening would require
synchronization with write, which will be much harder and less efficient. And we probably
need to have a fix for that out sooner than later (both the error when zero columns are
requested and the possibly to throw assertion errors wrongly).In the longer term, I think
we should explore the possibility of stopping to care whether our secondary indexes are
coherent at all time and repair them at read time as  this may allow us to get rid of the
read-before-write. But it's a longer term goal at best and work for another ticket. 


New Comment: 
+1 


New Comment: 
Integrated in Cassandra-0.7 #517 (See <a
href="https://builds.apache.org/job/Cassandra-0.7/517/" class="external-link"
rel="nofollow">https://builds.apache.org/job/Cassandra-0.7/517/</a>)<br/>    Fix scan
wrongly throwing assertion errors<br/>patch by slebresne; reviewed by jbellis for <a
href="https://issues.apache.org/jira/browse/CASSANDRA-2653" title="index scan errors out
when zero columns are requested" class="issue-link"
data-issue-key="CASSANDRA-2653"><del>CASSANDRA-2653</del></a>slebresne : <a
href="http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&amp;view=rev&amp;rev=1141129"
class="external-link"
rel="nofollow">http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&amp;view=rev&amp;rev=1141129</a><br/>Files
:
<ul>	<li>/cassandra/branches/cassandra-0.7/CHANGES.txt</li>	<li>/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/ColumnFamilyStore.java</li></ul> 


New Comment: 
Actually, after having committed it, I realize there is a few issue with the previous
patch. Two mostly:<ol>	<li>If the extraFilter query finds nothing (which it will only in
case of the race between write and reads), getColumnFamily() will return null and the
data.addAll() will NPE</li>	<li>For 0.8 and for counters, we must make really sure that
this extra query won't add column that were returned by the first query (which can happen
in the current code), otherwise we'll overcount. I think this is actually a bug that
predate the fix for this.</li></ol>Anyway, attaching 0001-Fix-scan-issue that fixes both
of those issue. It also add a slight optimization that avoids doing extra work if we know
an extra query won't help. 


New Comment: 
+1 


