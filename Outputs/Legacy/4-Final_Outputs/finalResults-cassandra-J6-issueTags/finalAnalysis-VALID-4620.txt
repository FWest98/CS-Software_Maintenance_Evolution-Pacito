Pattern changes caused by commit: 621d1f98639369717b6d09f8dd066b2a2d129e09

From: Decorator-0
To:   Decorator-1

From: Mediator-2
To:   Mediator-3


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-4620.txt 

commit 621d1f98639369717b6d09f8dd066b2a2d129e09
Author: Pavel Yaskevich <xedin@apache.org>

    Refactoring of the secondary index api
    patch by Jake Luciani; reviewed by Pavel Yaskevich for CASSANDRA-2982



==================================
 Issue CASSANDRA-2982 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-2982] Refactor secondary index api
-----------------

-----------------
Summary: Refactor secondary index api
-----------------

-----------------
Issue type: Sub-task
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Mon, 1 Aug 2011 18:53:24 +0000
-----------------

-----------------
Resolved at: Thu, 11 Aug 2011 10:56:40 +0000
-----------------

-----------------
Assigned to: T Jake Luciani
-----------------

-----------------
Description: 

Secondary indexes currently make some bad assumptions about the underlying indexes.

1.
That they are always stored in other column families.<br/>2. That there is a unique index
per column

In the case of <a href="https://issues.apache.org/jira/browse/CASSANDRA-2915"
title="Lucene based Secondary Indexes" class="issue-link"
data-issue-key="CASSANDRA-2915"><del>CASSANDRA-2915</del></a> neither of these are true. 
The new api should abstract the search concepts and allow any search api to plug in.

Once
the code is refactored and basically pluggable we can remove the IndexType enum and use
class names similar to how we handle partitioners and comparators.

Basic api is to add a
SecondaryIndexManager that handles different index types per CF and a SecondaryIndex base
class that handles a particular type implementation.

This requires major changes to
ColumnFamilyStore and Table.IndexBuilder
 

-----------------

-----------------
Comments: 

New Comment: 
refactored api, should cover new index types. Should we consider removing IndexType enum
and just use classname? 


New Comment: 
I don't think full index pluggability is a goal here.  So I don't see the point of that. 


New Comment: 
Want to give a high-level overview of the changes here? 


New Comment: 
Sure. I've abstracted the index management for a column family to SecondaryIndexManager.
For a particular column a index type can be specified that is implemented by a
SecondaryIndex subclass. Index building and updating works the same but is now
encapsulated by this API. <br/>The search API is abstracted by a custom
SecondaryIndexSearcher subclass which handles searching a IndexClause for columns of a
specific index type. This does not support searching across index types so all queries
must accept index expressions of the same index type. Otherwise you get an exception. The
one thing I might change is not exposing the cfs indexmanager variable and instead expose
all the index manager calls as part of the Cfs API that delegates to indexmanager. 


New Comment: 
Given this level of abstraction, I wonder if Jake's original suggestion about replacing
the IndexType enum with a classname makes more sense? 


New Comment: 
I'd prefer a class name, it's much more pluggable.  This makes sense given SecondaryIndex
is an abstract class. 


New Comment: 
Fix formatting and comments, other git merge problems 


New Comment: 
v3 with minor formatting/annotation fixes and refactorings. Rebased with latest trunk
(0bbc22c00dfcce3d0945e61e94dd91d78ed51a26).+1 with Jonathan on keeping IndexType as I
don't see the point of removing it and think that keeping public indexManager is fine and
convenient.So if nobody has any objections I think this is ready to be committed. Great
work, Jake! 


New Comment: 
For the Lucene secondary index, we need to report back the RAM consumed.  Then Cassandra
can, then when Memtable + Lucene RAM buffer exceeds the threshold we can and will flush
both.  Perhaps we can add an additional ram size method?This brings up another probable
issue, if Memtable flushes successfully and then Lucene is not able to commit. 


New Comment: 
+1 v3 


New Comment: 
<blockquote>if Memtable flushes successfully and then Lucene is not able to
commit</blockquote>for the existing indexes, we write the indexes first.  if we fail, the
"main" memtable will not be written.  if we succeed and the "main" memtable fails, the
main (technically, both, which is fine since the index flush is idempotent) will be
replayed from commitlog. 


New Comment: 
Committed. 


