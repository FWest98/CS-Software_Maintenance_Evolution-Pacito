Pattern changes caused by commit: 9392edf07298417f90263ec8bea0897afad9f574

From: Facade-1
To:   Facade-0


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-5424.txt 

commit 9392edf07298417f90263ec8bea0897afad9f574
Author: Jonathan Ellis <jbellis@apache.org>

    fix querying supercolumns by name
    patch by jbellis; reviewed by slebresne and tested by Mike Smith for CASSANDRA-3446



==================================
 Issue CASSANDRA-3446 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-3446] Problem SliceByNamesReadCommand on super column family after flush operation
-----------------

-----------------
Summary: Problem SliceByNamesReadCommand on super column family after flush operation
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Wed, 2 Nov 2011 16:15:25 +0000
-----------------

-----------------
Resolved at: Tue, 8 Nov 2011 17:55:31 +0000
-----------------

-----------------
Assigned to: Jonathan Ellis
-----------------

-----------------
Description: 

I'm having a problem with doing a multiget_slice on a super column family<br/>after its
first flush. Updates to the column values work properly, but<br/>trying to retrieve the
updated values using a multiget_slice operation fail<br/>to get the updated values.
Instead they return the values from before the<br/>flush. The problem is not apparent with
standard column families.

I've seen this problem in Cassandra v1.0.0 and v1.0.1. The
problem<br/>is not present in Cassandra v0.7.6.

Steps to reproduce:

   1. Create one or
more super column entries<br/>   2. Verify the sub column values can be updated and that
you can retrieve<br/>   the new values<br/>   3. Use nodetool to flush the column family
or restart cassandra<br/>   4. Update the sub column values<br/>   5. Verify they have
been updated using cassandra-cli<br/>   6. Verify you <b>DO NOT</b> get the updated values
when doing a<br/>   multiget_slice; instead you get the old values from before the
flush

You can get the most recent value by doing a flush followed by a
major<br/>compaction. However, future updates are not retrieved properly either.

With
debug turned on, it looks like the multiget_slice query uses the<br/>following
command/consistency level:<br/>SliceByNamesReadCommand(table='test_cassandra',
key=666f6f,<br/>columnParent='QueryPath(columnFamilyName='test',
superColumnName='null',<br/>columnName='null')', columns=<span
class="error">&#91;foo,&#93;</span>)/QUORUM.

Cassandra-cli uses the following
command/consistency level for a
get_slice:<br/>SliceFromReadCommand(table='test_cassandra',
key='666f6f',<br/>column_parent='QueryPath(columnFamilyName='test',
superColumnName='null',<br/>columnName='null')', start='', finish='',
reversed=false,<br/>count=1000000)/QUORUM

Notice the test program gets 'bar2' for the
column values and cassandra-cli<br/>gets 'bar3' for the column values:

tcpdump from test
program using hector-core:1.0-1

16:46:07.424562 IP iam.47158 &gt; iam.9160: Flags <span
class="error">&#91;P.&#93;</span>, seq 55:138, ack 30,<br/>win 257, options <span
class="error">&#91;nop,nop,TS val 27474096 ecr 27474095&#93;</span>, length
83<br/>E....#@.@.PK.........6#.....].8......{.....<br/>..8...8.........multiget_slice................foo..........test................foo.........<br/>16:46:07.424575
IP iam.9160 &gt; iam.47158: Flags <span class="error">&#91;.&#93;</span>, ack 138, win
256,<br/>options <span class="error">&#91;nop,nop,TS val 27474096 ecr
27474096&#93;</span>, length
0<br/>E..4..@.@.&lt;.........#..6].8..........(.....<br/>..8...8.<br/>16:46:07.428771 IP
iam.9160 &gt; iam.47158: Flags <span class="error">&#91;P.&#93;</span>, seq 30:173, ack
138,<br/>win 256, options <span class="error">&#91;nop,nop,TS val 27474097 ecr
27474096&#93;</span>, length
143<br/>@.@.&lt;&amp;........#..6].8................<br/>............foo...............foo...............foo1.......bar2<br/>........6h........foo2.......bar2<br/>........I.....

tcpdump
of cassandra-cli:

16:30:55.945123 IP iam.47134 &gt; iam.9160: Flags <span
class="error">&#91;P.&#93;</span>, seq 370:479, ack 5310,<br/>win 387, options <span
class="error">&#91;nop,nop,TS val 27246226 ecr 27241207&#93;</span>, length
109<br/>E.....@.@.9q..........#..n.X\<br/>.............<br/>................get_range_slices..............test.........................................................d.........<br/>16:30:55.945152
IP iam.9160 &gt; iam.47134: Flags <span class="error">&#91;.&#93;</span>, ack 479, win
256,<br/>options <span class="error">&#91;nop,nop,TS val 27246226 ecr
27246226&#93;</span>, length
0<br/>E..4..@.@.".........#...\<br/>...n.......(.....<br/>........<br/>16:30:55.949245 IP
iam.9160 &gt; iam.47134: Flags <span class="error">&#91;P.&#93;</span>, seq 5310:5461,
ack<br/>479, win 256, options <span class="error">&#91;nop,nop,TS val 27246227 ecr
27246226&#93;</span>, length
151<br/>E.....@.@."V........#...\<br/>...n.............<br/>....................get_range_slices...................foo..................foo...............foo1.......bar3<br/>........&amp;.........foo2.......bar3<br/>........:
.....
 

-----------------

-----------------
Comments: 

New Comment: 
Can you post your columnfamily create statement? 


New Comment: 
create keyspace test_cassandra;<br/>use test_cassandra;<br/>create column family test1
with column_type = 'Super' and comparator =<br/>'AsciiType';<br/>create column family
test2 with column_type = 'Standard' and comparator =<br/>'AsciiType'; 


New Comment: 
Is this just a single-node cluster? 


New Comment: 
Yes, single node cluster.On Wed, Nov 2, 2011 at 9:43 PM, Jonathan Ellis (Commented) (JIRA)
&lt; 


New Comment: 
Adds a unit test to ColumnFamilyStoreTest to reproduce the issue. 


New Comment: 
I had a similar problem and spent a fair amount of time tracking it down. It appears
related to a problem in collating data from Memtables and SStables, but only when the
query involves SuperColumnsI may have found a fix. It did solve the problem for me but I
haven't tested extensively for regressions or concurrency issues.<div class="code panel"
style="border-width: 1px;"><div class="codeContent panelContent"><pre
class="code-java"><span class="code-keyword">package</span> org.apache.cassandra.db;<span
class="code-keyword">public</span> <span class="code-keyword">class
</span>TreeMapBackedSortedColumns <span class="code-keyword">extends</span>
TreeMap&lt;ByteBuffer, IColumn&gt; <span class="code-keyword">implements</span>
ISortedColumns    /*     * If we find an old column that has the same name     * the ask
it to resolve itself <span class="code-keyword">else</span> add the <span
class="code-keyword">new</span> column    */    <span class="code-keyword">public</span>
void addColumn(IColumn column, Allocator allocator)    {        ByteBuffer name =
column.name();        IColumn oldColumn = put(name, column);        <span
class="code-keyword">if</span> (oldColumn != <span class="code-keyword">null</span>)      
 {            <span class="code-keyword">if</span> (oldColumn <span
class="code-keyword">instanceof</span> SuperColumn)            {                <span
class="code-keyword">assert</span> column <span class="code-keyword">instanceof</span>
SuperColumn;                ((SuperColumn) oldColumn).putColumn((SuperColumn)column,
allocator);                <span class="code-comment">// we need to restore the old value
here or things won't work! --norru@scee.net</span>                put(name, oldColumn);
<span class="code-comment">// &lt;--- here it is</span>            }            <span
class="code-keyword">else</span>            {                <span class="code-comment">//
calculate reconciled col from old (existing) col and <span class="code-keyword">new</span>
col</span>                IColumn reconciledColumn = column.reconcile(oldColumn,
allocator);                put(name, reconciledColumn);            }        }   
}</pre></div></div>Let me know if you need a proper patch. It's an one liner so it might
be easier for you to add the line yourself.Also let me know if you need more details.
Cheers! 


New Comment: 
There's at least two problems here.  One is the one Nicola describes.  The other is that
the name-based path in CollationController stops as soon as it finds one subcolumn in a
given supercolumn.Working on a patch for both. 


New Comment: 
There's a third bug involved, that can hide the second: SuperColumn.minTimestamp is
calculated incorrectly.Patch 01 adds tests for the two "main" bugs and fixes them.  Patch
02 removes SC.minTimestamp since part of the 01 fix is recognizing that we shouldn't
short-circuit a SuperColumn read, since we don't know how many potential subcolumns there
are without an exhaustive search. 


New Comment: 
I applied the patches to 1.0.2 and all looks good. Thanks a lot for the quick turn around
and keep up the good work!! 


New Comment: 
+1, good catches. 


New Comment: 
committed 


