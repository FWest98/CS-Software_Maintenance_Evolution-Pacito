Pattern changes caused by commit: fd3bfac6cbc487e36ac1c39740c5897e350d0d16

From: Flyweight-1
To:   Flyweight-3

From: Mediator-1
To:   Mediator-2


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-6531.txt 

commit fd3bfac6cbc487e36ac1c39740c5897e350d0d16
Author: Jonathan Ellis <jbellis@apache.org>

    make memory metering use an unbounded queue to avoid blocking the write path
    patch by pschuller and jbellis; reviewed by slebresne for CASSANDRA-4032



==================================
 Issue CASSANDRA-4032 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-4032] memtable.updateLiveRatio() is blocking, causing insane latencies for writes
-----------------

-----------------
Summary: memtable.updateLiveRatio() is blocking, causing insane latencies for writes
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Fri, 9 Mar 2012 15:10:22 +0000
-----------------

-----------------
Resolved at: Wed, 11 Apr 2012 18:27:14 +0000
-----------------

-----------------
Assigned to: Peter Schuller
-----------------

-----------------
Description: 

Reproduce by just starting a fresh cassandra with a heap large enough for live ratio
calculation (which is <tt>O<img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/thumbs_down.png" height="16"
width="16" align="absmiddle" alt="" border="0"/></tt>) to be insanely slow, and then
running <tt>./bin/stress -d host -n100000000 -t10</tt>. With a large enough heap and
default flushing behavior this is bad enough that stress gets timeouts.

Example ("blocked
for" is my debug log added around submit()):
<div class="code panel" style="border-width:
1px;"><div class="codeContent panelContent"><pre class="code-java"> INFO [MemoryMeter:1]
2012-03-09 15:07:30,857 Memtable.java (line 198) CFS(Keyspace=<span
class="code-quote">'Keyspace1'</span>, ColumnFamily=<span
class="code-quote">'Standard1'</span>) liveRatio is 8.89014894083727 (just-counted was
8.89014894083727).  calculation took 28273ms <span class="code-keyword">for</span> 1320245
columns WARN [MutationStage:8] 2012-03-09 15:07:30,857 Memtable.java (line 209) submit()
blocked <span class="code-keyword">for</span>: 231135</pre></div></div>
The calling code
was written assuming a RejectedExecutionException is thrown, but it's not because
<tt>DebuggableThreadPoolExecutor</tt> installs a blocking rejection handler.
 

-----------------

-----------------
Comments: 

New Comment: 
Attaching patch that allows us to create both blocking and non-blocking
<tt>DebuggableThreadPoolExecturor</tt>:s; use that for this particular case. 


New Comment: 
The DTPE change looks good, but don't you need a catch (Rejected) { } block in
updateLiveRatio? 


New Comment: 
There already is one, it's just a NOOP because of the blocking nature of the DTPE. 


New Comment: 
This is the code:<div class="code panel" style="border-width: 1px;"><div
class="codeContent panelContent"><pre class="code-java">        <span
class="code-keyword">try</span>        {            meterExecutor.submit(runnable);       
}        <span class="code-keyword">catch</span> (RejectedExecutionException e)        {  
         logger.debug(<span class="code-quote">"Meter thread is busy; skipping liveRatio
update <span class="code-keyword">for</span> {}"</span>, cfs);        }</pre></div></div> 


New Comment: 
Are we sure that what we want is a SynchronousQueue with task rejected? After all, there
is only on global memoryMeter, so we could end up failing to updateLiveRatio just based on
a race, even if calculations are fast. I'd suggest instead a bounded queue (but maybe not
infinite and we could indeed just skip task if that queue gets full). 


New Comment: 
<blockquote>This is the code:</blockquote>Either I'm blind or that's not in the attached
patch. 


New Comment: 
<blockquote>Either I'm blind or that's not in the attached patch.</blockquote>It's not.
It's <b>already there</b>, in the branch, committed. The code was written, I presume,
without the author realizing that RejectedExecutionException would never be thrown. 


New Comment: 
<blockquote>Are we sure that what we want is a SynchronousQueue with task rejected? After
all, there is only on global memoryMeter, so we could end up failing to updateLiveRatio
just based on a race, even if calculations are fast. I'd suggest instead a bounded queue
(but maybe not infinite and we could indeed just skip task if that queue gets
full).</blockquote>I agree it's fishy, though I'd suggest a separate ticket. This patch is
intended to make the code behave the way the original commit intended.This (from the code,
not my patch) seems legit though:<div class="code panel" style="border-width: 1px;"><div
class="codeContent panelContent"><pre class="code-java">    <span class="code-comment">//
we're careful to only allow one count to run at a time because counting is slow</span>   
<span class="code-comment">// (can be minutes, <span class="code-keyword">for</span> a
large memtable and a busy server), so we could keep memtables</span>    <span
class="code-comment">// alive after they<span class="code-quote">'re flushed and would
otherwise be GC'</span>d.</span></pre></div></div>We could have one queue per unique CF
and have a consumer that iterates over the set of queues, guaranteeing that each CF gets
processed once per "cycle". A simpler solution is probably preferable though if we can
think of one. 


New Comment: 
How about just having an unbounded queue but having each CF just keep a flag that says
whether or not there is a calculation currently pending or executing; it would be reset by
the task when executed, and CAS:ed in the write path. This; single queue, same DTPE. We'd
just submit a task with a reference to the AtomicBoolean which it will set to false on
completion. 


New Comment: 
(That seems simple enough to just do right now and not bother with a separate ticket. If
you agree I'll submit a patch.) 


New Comment: 
Sounds fine to me. 


New Comment: 
Attaching <tt>v2</tt>. Keeps NBHM mapping CFS -&gt; AtomicBoolean. Mappings are never
removed (assuming reasonably bound number of unique CFS:s during a lifetime). Queue used
for DTPE is unbounded. 


New Comment: 
(v2 doesn't keep the changes to DTPE, which are no longer used.) 


New Comment: 
v3 attached:<ul class="alternate" type="square">	<li>uses putIfAbsent in the AtomicBoolean
creation</li>	<li>drops the catch block around executor submission</li></ul> 


New Comment: 
Wouldn't using a ConcurrentSkipListSet simply the code? Feels like a lot of boilerplate to
record that there is already a metering running (it's not like this is a hot path enough
to justify the NBHM). 


New Comment: 
you're right; v4 attached w/ Set approach.(used NBHS instead of CSLS since the latter
requires defining a comparator.  I'm not sure the overhead is substantially different.) 


New Comment: 
+1 with two nits:<ul>	<li>In the comment "to a maximum of one per CFS using this map"
could have a s/map/set/</li>	<li>Note sure if there was an intent in changing the
maximumPoolSize of the meterExecutor to Integer.MAX_VALUE. As it stands, with an unbounded
queue the maximumPoolSize is ignored so that doesn't really matter, but just wanted to
mention it.</li></ul> 


