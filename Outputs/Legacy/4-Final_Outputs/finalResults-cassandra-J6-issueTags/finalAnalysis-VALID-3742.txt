Pattern changes caused by commit: ef47618115159608aa276077a1004da404e8efce

From: Abstract Factory-3
To:   Abstract Factory-2

From: Factory Method-3
To:   Factory Method-2

From: Mediator-2
To:   Mediator-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-3742.txt 

commit ef47618115159608aa276077a1004da404e8efce
Author: Sylvain Lebresne <slebresne@apache.org>

    Purge tombstone from row cache (0.7 version)
    patch by slebresne; reviewed by jbellis for CASSANDRA-2305



==================================
 Issue CASSANDRA-2305 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-2305] Tombstoned rows not purged from cache after gcgraceseconds
-----------------

-----------------
Summary: Tombstoned rows not purged from cache after gcgraceseconds
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Thu, 10 Mar 2011 04:39:30 +0000
-----------------

-----------------
Resolved at: Sun, 10 Apr 2011 18:50:03 +0000
-----------------

-----------------
Assigned to: Sylvain Lebresne
-----------------

-----------------
Description: 

From email to list:

I was wondering if this is the expected behavior of deletes (0.7.0).
Let's say I have a 1-node cluster with a single CF which has gc_grace_seconds = 0. The
following sequence of operations happens (in the given order):

insert row X with
timestamp T<br/>delete row X with timestamp T+1<br/>force flush + compaction<br/>insert
row X with timestamp T

My understanding is that the tombstone created by the delete (and
row X) will disappear with the flush + compaction which means the last insertion should
show up. My experimentation, however, suggests otherwise (the last insertion does not show
up).

I believe I have traced this to the fact that the markedForDeleteAt field on the
ColumnFamily does not get reset after a compaction (after gc_grace_seconds has passed); is
this desirable? I think it introduces an inconsistency in how tombstoned columns work
versus tombstoned CFs. Thanks.
 

-----------------

-----------------
Comments: 

New Comment: 
For a little more info, I think this only happens when you remove an entire row. If you
delete specific columns, the tombstones are handled appropriately. 


New Comment: 
This will also happen if you remove all the columns inside the row (even though you didn't
issued a row deletion command).The problem is that when you flush + compact and gcGrace
has elapsed, if the row is empty (i.e. all tombstone have been collected), the row itself
is collected. This means that when you issue the second wave of inserts, there is no trace
whatsoever of the row.That's why you are not supposed to have a gcGrace too low and why it
is highly advised to use the current time as a timestamp. If so, the scenario above will
never happen.Best thing we can do is probably to edit <a
href="http://wiki.apache.org/cassandra/DistributedDeletes" class="external-link"
rel="nofollow">http://wiki.apache.org/cassandra/DistributedDeletes</a> to add that gcGrace
should be such that no insert with a timestamp lower that a delete could reach any given
node after gcGrace has elapsed. 


New Comment: 
<blockquote>The problem is that when you flush + compact and gcGrace has elapsed, if the
row is empty (i.e. all tombstone have been collected), the row itself is collected. This
means that when you issue the second wave of inserts, there is no trace whatsoever of the
row.</blockquote>That's what's supposed to happen, but Jeffrey is saying that is NOT what
he observes. 


New Comment: 
Oups, my mistake. I somehow confused myself. I was not able to reproduce though, but I'll
try harder tomorrow. 


New Comment: 
I think this is due to row cache. We do not invalidate the row cache when a row is fully
collected by compaction.Jeffrey, can you confirm that you had some row cache enabled when
doing your experiments ?Attaching 2 patch against 0.7. The first one is a unit test
showing the failure, the second one is the fix. 


New Comment: 
committed 


New Comment: 
I actually don't have row cache enabled (I just checked cfstats to make sure), so I don't
think that's the cause of my problem in particular. Here's some more info that may or may
not be correct:<ul class="alternate" type="square">	<li>When I run the compaction, in
ColumnFamilyStore.removeDeletedStandard() I see that columns are being removed because of
the c.timestamp() &lt;= cf.getMarkedForDeleteAt() condition, which makes sense since I
issued a delete on the entire row.</li>	<li>However, after the compaction, I do the
insert, and if I flush/compact again, I still see the columns being removed because of
that condition. It seems like the markedForDeleteAt field on the ColumnFamily is
persisting across the major compaction which I believe is hiding the newly inserted
column.</li></ul>Also, my initial steps to repro were not correct, which made it hard to
figure out the root cause. Here is a proper repro:<ul class="alternate"
type="square">	<li>Create a CF with gc_grace_seconds = 0 and no row cache.</li>	<li>Insert
row X, col A with timestamp 0.</li>	<li>Insert row X, col B with timestamp
2.</li>	<li>Remove row X with timestamp 1 (expect col A to disappear, col B to
stay).</li>	<li>Wait 1 second.</li>	<li>Force flush and compaction.</li>	<li>Insert row X,
col A with timestamp 0.</li>	<li>Read row X, col A (see nothing).</li></ul>Inserting row
X, col B is necessary for this to repro because if all the columns in a row disappear, the
ColumnFamily object goes away and the markedForDeleteAt field is reset. Only when a column
still exists does the field persist across the compaction. Hope this helps! 


New Comment: 
I believe the cause to be something else (see latest comment). 


New Comment: 
Integrated in Cassandra-0.7 #375 (See <a
href="https://hudson.apache.org/hudson/job/Cassandra-0.7/375/" class="external-link"
rel="nofollow">https://hudson.apache.org/hudson/job/Cassandra-0.7/375/</a>) 


New Comment: 
Ok, I understand what you meant. I've created <a
href="https://issues.apache.org/jira/browse/CASSANDRA-2317" title="Column family deletion
time is not always reseted after gc_grace" class="issue-link"
data-issue-key="CASSANDRA-2317"><del>CASSANDRA-2317</del></a> with the fix since we have
already committed a patch here. Thanks a lot for the report. 


New Comment: 
Remarking this resolved, the follow up is in <a
href="https://issues.apache.org/jira/browse/CASSANDRA-2317" title="Column family deletion
time is not always reseted after gc_grace" class="issue-link"
data-issue-key="CASSANDRA-2317"><del>CASSANDRA-2317</del></a> instead. 


New Comment: 
I'm reopening because the committed patch, while ok, is only a partial fix. 


New Comment: 
The first patch was purging the cache when the full row is expired. But we don't remove
expired tombstone from the cache.Attaching a second patch to purge the cache. This has two
purposes: <ol>	<li>avoid surprise for client getting tombstones back from query (either
sstable2json or rangeSlice) even well after gc_grace and compaction has
occured</li>	<li>reclaim some memory for row sitting in the cache for a very long
time</li></ol>Note that this patch introduces concurrent deletes, and as such SHOULDN'T be
applied to a branch that do not have <a
href="https://issues.apache.org/jira/browse/CASSANDRA-1559" title="make
{SuperColumn,ColumnFamily}.addColumn() correct in the face of concurrent removals"
class="issue-link" data-issue-key="CASSANDRA-1559"><del>CASSANDRA-1559</del></a> (0.7 and
0.8 have it).Patch is against 0.7 


New Comment: 
+1 


New Comment: 
Committed to 0.7 (r1090867) and a rebased version to trunk (r1090866) 


New Comment: 
Integrated in Cassandra-0.7 #429 (See <a
href="https://hudson.apache.org/hudson/job/Cassandra-0.7/429/" class="external-link"
rel="nofollow">https://hudson.apache.org/hudson/job/Cassandra-0.7/429/</a>)<br/>    Purge
tombstone from row cache (0.7 version)<br/>patch by slebresne; reviewed by jbellis for <a
href="https://issues.apache.org/jira/browse/CASSANDRA-2305" title="Tombstoned rows not
purged from cache after gcgraceseconds" class="issue-link"
data-issue-key="CASSANDRA-2305"><del>CASSANDRA-2305</del></a> 


