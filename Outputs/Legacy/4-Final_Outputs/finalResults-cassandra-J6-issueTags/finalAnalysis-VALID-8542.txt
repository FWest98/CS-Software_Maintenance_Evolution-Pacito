Pattern changes caused by commit: 9c8d949301f1f082362225934cfeddd0d2cbe982

From: Abstract Factory-1
To:   Abstract Factory-2

From: Factory Method-1
To:   Factory Method-2

From: Decorator-2
To:   Decorator-1

From: Facade-0
To:   Facade-1

From: Flyweight-3
To:   Flyweight-2

From: Mediator-3
To:   Mediator-1

From: Strategy-0
To:   Strategy-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-8542.txt 

commit 9c8d949301f1f082362225934cfeddd0d2cbe982
Author: Jonathan Ellis <jbellis@apache.org>

    fix sstable maxtimestamp forrow deletes andpre-1.1.1 sstables
    patch by jbellis; reviewed by slebresne for CASSANDRA-5153



==================================
 Issue CASSANDRA-5153 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-5153] max client timestamp
-----------------

-----------------
Summary: max client timestamp
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Mon, 14 Jan 2013 03:16:03 +0000
-----------------

-----------------
Resolved at: Thu, 24 Jan 2013 14:58:34 +0000
-----------------

-----------------
Assigned to: Jonathan Ellis
-----------------

-----------------
Description: 

1. In public LazilyCompactedRow(CompactionController controller, List&lt;? extends
ICountableColumnIterator&gt; rows)<br/>   columnStats = new ColumnStats(reducer == null ?
0 : reducer.columns, reducer == null ? Long.MIN_VALUE : reducer.maxTimestampSeen,<br/>    
                                 reducer == null ? new
StreamingHistogram(SSTable.TOMBSTONE_HISTOGRAM_BIN_SIZE) : reducer.tombstones

  Tthe
maxTimestampSeen should be max(emptyColumnFamily.deletionInfo().maxTimestamp(),
reducer.maxTimestampSeen)?

2. In private ColumnFamily collectTimeOrderedData()<br/>      
         // if we've already seen a row tombstone with a timestamp greater<br/>           
    // than the most recent update to this sstable, we're done, since the rest of the
sstables<br/>                // will also be older<br/>                if
(sstable.getMaxTimestamp() &lt; mostRecentRowTombstone)<br/>                    break;
<br/>   In the case that sstable.getMaxTimestamp == Long.MIN_VALUE, is it logical?
 

-----------------

-----------------
Comments: 

New Comment: 
What about max client timestamp? 


New Comment: 
Any ideas?<br/>Thanks 


New Comment: 
I think you're right.  Patch attached to fix and to treat old sstables with MAX_VALUE
instead of MIN. 


New Comment: 
I think the correct fix in LCR would be:<div class="preformatted panel"
style="border-width: 1px;"><div class="preformattedContent panelContent"><pre>markedAt =
emptyColumnFamily.getMarkedForDeleteAt();maxTimestamp = reducer == null ? markedAt :
Math.max(markedAt, reducer.maxTimestampSeen);</pre></div></div>because <tt>reducer ==
null</tt> implies there is no columns for that row in any of the source SSTable, and thus
guarantees we have a row tombstone (otherwise we wouldn't have written the row in the
first place). And in fact, even if we were to write non-tombstoned empty rows, then
MIN_VALUE would be the correct value for maxTimestamp.Also, while the default of MIN_VALUE
for old non-timestamp-tracking sstables is clearly bogus and should be fixed, I would
almost suggest not bumping the sstable version (I'm still hesitant but leaning towards not
doing it). The rational is that there are only 2 cases currently where a sstable can have
a MIN_VALUE max timestamp:<ol>	<li>the sstable is a pre-1.0.10 one that don't track
timestamp. Fixing SSTableMetada fixes that part.</li>	<li>the sstable is entirely and
uniquely composed of row tombstones.</li></ol>The version bump is "fixing" only the latter
but at the price of temporarly breaking the collectTimeOrderedData optimization for
everyone that will upgrade to the version containing this. Granted collectTimeOrderedData
is "just an optimization", but having a sstable entirely composed of row tombstones is a
pretty remote risk. And besides, for it to trigger a problem you actually need at least 2
sstables entirely composed of row tombstones (and even then there is no guaranteed you'll
get the bug). Feels even more than remote. 


