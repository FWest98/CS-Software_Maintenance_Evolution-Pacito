Pattern changes caused by commit: a853d7e40f75bec7046a04d83b9c9a01d72a3cef

From: Facade-1
To:   Facade-0


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-5414.txt 

commit a853d7e40f75bec7046a04d83b9c9a01d72a3cef
Author: Jonathan Ellis <jbellis@apache.org>

    fix handling of rows with no columns
    patch by pyaskevich and jbellis for CASSANDRA-3424



==================================
 Issue CASSANDRA-3424 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-3424] Selecting just the row_key returns nil instead of just the row_key
-----------------

-----------------
Summary: Selecting just the row_key returns nil instead of just the row_key
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Sun, 30 Oct 2011 12:22:41 +0000
-----------------

-----------------
Resolved at: Mon, 2 Apr 2012 16:27:28 +0000
-----------------

-----------------
Assigned to: Jonathan Ellis
-----------------

-----------------
Description: 

CREATE KEYSPACE CassandraCQLTestKeyspace WITH
strategy_class='org.apache.cassandra.locator.SimpleStrategy' AND
strategy_options:replication_factor=1<br/>USE CassandraCQLTestKeyspace<br/>CREATE
COLUMNFAMILY row_key_validation_cf_ascii (id ascii PRIMARY KEY, test_column
text)<br/>INSERT INTO row_key_validation_cf_ascii (id, test_column) VALUES ('test string',
'test')
<ol>	<li>Works as expected<br/>SELECT * FROM row_key_validation_cf_ascii WHERE id
= 'test string'</li></ol><ol>	<li>Returns an empty result, unexpected<br/>SELECT id FROM
row_key_validation_cf_ascii WHERE id = 'test string'</li></ol> 

-----------------

-----------------
Comments: 

New Comment: 
Odd, that should be handled by this code:<div class="code panel" style="border-width:
1px;"><div class="codeContent panelContent"><pre class="code-java">.                      
    <span class="code-keyword">if</span> (term.getText().equalsIgnoreCase(keyString))     
                      {                                <span class="code-comment">//
preserve <span class="code-keyword">case</span> of key as it was requested</span>         
                      ByteBuffer requestedKey = ByteBufferUtil.bytes(term.getText());     
                          thriftColumns.add(<span class="code-keyword">new</span>
Column(requestedKey).setValue(row.key.key).setTimestamp(-1));                             
  result.schema.name_types.put(requestedKey, TypeParser.getShortName(AsciiType.instance));
                               result.schema.value_types.put(requestedKey,
TypeParser.getShortName(metadata.getKeyValidator()));                                <span
class="code-keyword">continue</span>;                            }</pre></div></div> 


New Comment: 
I think we can do a simpler fix actually (v2).  We actually <b>always</b> want a row in
the resultset for each row that exists in the database; the original "skip null CF" code
is flat out wrong.  Consider these cases:<div class="preformatted panel"
style="border-width: 1px;"><div class="preformattedContent panelContent"><pre>SELECT *
FROM foo WHERE key = 'bar';SELECT x..y FROM foo WHERE key = 'bar';SELECT key, x, y FROM
foo WHERE key = 'bar';SELECT x, y FROM foo WHERE key = 'bar';</pre></div></div>In none of
these cases should we leave the row out of the resultset if there were no columns found
(but the row exists).  (Possible exception for the * case aka "range ghosts" but for now
that is the behavior we deliver.)So, v2 removes the "leave nulls out entirely" check and
adds NPE protection to the columnRange case. 


New Comment: 
I was relying on the current logic but in case we always wan't results than +1. 


New Comment: 
committed 


New Comment: 
<blockquote>In none of these cases should we leave the row out of the resultset if there
were no columns found (but the row exists).</blockquote>The effect of this change is that
a SELECT by-key will always return at least one row result, no matter the key.Other than
the <tt>row.cf == null</tt> test, I'm not sure how you would distinguish between a row
that existed, or not, when there are no column results to return. 


New Comment: 
This change didn't do what it was supposed to, and it introduced a breaking CQL change,
(which has since made it into stable release updates<img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/warning.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>).  If we'd have caught this before it was
rolled into a release, I'd say it warranted an immediate -1 and a revert.We haven't been
doing nearly as well as I'd hoped in keeping stability promises, but I might be satisfied
to call the original behavior buggy, and the intended behavior of this change as the fix,
if it could be made to work the way intended (to return the result <em>if</em> the row
exists).  Can anyone see a way to accomplish that? 


New Comment: 
<blockquote>This change didn't do what it was supposed to</blockquote>To be clear, it
<b>did</b> fix the reported problem, of rows not being returned when they <b>did</b>
exist. Of course, now we have the opposite problem, as reported in <a
href="https://issues.apache.org/jira/browse/CASSANDRA-3505" title="Explicitly requested
keys will always be present in resultset" class="issue-link"
data-issue-key="CASSANDRA-3505"><del>CASSANDRA-3505</del></a>. 


New Comment: 
It doesn't seem possible to distinguish between existing and non-existant keys currently,
would it be the good idea to revert this one? Or just close it and move all discussion to
<a href="https://issues.apache.org/jira/browse/CASSANDRA-3505" title="Explicitly requested
keys will always be present in resultset" class="issue-link"
data-issue-key="CASSANDRA-3505"><del>CASSANDRA-3505</del></a>? 


New Comment: 
OK, so stepping a back a bit...If we have semantics which are stable and expected in some
version, and we alter those in a future version (for anything other than a major version
change), that is a regression.  So even if this patch had done what it intended to do, it
would be a regression, and we have always fixed regressions as quickly as possible.While
it would make it no less of a regression, if this change had resulted in SQL semantics, it
could be considered an improvement, but that is not the case.  The pre-3424 behavior at
least benefits from being consistent with how the RPC interface works, and every prior
CQL-enabled version of Cassandra.So I believe we should revert this change
because:<ol>	<li>It signals that we are serious about maintaining the contract we've made
with our users</li>	<li>The original behavior (while not ideal) better satisfies the
element of least-surprise</li></ol> 


New Comment: 
My point is that by your definition, changing behavior that is "stable and expected" in
1.0.4+, is <b>also</b> a regression, whether or not it was introduced by a regression
itself.I do not agree that the original behavior better satisfied least surprise. 


New Comment: 
I look at it this way: Are there more users of 1.0.0 .. 1.0.3 out there, who will be
surprised when they upgrade to 1.0.7 if we leave it be?  Or users of 1.0.4 .. 1.0.6, who
will be surprised when they upgrade if we change it?  <b>That's</b> the most responsible
way to signal we're taking stability seriously.I don't know for sure, but 1.0.0 .. 1.0.3
had enough problems that I doubt many people are still using them. 


New Comment: 
<blockquote>I look at it this way: Are there more users of 1.0.0 .. 1.0.3 out there, who
will be surprised when they upgrade to 1.0.7 if we leave it be?</blockquote>Shouldn't we
include the versions from the 0.8 series in this as well?<blockquote>Or users of 1.0.4 ..
1.0.6, who will be surprised when they upgrade if we change it? That's the most
responsible way to signal we're taking stability seriously.</blockquote>If you're
suggesting that we fix regressions as soon as they are identified as such, instead of
propagating them across 3 more releases because we prefer the new behavior, then I
emphatically agree. 


New Comment: 
<blockquote>Shouldn't we include the versions from the 0.8 series in this as
well?</blockquote>IMO?  No, because we changed enough other CQL behavior from 0.8 to 1.0
that they have bigger things to worry about.<blockquote>If you're suggesting that we fix
regressions as soon as they are identified as such, instead of propagating them across 3
more releases because we prefer the new behavior, then I emphatically
agree.</blockquote>Fine, mea culpa.  We should have reverted this for 1.0.5.  I'm sorry
that I had other priorities at the time.  But today the relevant issue is what the
responsible thing to do is for 1.0.7 given the background I outlined, not what I should
have done a month ago. 


New Comment: 
I was off on the dates &#8211; I thought 1.0.4 was released before we realized <a
href="https://issues.apache.org/jira/browse/CASSANDRA-3505" title="Explicitly requested
keys will always be present in resultset" class="issue-link"
data-issue-key="CASSANDRA-3505"><del>CASSANDRA-3505</del></a> was caused by this, but it
was not.  I had time to revert before this regression got into the wild, but didn't. 
Sorry! 


New Comment: 
Updated documentation:<a
href="https://github.com/eevans/cassandra/commit/a8d0135fe008dcb8754dcb9d5a173228bef30e0c"
class="external-link"
rel="nofollow">https://github.com/eevans/cassandra/commit/a8d0135fe008dcb8754dcb9d5a173228bef30e0c</a>
(diff) <a href="https://github.com/eevans/cassandra/tree/3424" class="external-link"
rel="nofollow">https://github.com/eevans/cassandra/tree/3424</a> (branch) 


