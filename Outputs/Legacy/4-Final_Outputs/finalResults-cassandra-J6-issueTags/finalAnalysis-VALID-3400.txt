Pattern changes caused by commit: 1f073123f61dd7245d1412adbccd4be2337705cf

From: Abstract Factory-3
To:   Abstract Factory-2

From: Factory Method-3
To:   Factory Method-2


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-3400.txt 

commit 1f073123f61dd7245d1412adbccd4be2337705cf
Author: Jonathan Ellis <jbellis@apache.org>

    throw EOFException when seeking past EOF in read-only mode
    patch by Pavel Yaskevich; reviewed by tjake and jbellis for CASSANDRA-2256



==================================
 Issue CASSANDRA-2256 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-2256] BRAF assertion error
-----------------

-----------------
Summary: BRAF assertion error
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Mon, 28 Feb 2011 21:29:06 +0000
-----------------

-----------------
Resolved at: Thu, 3 Mar 2011 16:44:20 +0000
-----------------

-----------------
Assigned to: Pavel Yaskevich
-----------------

-----------------
Description: 

While investigating <a href="https://issues.apache.org/jira/browse/CASSANDRA-2240"
title="nodetool scrub hangs or throws an exception" class="issue-link"
data-issue-key="CASSANDRA-2240"><del>CASSANDRA-2240</del></a> I ran into this:
<div
class="preformatted panel" style="border-width: 1px;"><div class="preformattedContent
panelContent"><pre>java.lang.AssertionError        at
org.apache.cassandra.io.util.BufferedRandomAccessFile.read(BufferedRandomAccessFile.java\:230)
       at java.io.RandomAccessFile.readByte(RandomAccessFile.java:589)        at
org.apache.cassandra.utils.ByteBufferUtil.readShortLength(ByteBufferUtil.java:273)       
at org.apache.cassandra.utils.ByteBufferUtil.readWithShortLength(ByteBufferUtil.java:284) 
      at
org.apache.cassandra.db.CompactionManager.doScrub(CompactionManager.java:539)</pre></div></div> 

-----------------

-----------------
Comments: 

New Comment: 
Test for the problem:<div class="code panel" style="border-width: 1px;"><div
class="codeContent panelContent"><pre class="code-java"><span
class="code-keyword">public</span> void testAssertOnRead() <span
class="code-keyword">throws</span> IOException    {        BufferedRandomAccessFile file =
createTempFile(<span class="code-quote">"braf"</span>);        file.write(<span
class="code-keyword">new</span> <span class="code-object">byte</span>[10]);       
file.sync();        BufferedRandomAccessFile copy = <span class="code-keyword">new</span>
BufferedRandomAccessFile(file.getPath(), <span class="code-quote">"r"</span>);       
copy.seek(15);        copy.read();        file.close();        copy.close();   
}</pre></div></div>This happens when you are trying to seek to position &gt; file length
on read-only file and then read (because fileLength is cached, method isEOF() does not
work properly). I don't think that we should allow such seeks. 


New Comment: 
Technically RAF.seek allows seeking beyond EOF and writing there (presumably the
intervening space would be filled with 0?) but Cassandra doesn't use this and it's kind of
a weird corner case.  There's a pretty strong assumption in BRAF that current &lt;=
EOF.So, I would be okay with throwing EOFException if you try to seek past EOF. 


New Comment: 
Is there a way to do this w/o calling channel.size() for each seek?  We seek twice for
every row written, and channel.size() is fairly expensive. 


New Comment: 
There is no way to skip this unless we will check this only for read-only files. 


New Comment: 
throwing EOF is good.Regarding the check of length on every seek for writable files, I
think you could change it to see if the seek is &lt; bufferOffset + buffer.length before
calling length() 


New Comment: 
It is also half-solving, I think we can check that for read-only files and for writable we
can leave this as is (makes perfect sense), any counter-argument? 


New Comment: 
The counter argument is we call seek() 2 times for every row in SSTableWriter.So we need
to make sure we don't call stat() unless we have no other choice.<br/>Another approach
would be to set fileLength based on the total number of bytes from the starting size, or 0
for a new file... 


New Comment: 
if we will be doing this for read-only condition will be <div class="code panel"
style="border-width: 1px;"><div class="codeContent panelContent"><pre
class="code-java"><span class="code-keyword">if</span> (fileLength != -1 &amp;&amp;
newPosition &gt; fileLength)    <span class="code-keyword">throw</span> <span
class="code-keyword">new</span> EOFException();</pre></div></div>this won't call
channel.size() or do any expensive calculations like length() 


New Comment: 
Oh so you mean let the it throw an AssertionError if you try to seek beyond the end of a
file in "rw" mode? 


New Comment: 
Not a fan of relying on assert when we really want EOFException. 


New Comment: 
Seems that we don't understand each other here <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>seek method will look like this:<div
class="code panel" style="border-width: 1px;"><div class="codeContent panelContent"><pre
class="code-java">    <span class="code-keyword">public</span> void seek(<span
class="code-object">long</span> newPosition) <span class="code-keyword">throws</span>
IOException    {        <span class="code-keyword">if</span> (newPosition &lt; 0)         
  <span class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalArgumentException(<span class="code-quote">"<span class="code-keyword">new</span>
position should not be negative"</span>);        <span class="code-keyword">if</span>
(fileLength != -1 &amp;&amp; newPosition &gt; fileLength)            <span
class="code-keyword">throw</span> <span class="code-keyword">new</span> EOFException(<span
class="code-quote">"unable to seek past the end of the file in read-only mode."</span>);  
     current = newPosition;        <span class="code-keyword">if</span> (newPosition &gt;=
bufferOffset + validBufferBytes || newPosition &lt; bufferOffset)            reBuffer();
<span class="code-comment">// <span class="code-keyword">this</span> will set bufferEnd
<span class="code-keyword">for</span> us</span>    }</pre></div></div>We set fileLength =
-1 for "rw" mode and caching fileLength = channel.size() for "r" mode files, so condition
"fileLength != -1 &amp;&amp; newPosition &gt; fileLength" will allow us to block seeking
past the end of the file in "r" mode leaving "rw" untouched (which makes a good sense even
if it's unused right now and lets us avoid calling length() for every seek()). 


New Comment: 
Right, but what happens if you try to seek past the end of a file in "rw" mode? 


New Comment: 
That will be allowed as it is right now but that won't create any problems because length
of the file is dynamic in that case and isEOF() method will be working properly. 


New Comment: 
If that's tested and proven then I don't see an issue with using the code snippet above. 


New Comment: 
Yes, it is. I will attach v2 patch asap. 


New Comment: 
committed with additional test that writing past EOF actually works 


