Pattern changes caused by commit: d2eadba2a6fe174aa94309deb487ff6391674847

From: Abstract Factory-1
To:   Abstract Factory-2

From: Factory Method-1
To:   Factory Method-2

From: Decorator-2
To:   Decorator-1

From: Facade-0
To:   Facade-1

From: Flyweight-2
To:   Flyweight-1

From: Mediator-3
To:   Mediator-1

From: Strategy-0
To:   Strategy-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-9096.txt 

commit d2eadba2a6fe174aa94309deb487ff6391674847
Author: Brandon Williams <brandonwilliams@apache.org>

    Remove synchronization in long-running PCRS
    Patch by Oleg Kibirev, reviewed by brandonwilliams for CASSANDRA-5456



==================================
 Issue CASSANDRA-5456 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-5456] Large number of bootstrapping nodes cause gossip to stop working
-----------------

-----------------
Summary: Large number of bootstrapping nodes cause gossip to stop working
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Thu, 11 Apr 2013 18:44:13 +0000
-----------------

-----------------
Resolved at: Fri, 12 Apr 2013 17:13:38 +0000
-----------------

-----------------
Assigned to: Oleg Kibirev
-----------------

-----------------
Description: 

Long running section of code in PendingRangeCalculatorService is synchronized on
bootstrapTokens. This causes gossip to stop working as it waits for the same lock when a
large number of nodes (hundreds in our case) are bootstrapping. Consequently, the whole
cluster becomes non-functional. 

I experimented with the following change in
PendingRangeCalculatorService.java and it resolved the problem in our case. Prior code had
synchronized around the for loop.

synchronized(bootstrapTokens) {<br/>    bootstrapTokens
= new LinkedHashMap&lt;Token, InetAddress&gt;(bootstrapTokens);<br/>}

for
(Map.Entry&lt;Token, InetAddress&gt; entry : bootstrapTokens.entrySet())<br/>{<br/>  
InetAddress endpoint = entry.getValue();

  
allLeftMetadata.updateNormalToken(entry.getKey(), endpoint);<br/>   for
(Range&lt;Token&gt; range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))<br/>
  pendingRanges.put(range, endpoint);<br/>  
allLeftMetadata.removeEndpoint(endpoint);<br/>}
 

-----------------

-----------------
Comments: 

New Comment: 
Making a copy of bootstrapTokens rather than holding a lock on the same for entire time
consuming loop. 


New Comment: 
Making a copy of bootstrapTokens before a time consuming loop rather than holding a
synchronized lock for the whole duration 


