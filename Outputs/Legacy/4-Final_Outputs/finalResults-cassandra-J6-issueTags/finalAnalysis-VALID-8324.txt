Pattern changes caused by commit: 8a3b29174b7b6ed921b93fe604fac95afd1d8924

From: Abstract Factory-1
To:   Abstract Factory-2

From: Factory Method-1
To:   Factory Method-2

From: Decorator-2
To:   Decorator-1

From: Facade-0
To:   Facade-1

From: Flyweight-2
To:   Flyweight-1

From: Mediator-3
To:   Mediator-1

From: Strategy-0
To:   Strategy-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-8324.txt 

commit 8a3b29174b7b6ed921b93fe604fac95afd1d8924
Author: Jonathan Ellis <jbellis@apache.org>

    improve validation for start key, end token ranges
    patch by jbellis; reviewed by dbrosius for CASSANDRA-5089



==================================
 Issue CASSANDRA-5089 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-5089] get_range_slices does not validate end_token
-----------------

-----------------
Summary: get_range_slices does not validate end_token
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Sun, 23 Dec 2012 21:04:29 +0000
-----------------

-----------------
Resolved at: Wed, 9 Jan 2013 22:29:05 +0000
-----------------

-----------------
Assigned to: Jonathan Ellis
-----------------

-----------------
Description: 

get_range_slices times out, java log has the following exception:<br/>ERROR <span
class="error">&#91;Thrift:1&#93;</span> 2012-12-22 08:14:30,120
AbstractCassandraDaemon.java (line 135) Exception in thread Thread<span
class="error">&#91;Thrift:1,5,main&#93;</span><br/>java.lang.AssertionError: <span
class="error">&#91;DecoratedKey(28555413689034504124051437792156504,
6434313866653035643631663962323635323937343337653666636265616162),max(0)&#93;</span><br/> 
      at org.apache.cassandra.dht.Bounds.&lt;init&gt;(Bounds.java:45)<br/>        at
org.apache.cassandra.dht.Bounds.&lt;init&gt;(Bounds.java:38)<br/>        at
org.apache.cassandra.thrift.CassandraServer.get_range_slices(CassandraServer.java:698)<br/>
       at
org.apache.cassandra.thrift.Cassandra$Processor$get_range_slices.getResult(Cassandra.java:3083)<br/>
       at
org.apache.cassandra.thrift.Cassandra$Processor$get_range_slices.getResult(Cassandra.java:3071)<br/>
       at org.apache.thrift.ProcessFunction.process(ProcessFunction.java:32)<br/>       
at org.apache.thrift.TBaseProcessor.process(TBaseProcessor.java:34)<br/>        at
org.apache.cassandra.thrift.CustomTThreadPoolServer$WorkerProcess.run(CustomTThreadPoolServer.java:186)<br/>
       at
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)<br/>      
 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)<br/>  
     at java.lang.Thread.run(Thread.java:722)

We see it every time on the SECOND
get_range_slices call when we clear start_token and set start_key in the key range.<br/>We
noticed this in 1.1.7 first, 1.1.8 still affected. 1.1.6 is fine.<br/>Please contact me if
you need more information.
 

-----------------

-----------------
Comments: 

New Comment: 
It looks like you are specifying start_key and end_token, with an invalid end_token. 
Don't do that.  (If you want to specify "the rest of the token range" then use end_key=""
and leave end_token null.) 


New Comment: 
Prior to <a href="https://issues.apache.org/jira/browse/CASSANDRA-4804" title="Wrong
assumption for KeyRange about range.end_token in get_range_slices()." class="issue-link"
data-issue-key="CASSANDRA-4804"><del>CASSANDRA-4804</del></a> we always ignored end_token
which is why this is biting you now.Patch attached to add extra validation so we don't
rely on AssertionError to stop this. 


New Comment: 
what is the proper format for token? I assumed it is decimal string. I think it is worked
in 1.1.6<br/>re using end_key="": start_key + end_token range has its very valid use case,
when the whole data set should be processed (think of map/reduce) on multiple distributed
workers. We split the ring into N parts, every worker start with (start_token - end_token)
range, when first batch is received it switches to (star_key - end_token).
ColumnFamilyRecordReader is cheating here by using internals for calculating
token:<br/>startToken =
partitioner.getTokenFactory().toString(partitioner.getToken(Iterables.getLast(rows).key));<br/>unfortunately
it is not an option for us, we are using C++<br/>So, what is the proper format for token
and how to do iteration over several ranges?<br/>Thank you. 


New Comment: 
simplified v2 attached 


New Comment: 
v2 lgtm, assuming we don't allow a crazy combination of range.start_key and
range.end_token or such.also note, pushing to trunk will not compile cleanly as on trunk
throws of IRE needs to be fully qualified... (or an import needs to be added). 


New Comment: 
Dave,<br/>either your statement about craziness of start_key - end_token or first
paragraph of <a href="https://issues.apache.org/jira/browse/CASSANDRA-4804"
class="external-link"
rel="nofollow">https://issues.apache.org/jira/browse/CASSANDRA-4804</a> description is
incorrect.<br/>I would like to reiterate that start_key - end_token combination let us
split ranges and iterate over segments using API only without reaching internals.<br/>Ok,
if you guys decide that you don't want to support this combination, can you give us
another tool for iteration? IMHO something like <br/>3:  optional string token,<br/>in
KeySlice would be sufficient for proper iteration over token ranges. As a free benefit we
would get a better token iterator semantics. 


New Comment: 
<blockquote>assuming we don't allow a crazy combination of range.start_key and
range.end_token or such</blockquote>Heh, that's what I was trying to validate in v1.  I
retract v2. <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 


New Comment: 
Sorry Aleksey, ignore my craziness comment <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>V1, needs semi at RowPosition stop =
p.getTokenFactory().fromString(range.end_token).maxKeyBound(p)also, it seems there is
ambiquity if end_key and end_token are specified. (or start_key and start_token for that
matter). 


New Comment: 
ah, there's a check at the top for this ambiquity, so i was mistaken...patch lgtm, except
for semi. 


New Comment: 
committed, thanks 


New Comment: 
I applied the 5089-v2.txt to 1.1.8. Unfortunately, I have to report that it does not fix
the problem.<br/>It is not really surprising, because the patch does not change anything
for our case of (start_key, end_token) range.<br/>I have a huge log with debug logging
level, please contact me if interested. 


New Comment: 
i would have thought this+            RowPosition stop =
p.getTokenFactory().fromString(range.end_token).maxKeyBound(p)<br/>+            if
(range.start_key != null &amp;&amp; RowPosition.forKey(range.start_key, p).compareTo(stop)
&gt; 0)<br/>+                throw new InvalidRequestException("Start key's token sorts
after end token");would have addressed the issue. Can you produce a simple test case that
shows the problem? 


New Comment: 
test attached.<br/>Please note that you need -ea JVM command line flag to reveal the
problem, without -ea it works fine.<br/>I think the problem is in Bounds.java:45 assert
statement:        assert left.compareTo(right) &lt;= 0 || right.isMinimum(partitioner) :
"<span class="error">&#91;&quot; + left + &quot;,&quot; + right + &quot;&#93;</span>"; Why
left is even compared to right? Why "bounds may not wrap" as it stated in the comment?
Logically, "less" and "more" are irrelevant to iterator position as we are talking about
RING. 


