Pattern changes caused by commit: 6c7ad9c34415531d6bb1e27ed1b06fe7c93fb4a3

From: Facade-4
To:   Facade-5

From: Proxy-1
To:   Proxy-0


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-1658.txt 

commit 6c7ad9c34415531d6bb1e27ed1b06fe7c93fb4a3
Author: Emmanuel Lecharny <elecharny@apache.org>

    The fix I applied for DIRMINA-672 was not sufficient : we have to get out of the loop if the decode method returns false.



==================================
 Issue DIRMINA-672 Description 
=======================================

Project: MINA
-----------------

-----------------
Title: [DIRMINA-672] CumulativeProtocolDecoder/ DemuxingProtocolDecoder
-----------------

-----------------
Summary: CumulativeProtocolDecoder/ DemuxingProtocolDecoder
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Closed
-----------------

-----------------
Created at: Fri, 13 Mar 2009 18:26:51 +0000
-----------------

-----------------
Resolved at: Wed, 6 May 2009 12:14:28 +0000
-----------------

-----------------
Assigned to: Emmanuel LÃ©charny
-----------------

-----------------
Description: 

Excerpt from forum discussion at: <a
href="http://www.nabble.com/Potential-DemuxingProtocolDecoderBug-td22489974.html"
class="external-link"
rel="nofollow">http://www.nabble.com/Potential-DemuxingProtocolDecoderBug-td22489974.html</a>

I'm
using 2.0.0-M4.  Upon inspection of the
source code, I can tell it's going to be
a JDK / OS independent issue.  Also upon
inspection, I've discovered the bug is
actually in the
CumulativeProtocolDecoder (starting @
line 125):

if
(!session.getTransportMetadata().hasFragmentation())
{<br/>      doDecode(session, in,
out);<br/>      return;<br/>}

This
breaks the contract with the doDecode
method as it is only called once (the
documentation says it should be called
repeatedly until it returns false).  The
following changes makes my previous test
case pass, but it's probably a little
simplistic.

if
(!session.getTransportMetadata().hasFragmentation())
{<br/>      while(in.hasRemaining()
&amp;&amp; doDecode(session, in, out))
{
            //Do nothing      }
     
return;<br/>}

The code should probably
make sure that if doDecode returns true,
some of the buffer was actually consumed
(as the code for fragmented transports
does).  Also, it may make sense to
provide another method (i.e.
finishNonFragmentedDecode(...)), for
handling the remainder of the buffer
after doDecode returns false.

I see
where the author was headed with this
code.  Transports (such as UDP) that
don't support fragmentation probably
don't jive with the concept of an
accumulating buffer (what do we do with
the accumulation buffer if we drop a UDP
packet?).  It does however make perfect
sense to use such transports with the
concept of a DemuxingProtocolDecoder. 
Perhaps it would be better to refactor
the DemuxingProtocolDecoder so that it's
not a subclass of
CumulativeProtocolDecoder.  Create a
helper class that handles the fragment
accumulation aspect.
CumulativeProtocolDecoder would always
use said helper class (throwing an error
if the protocol doesn't support
fragmentation), but
DemuxingProtocolDecoder could opt to use
it depending on the protocol it
encounters.
 
