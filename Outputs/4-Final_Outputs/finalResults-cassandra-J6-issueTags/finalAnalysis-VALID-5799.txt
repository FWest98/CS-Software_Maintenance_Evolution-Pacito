Pattern changes caused by commit: 9f04f3e16ecb2a52c91afe21309e496dbfde3070

From: Facade-1
To:   Facade-0

From: Flyweight-3
To:   Flyweight-4


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-5799.txt 

commit 9f04f3e16ecb2a52c91afe21309e496dbfde3070
Author: Brandon Williams <brandonwilliams@apache.org>

    Bootstrapping nodes never use the hibernation state.
    Patch by brandonwilliams, reviewed by vijay for CASSANDRA-3737



==================================
 Issue CASSANDRA-3737 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-3737] Its impossible to removetoken joining down node
-----------------

-----------------
Summary: Its impossible to removetoken joining down node
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Fri, 13 Jan 2012 09:32:11 +0000
-----------------

-----------------
Resolved at: Sat, 14 Jan 2012 00:42:52 +0000
-----------------

-----------------
Assigned to: Brandon Williams
-----------------

-----------------
Description: 

We have a node that incidentaly started to join cluster. Admins made it down quicky, so
now it looks :<br/>10.112.0.234    datacenter1 rack1       Down   Joining 46.83 GB       
2,90%   15893087653239874101909022095979644640  <br/>And I can't removetoken such a
node:

 nodetool -h tap9600 removetoken
15893087653239874101909022095979644640<br/>Exception in thread "main"
java.lang.UnsupportedOperationException: Token not found.<br/>	at
org.apache.cassandra.service.StorageService.removeToken(StorageService.java:2376)<br/>	at
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br/>	at
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)<br/>	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br/>	at
java.lang.reflect.Method.invoke(Method.java:616)<br/>	at
com.sun.jmx.mbeanserver.StandardMBeanIntrospector.invokeM2(StandardMBeanIntrospector.java:111)<br/>	at
com.sun.jmx.mbeanserver.StandardMBeanIntrospector.invokeM2(StandardMBeanIntrospector.java:45)<br/>	at
com.sun.jmx.mbeanserver.MBeanIntrospector.invokeM(MBeanIntrospector.java:226)<br/>	at
com.sun.jmx.mbeanserver.PerInterface.invoke(PerInterface.java:138)<br/>	at
com.sun.jmx.mbeanserver.MBeanSupport.invoke(MBeanSupport.java:251)<br/>	at
com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:857)<br/>	at
com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:795)<br/>	at
javax.management.remote.rmi.RMIConnectionImpl.doOperation(RMIConnectionImpl.java:1450)<br/>	at
javax.management.remote.rmi.RMIConnectionImpl.access$200(RMIConnectionImpl.java:90)<br/>	at
javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(RMIConnectionImpl.java:1285)<br/>	at
javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(RMIConnectionImpl.java:1383)<br/>	at
javax.management.remote.rmi.RMIConnectionImpl.invoke(RMIConnectionImpl.java:807)<br/>	at
sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)<br/>	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br/>	at
java.lang.reflect.Method.invoke(Method.java:616)<br/>	at
sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:322)<br/>	at
sun.rmi.transport.Transport$1.run(Transport.java:177)<br/>	at
java.security.AccessController.doPrivileged(Native Method)<br/>	at
sun.rmi.transport.Transport.serviceCall(Transport.java:173)<br/>	at
sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:553)<br/>	at
sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:808)<br/>	at
sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:667)<br/>	at
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)<br/>	at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)<br/>	at
java.lang.Thread.run(Thread.java:679)
 

-----------------

-----------------
Comments: 

New Comment: 
You shouldn't need to remove this node; it should be removed after a minute or so since it
is a fat client. 


New Comment: 
<blockquote>You shouldn't need to remove this node; it should be removed after a minute or
so since it is a fat client.</blockquote>But we have a bug introduced by <a
href="https://issues.apache.org/jira/browse/CASSANDRA-957" title="convenience workflow for
replacing dead node" class="issue-link"
data-issue-key="CASSANDRA-957"><del>CASSANDRA-957</del></a>; bootstrapping nodes start in
hibernate, which is a dead state, resulting in setHasToken being set to true in
handleMajorStateChange:<div class="preformatted panel" style="border-width: 1px;"><div
class="preformattedContent panelContent"><pre>            epState.setHasToken(true); //
fat clients won't have a dead state</pre></div></div>That comment is no longer true. <img
class="emoticon" src="https://issues.apache.org/jira/images/icons/emoticons/sad.png"
height="16" width="16" align="absmiddle" alt="" border="0"/> 


New Comment: 
Since the boolean value of hibernate has no bearing, only its presence in STATUS, there is
no need for a bootstrapping node to ever use the hibernation state. 


New Comment: 
+1 


