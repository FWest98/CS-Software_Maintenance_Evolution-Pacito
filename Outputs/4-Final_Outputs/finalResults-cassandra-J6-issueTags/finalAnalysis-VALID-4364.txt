Pattern changes caused by commit: 57684e9aab65c7ecff60c108d8d3c183073088b1

From: Mediator-2
To:   Mediator-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-4364.txt 

commit 57684e9aab65c7ecff60c108d8d3c183073088b1
Author: Jonathan Ellis <jbellis@apache.org>

    fix race that could result in Hadoopwriter failing to throw exception for encountered error
    patch by Mck SembWever and jbellis for CASSANDRA-2755



==================================
 Issue CASSANDRA-2755 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-2755] ColumnFamilyRecordWriter fails to throw a write exception encountered after the user begins to close the writer
-----------------

-----------------
Summary: ColumnFamilyRecordWriter fails to throw a write exception encountered after the user begins to close the writer
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Thu, 9 Jun 2011 19:40:29 +0000
-----------------

-----------------
Resolved at: Tue, 28 Jun 2011 12:27:27 +0000
-----------------

-----------------
Assigned to: Michael Semb Wever
-----------------

-----------------
Description: 

There appears to be a race condition in <tt>ColumnFamilyRecordWriter</tt> that can result
in the loss of an exception. Here is how it can happen (W stands for the
<tt>RangeClient</tt>'s worker thread; U stands for the <tt>ColumnFamilyRecordWriter</tt>
user's thread):
<ol>	<li>W: <tt>RangeClient</tt>'s <tt>run</tt> method catches an
exception originating in the Thrift client/socket, but doesn't get a chance to set it on
the <tt>lastException</tt> field before it the thread is preempted.</li>	<li>U: The user
calls <tt>close</tt> which calls <tt>stopNicely</tt>. Because the <tt>lastException</tt>
field is null, <tt>stopNicely</tt> does not throw anything. <tt>close</tt> then joins on
the worker thread.</li>	<li>W: The <tt>RangeClient</tt>'s <tt>run</tt> method sets the
<tt>lastException</tt> field and exits.</li>	<li>U: Although the thread in <tt>close</tt>
is waiting for the worker thread to exit, it has already checked the
<tt>lastException</tt> field so it doesn't detect the presence of the last exception.
Instead, <tt>close</tt> returns without throwing anything.</li></ol>
This race condition
means that intermittently write failures will go undetected.
 

-----------------

-----------------
Comments: 

New Comment: 
In RangeClient i cannot see why close() needs to be called before lastException is
assigned. The following patch should work: I have tested it against various jobs but i
have no reproducible testcase to confirm this bug against.Also in the patch is a slight
cleanup to ColumnFamilyRecordWriter's close() methods: keeping implementation out of
deprecated methods. 


New Comment: 
It looks to me that as long as we check for the exception before calling join, there will
be a window to miss one.v2 encapsulates RangeClient.close better to avoid this. 


New Comment: 
The check for the exception also occurs in ColumnFamilyRecordWriter.write(buf, value)
-&gt; RangeClient.put(pair)<br/>Isn't it possible the put(..) is being called while the
RangeClient thread is inside close() ?<br/>(isn't write(..) called more often than close()
?)For this reason inside RangeClient.run() i assigned lastException before calling close() 


New Comment: 
<blockquote>Isn't it possible the put(..) is being called while the RangeClient thread is
inside close?</blockquote>old close, new closeInternal?Yes, but I don't see how that
changes things.  I.e., it's always possible that the last put() will happen before an
exception is set; hence, the extra check on close. 


New Comment: 
<blockquote>it's always possible that the last put() will happen before an exception is
set; hence, the extra check on close.</blockquote>Quite right. 


New Comment: 
Jonathan: Is your patch being applied? 


New Comment: 
waiting for a +1, wasn't clear if your last comment was intended that way. 


New Comment: 
Yes it was a +1 


New Comment: 
committed, thanks! 


