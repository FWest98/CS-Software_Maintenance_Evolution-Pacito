Pattern changes caused by commit: 1e18538c9868e92622e9e0acf87b2e88b9bd6182

From: Facade-1
To:   Facade-0

From: Flyweight-3
To:   Flyweight-4


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-6352.txt 

commit 1e18538c9868e92622e9e0acf87b2e88b9bd6182
Author: Jonathan Ellis <jbellis@apache.org>

    only deserialize keys we need in the sample
    patch by yukim; reviewed by jbellis for CASSANDRA-4023



==================================
 Issue CASSANDRA-4023 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-4023] Improve BloomFilter deserialization performance
-----------------

-----------------
Summary: Improve BloomFilter deserialization performance
-----------------

-----------------
Issue type: Improvement
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Thu, 8 Mar 2012 18:56:29 +0000
-----------------

-----------------
Resolved at: Tue, 27 Mar 2012 04:44:32 +0000
-----------------

-----------------
Assigned to: Yuki Morishita
-----------------

-----------------
Description: 

The difference of startup times between a 0.8.7 cluster and 1.0.7 cluster with the same
amount of data is 4x greater in 1.0.7.

It seems as though 1.0.7 loads the BloomFilter
through a series of reading longs out in a multithreaded process while 0.8.7 reads the
entire object.

Perhaps we should update the new BloomFilter to do reading in batch as
well?
 

-----------------

-----------------
Comments: 

New Comment: 
The theory here being that the multithreadedness is causing seek contention when loading
the sstables. 


New Comment: 
We added the multithreadedness specifically because it <b>improves</b> startup time for
people with multiple spindles or SSDs...Any ideas how to get the best of both worlds
besides falling back to a config options?(Maybe it's time to add random vs sequential
speed ratio as a setting, which at least is general enough to be useful in other places.) 


New Comment: 
<blockquote>(Maybe it's time to add random vs sequential speed ratio as a setting, which
at least is general enough to be useful in other places.)</blockquote>This sounds like a
good idea, we're never going to strike a balance that's sufficient between SSD and
rotational media without a knob to turn. 


New Comment: 
My $0.02 is that it may be helpful to batch reads.  Not sure if the underlying stream used
in reading the bloom filters reads a large chunk and caches it, but if not, it could help
to instead of just calling ois.readLong(), you read 64K or 1M or whatever you feel is
appropriate (maybe configurable?) into a buffer and grab the longs out of those.  This
doesn't completely fix the problem of disk contention, but it might cause larger
sequential reads to be submitted to the disk, which then might behave nicer?The specific
example I'm thinking of here is: it looks like the deserialization of LegacyBloomFilter
(perhaps what 0.8 uses?) is just a ois.readObject() for a BitSet.  And that's like, it. 
Whereas for BloomFilter (the new version?), deserialization is a tight loop of readLong()
calls.  Same with serialization FWIW.  Not that using Java serialization for LTS is
necessarily a good idea, but it may be happier for the disk. 


New Comment: 
Sorry, the description threw me off.  So really we're talking about our paged bloom filter
(<a href="https://issues.apache.org/jira/browse/CASSANDRA-2466" title="bloom filters
should avoid huge array allocations to avoid fragmentation concerns" class="issue-link"
data-issue-key="CASSANDRA-2466"><del>CASSANDRA-2466</del></a>), not the multithreaded
startup (<a href="https://issues.apache.org/jira/browse/CASSANDRA-2988" title="Improve
SSTableReader.load() when loading index files" class="issue-link"
data-issue-key="CASSANDRA-2988"><del>CASSANDRA-2988</del></a>). 


New Comment: 
patch to do buffered bloom filter deserialization 


New Comment: 
+1 on the patch.  When we get a chance, we'll try out the patch on the cluster that
demonstrated the issue.The overall intent of the ticket filed is that startup is slower
overall, and this was just one example in the code that I found that could be part of the
problem.  Any other ideas as to things that could cause slower startup?  We noticed the
logs had a lot of SSTables being opened during startup, and we do have some 100+GB
SSTables on disk, so general SSTable reading was my first instinct to check. 


New Comment: 
Also, FWIW, the observed slowness is in 1.0.7, not 1.0.1 as mentioned in the affects
version (though it certainly may affect 1.0.1 as well).  I don't seem to have permission
to update this. 


New Comment: 
Right, actual versions affected are <tt>[affects-version .. fix-version)</tt> 


New Comment: 
Hi Jonathan.  We patched our cluster and startup time didn't decrease much if at all.  I
still think the patch is probably a positive help, but it looks like there are bigger
problems elsewhere.  Let me know if any additional testing or logs could help out here. 


New Comment: 
I measured how long does it take to load each sstable component(Data, Index, Filter) and
found out that loading from index file takes longer in 1.0 than in 0.8.<br/>By looking
code for difference between 0.8 and 1.0, I noticed that in 1.0, every keys stored in index
file get deserialized, while  in 0.8, only those keys that should be added to index
summary get deserialized.<br/>The reason we deserialize all keys in 1.0 is to obtain first
and last keys stored in sstable. Attached patch tries to skip deserializing keys when
possible.Patch is against 1.0 branch. 


New Comment: 
LGTM, but can you add a test for indexSummary, SSTR.first, and SSTR.last?  (Adding to one
of the existing SSTR or CF tests is fine of course.) 


New Comment: 
Attaching v3, which is slightly modified from v2 and comes with test. 


New Comment: 
committed, thanks! 


New Comment: 
In trunk, <a href="https://issues.apache.org/jira/browse/CASSANDRA-2319" title="Promote
row index" class="issue-link"
data-issue-key="CASSANDRA-2319"><del>CASSANDRA-2319</del></a> changed the content in
primary index file, so we need to calculate its serialized size differently to determine
if the key is the last one. 


New Comment: 
Attaching patch to current trunk.Unfortunately, there is no way to determine serialized
size of promoted row index without actually deserializing some of it, so we cannot
determine the last key.<br/>Patch deserializes every key when sstable has promoted index,
but instead it tries to reduce the amount of io when deserialize index itself. 


New Comment: 
Is this io-reducing something that could also apply to 1.0? 


New Comment: 
<blockquote>Is this io-reducing something that could also apply to 1.0?</blockquote>It's
for RowIndexEntry which is introduced for v1.2 (<a
href="https://issues.apache.org/jira/browse/CASSANDRA-2319" title="Promote row index"
class="issue-link" data-issue-key="CASSANDRA-2319"><del>CASSANDRA-2319</del></a>), so it
only relates to trunk. 


New Comment: 
Could we rename lastKey to lastKeyForUnpromoted, and then take the hasPromotedIndexes out
of that assignment?  Since you also added it to the big if statement.I guess
deserializePositionOnly is only for unpromoted indexes?  Because for promoted ones
decoratedKey will never be null.+1 otherwise, I guess we'll have to rely on <a
href="https://issues.apache.org/jira/browse/CASSANDRA-2392" title="Saving IndexSummaries
to disk" class="issue-link" data-issue-key="CASSANDRA-2392"><del>CASSANDRA-2392</del></a>
for startup speed in 1.2. 


New Comment: 
Getting NPE around this code (trunk).SSTableReader.open on
system-schema_columnfamilies-ib-2SSTableReader.load bails out of the while (true) loop
becauseif (indexPosition == indexSize)causing the right variable to remain null, which
then gets passed tothis.last = getMinimalKey(right);which NPEsboolean lastKey =
indexPosition + DBConstants.SHORT_SIZE + len + DBConstants.LONG_SIZE == indexSize; is
false on the last itemindexPosition = 0<br/>len = 9<br/>indexSize = 2319 != 23public
static DecoratedKey getMinimalKey(DecoratedKey key)    {        return key.key.position()
&gt; 0 || key.key.hasRemaining()                                       ? new
DecoratedKey(key.token, HeapAllocator.instance.clone(key.key))                            
          : key;    } 


New Comment: 
Seems like this is the fix to me (at least in the simple case where the int read in
deserialize is 0) more would need to be done if not.diff --git
a/src/java/org/apache/cassandra/io/sstable/SSTableReader.java
b/src/java/org/apache/cassandra/io/sstable/SSTableReader.java<br/>index 9e92220..959a66d
100644<br/>&#8212; a/src/java/org/apache/cassandra/io/sstable/SSTableReader.java<br/>+++
b/src/java/org/apache/cassandra/io/sstable/SSTableReader.java<br/>@@ -361,7 +361,7 @@
public class SSTableReader extends SSTable<br/>                 int len =
ByteBufferUtil.readShortLength(input);                 boolean firstKey = left == null;<ul
class="alternate" type="square">	<li>boolean lastKey = indexPosition +
DBConstants.SHORT_SIZE + len + DBConstants.LONG_SIZE == indexSize;<br/>+               
boolean lastKey = indexPosition + DBConstants.SHORT_SIZE + len + DBConstants.LONG_SIZE +
(descriptor.hasPromotedIndexes ? DBConstants.INT_SIZE : 0) == indexSize;<br/>             
   boolean shouldAddEntry = indexSummary.shouldAddEntry();<br/>                 if
(shouldAddEntry || cacheLoading || recreatebloom || firstKey || lastKey)<br/>             
   {</li></ul> 


New Comment: 
<blockquote>Could we rename lastKey to lastKeyForUnpromoted, and then take the
hasPromotedIndexes out of that assignment?</blockquote>Done.<blockquote>I guess
deserializePositionOnly is only for unpromoted indexes?</blockquote>It deserializes whole
row index only when decoratedKey is not null AND cache key. Otherwise only deserialize
position. 


New Comment: 
Does v3 include a fix for the NPE Dave found? 


New Comment: 
NPE only happens on trunk and that is why I reopened this issue.<br/>Fix is attached as
trunk-4023.txt.<br/>v3 attached above is for 1.0 branch and already committed to 1.0 and
1.1 without any problem. 


New Comment: 
no v3 has this bugthe problem is in the general case where
RowIndexEntry.serializer.deserialize() is using the hasPromotedIndexes code, the amount of
data read is variable (assuming in this case the first int read in deserialize can be non
0). Therefore in SSTableReader the code can no longer statically predict when a particular
key will be the last key.Ah I see.. yes this happens on trunk... so if it is fixed
elsewhere, then good... never mind me. 


