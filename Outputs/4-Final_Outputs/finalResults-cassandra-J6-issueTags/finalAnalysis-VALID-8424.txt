Pattern changes caused by commit: 1cbbba095a715cc69254336d34d840463b1fd46e

From: Abstract Factory-1
To:   Abstract Factory-2

From: Factory Method-1
To:   Factory Method-2

From: Decorator-2
To:   Decorator-1

From: Facade-0
To:   Facade-1

From: Flyweight-2
To:   Flyweight-1

From: Mediator-3
To:   Mediator-1

From: Strategy-0
To:   Strategy-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-8424.txt 

commit 1cbbba095a715cc69254336d34d840463b1fd46e
Author: Yuki Morishita <yukim@apache.org>

    fix get_count returns incorrect value with TTL; patch by yukim reviewed by slebresne for CASSANDRA-5099



==================================
 Issue CASSANDRA-5099 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-5099] Since 1.1, get_count sometimes returns value smaller than actual column count
-----------------

-----------------
Summary: Since 1.1, get_count sometimes returns value smaller than actual column count
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Wed, 2 Jan 2013 22:51:15 +0000
-----------------

-----------------
Resolved at: Fri, 11 Jan 2013 17:06:25 +0000
-----------------

-----------------
Assigned to: Yuki Morishita
-----------------

-----------------
Description: 

We have a CF where rows have thousands of TTLd columns. The columns are continually added
at a regular rate, and TTL out after 15 minutes. We continually run a 'get_count' on these
keys to get a count of the number of live columns.

Since we upgrade from 1.0 to 1.1.7,
"get_count" regularly returns much smaller values than are possible. For example, with 
roughly 15,000 columns that have well-distributed TTLs, running a get_count 10 times will
result in 1 or 2 results that are up to half the actual column count. Using a normal 'get'
to count those columns always results in proper values. 

For example:

(all of these
counts were ran within a second or less of eachother)
<div class="code panel"
style="border-width: 1px;"><div class="codeContent panelContent"><pre
class="code-java">[<span class="code-keyword">default</span>@reddit] count 
AccountsActiveBySR[<span class="code-quote">'2qh0u'</span>];13665 columns[<span
class="code-keyword">default</span>@reddit] count  AccountsActiveBySR[<span
class="code-quote">'2qh0u'</span>];13665 columns[<span
class="code-keyword">default</span>@reddit] count  AccountsActiveBySR[<span
class="code-quote">'2qh0u'</span>];13666 columns[<span
class="code-keyword">default</span>@reddit] count  AccountsActiveBySR[<span
class="code-quote">'2qh0u'</span>];3069 columns[<span
class="code-keyword">default</span>@reddit] count  AccountsActiveBySR[<span
class="code-quote">'2qh0u'</span>];13660 columns[<span
class="code-keyword">default</span>@reddit] count  AccountsActiveBySR[<span
class="code-quote">'2qh0u'</span>];13661 columns</pre></div></div>
I should note that this
issue happens much more frequently with larger (&gt;10k columns) rows than smaller rows.
It never seems to happen with rows having fewer than 1k columns.

There are no
supercolumns in use. The key names and column names are very short, and there are no
column values. The CF is LCS, and due to the TTL only hovers around a few MB in size. GC
grace is normally at zero, but the problem is consistent with non-zero gc grace times.

It
appears that there was an issue (<a
href="https://issues.apache.org/jira/browse/CASSANDRA-4833" title="get_count with
&#39;count&#39; param between 1024 and ~actual column count fails" class="issue-link"
data-issue-key="CASSANDRA-4833"><del>CASSANDRA-4833</del></a>) fixed in 1.1.7 regarding
get_count. Some logic was added to prevent an infinite loop case. Could that change have
resulted in this problem somehow? I can't find any other relevant 1.1 changes that might
explain this issue.
 

-----------------

-----------------
Comments: 

New Comment: 
Also found <a href="https://issues.apache.org/jira/browse/CASSANDRA-3798" title="get_count
paging often asks for a page uselessly" class="issue-link"
data-issue-key="CASSANDRA-3798"><del>CASSANDRA-3798</del></a> which altered the get_count
logic between 1.0 and 1.1. 


New Comment: 
Confirmed that this problem is consistent on both LCS and SizeTiered. 


New Comment: 
I've ported the 1.0.11 get_count code from CassandraServer.java to 1.1.7. Doing so
resolves this issue. 


New Comment: 
Fix for <a href="https://issues.apache.org/jira/browse/CASSANDRA-4833" title="get_count
with &#39;count&#39; param between 1024 and ~actual column count fails" class="issue-link"
data-issue-key="CASSANDRA-4833"><del>CASSANDRA-4833</del></a> assumes that only last page
from get_slice has columns less than requested, and if that happens, returns the column
count collected.<br/>But in case of ttl, it is possible to have less columns at the middle
of the pagenation.Attached patch changes loop termination check so that it does not depend
on column count, which is what we had in 1.0. 


New Comment: 
In fact, I think that this point out to a more serious problem with TTL.Because even
get_count aside, if I do a get_slice with a particular count n, I expect that if I get
less than n values in my result, it means there is no more value matching whatever replica
I've provided. I'd say that any other behavior is a bug. But with TTL, if a column expires
while the query is processed, we may fail that count argument (which is exactly what hits
us here).In other words, I'm not sure reintroducing the inefficiency of always doing one
last almost always useless query to make sure the paging is indeed over is the right fix,
because I doubt people that do manual row paging using get_slice actually implement that
"do one last query just in case the previous query lied on the count returned".What I
would suggest instead would be to have CassandraServer save the current time before doing
a get_slice, and use that time in thriftifyColumns when deciding if a column is considered
expired or not. That way we won't skip an expiring column from the result set if it had
been counted as live during the actual internal query. 


New Comment: 
I'll note that the solution I'm suggesting is 1) slightly painful to implement because
deserialization change expiring columns into tombstones so we would have have to pass the
expireBefore all the way down the stack and 2) this only really work correctly if we
actually send that expireBefore to other nodes along with the read request to use as
reference. In particular 2) makes such solution pretty much out of scope for 1.1 and even
1.2 (since it's a protocol change). That being said, I do think this is probably the
"right" solution in the long run (unless someone has a better idea of course).Note that I
don't oppose committing the "let's do one more request" to 1.1 to fix get_count if we have
nothing better, but that doesn't change the fact that the get_slice count is potentially
broken when TTLs are involved. I just don't see a quick fix right off the bat. 


New Comment: 
Sounds to me like we should commit the "one more request" fix and open a new ticket to
address mid-request ttl expiration for 1.2 only. 


New Comment: 
I'm +1 to commit this patch for 1.1.9 and open new ticket for 1.2.<br/>So, is the patch
looking good? 


New Comment: 
<blockquote>So, is the patch looking good?</blockquote>Yes, +1. I've created <a
href="https://issues.apache.org/jira/browse/CASSANDRA-5149" title="Respect slice count
even if column expire mid-request" class="issue-link"
data-issue-key="CASSANDRA-5149"><del>CASSANDRA-5149</del></a> for the follow up. 


