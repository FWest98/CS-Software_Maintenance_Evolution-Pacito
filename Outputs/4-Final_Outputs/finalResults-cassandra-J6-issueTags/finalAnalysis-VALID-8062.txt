Pattern changes caused by commit: 5a3eb1a6c3e61bd217e23e5d1e7c27f03fab4f08

From: Abstract Factory-1
To:   Abstract Factory-2

From: Factory Method-1
To:   Factory Method-2


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-8062.txt 

commit 5a3eb1a6c3e61bd217e23e5d1e7c27f03fab4f08
Author: Aleksey Yeschenko <aleksey@apache.org>

    Replace IAuthority with new IAuthorizer; patch by Aleksey Yeschenko,
    reviewed by Jonathan Ellis for CASSANDRA-4874



==================================
 Issue CASSANDRA-4874 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-4874] Possible authorizaton handling impovements
-----------------

-----------------
Summary: Possible authorizaton handling impovements
-----------------

-----------------
Issue type: Improvement
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Tue, 30 Oct 2012 03:46:56 +0000
-----------------

-----------------
Resolved at: Tue, 27 Nov 2012 17:34:04 +0000
-----------------

-----------------
Assigned to: Aleksey Yeschenko
-----------------

-----------------
Description: 

I'll create another issue with my suggestions about fixing/improving IAuthority
interfaces. This one lists possible improvements that aren't related to grant/revoke
methods.

Inconsistencies:
<ul class="alternate" type="square">	<li>CREATE COLUMNFAMILY:
P.CREATE on the KS in CQL2 vs. P.CREATE on the CF in CQL3 and Thrift</li>	<li>BATCH:
P.UPDATE or P.DELETE on CF in CQL2 vs. P.UPDATE in CQL3 and Thrift (despite remove* in
Thrift asking for P.DELETE)</li>	<li>DELETE: P.DELETE in CQL2 and Thrift vs. P.UPDATE in
CQL3</li>	<li>DROP INDEX: no checks in CQL2 vs. P.ALTER on the CF in CQL3</li></ul>
Other
issues/suggestions
<ul class="alternate" type="square">	<li>CQL2 DROP INDEX should require
authorization</li>	<li>current permission checks are inconsistent since they are performed
separately by CQL2 query processor, Thrift CassandraServer and CQL3 statement
classes.<br/>We should move it to one place. SomeClassWithABetterName.authorize(Operation,
KS, CF, User), where operation would be a enum<br/>(ALTER_KEYSPACE, ALTER_TABLE,
CREATE_TABLE, CREATE, USE, UPDATE etc.), CF should be nullable.</li>	<li>we don't respect
the hierarchy when checking for permissions, or, to be more specific, we are doing it
wrong. take  CQL3 INSERT as an example:<br/>we require P.UPDATE on the CF or FULL_ACCESS
on either KS or CF. However, having P.UPDATE on the KS won't allow you to perform the
statement, only FULL_ACCESS will do.<br/>I doubt this was intentional, and if it was, I
say it's wrong. P.UPDATE on the KS should allow you to do updates on KS's
cfs.<br/>Examples in <a
href="http://www.datastax.com/dev/blog/dynamic-permission-allocation-in-cassandra-1-1"
class="external-link"
rel="nofollow">http://www.datastax.com/dev/blog/dynamic-permission-allocation-in-cassandra-1-1</a>
point to it being a bug, since REVOKE UPDATE ON ks FROM omega is there.</li>	<li>currently
we lack a way to set permission on cassandra/keyspaces resource. I think we should be able
to do it. See the following point on why.</li>	<li>currently to create a keyspace you must
have a P.CREATE permission on that keyspace THAT DOESN'T EVEN EXIST YET. So only a
superuser can create a keyspace,<br/>or a superuser must first grant you a permission to
create it. Which doesn't look right to me. P.CREATE on cassandra/keyspaces should allow
you to create new<br/>keyspaces without an explicit permission for each of
them.</li>	<li>same goes for CREATE TABLE. you need P.CREATE on that not-yet-existing CF
of FULL_ACCESS on the whole KS. P.CREATE on the KS won't do. this is wrong.</li>	<li>since
permissions don't map directly to statements, we should describe clearly in the
documentation what permissions are required by what cql statement/thrift
method.</li></ul>
Full list of current permission requirements: <a
href="https://gist.github.com/3978182" class="external-link"
rel="nofollow">https://gist.github.com/3978182</a>
 

-----------------

-----------------
Comments: 

New Comment: 
<blockquote>CREATE COLUMNFAMILY: P.CREATE on the KS in CQL2 vs. P.CREATE on the CF in CQL3
and Thrift</blockquote>CQL2 sounds correct to me, how can you have permissions on an
object that doesn't exist yet?But that would imply that KS create permissioning is also
broken, which you mention.Maybe we should have a "cluster" or "all" top-level permission:
having create on all, allows creating keyspaces.  This would fit with the heirarchy design
you describe too (GRANT UPDATE ON ALL TO foo), and gives a nice shorthand for granting
system-wide permissions (or a subset of them) w/o making someone a
superuser.<blockquote>BATCH: P.UPDATE or P.DELETE on CF in CQL2 vs. P.UPDATE in CQL3 and
Thrift (despite remove* in Thrift asking for P.DELETE)</blockquote>ISTM that the correct
behavior is to permission-check each statement in the batch separately.<blockquote>DELETE:
P.DELETE in CQL2 and Thrift vs. P.UPDATE in CQL3</blockquote>Seems
obvious.<blockquote>DROP INDEX: no checks in CQL2 vs. P.ALTER on the CF in
CQL3</blockquote>ALTER sounds reasonable.<blockquote>We should move it to one place.
SomeClassWithABetterName.authorize</blockquote>I'm not sure this really improves things,
you've just created an abstraction layer with different names but fundamentally you still
have to insert the correct auth call in each query processing path.<blockquote>P.UPDATE on
the KS should allow you to do updates on KS's cfs</blockquote>+1 


New Comment: 
<blockquote><blockquote>DELETE: P.DELETE in CQL2 and Thrift vs. P.UPDATE in
CQL3</blockquote>Seems obvious.</blockquote>Not to me. Should be P.DELETE in Thrift and
CQL3? If so, then what do you think about requiring both P.UPDATE and P.DELETE for
inserts/updates with TTL set?<blockquote><blockquote>We should move it to one place.
SomeClassWithABetterName.authorize</blockquote>I'm not sure this really improves things,
you've just created an abstraction layer with different names but fundamentally you still
have to insert the correct auth call in each query processing path.</blockquote>You are
right. This won't be needed once we fix permission inheritance. Then one method in
ClientState (modified current hasAccees) will be sufficient. No need for another enum.<a
href="https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jbellis"
class="user-hover" rel="jbellis">Jonathan Ellis</a> Can you look at <a
href="https://issues.apache.org/jira/browse/CASSANDRA-4875" title="Revert IAuthority2
interface" class="issue-link"
data-issue-key="CASSANDRA-4875"><del>CASSANDRA-4875</del></a> as well please? 


New Comment: 
<blockquote>Should be P.DELETE in Thrift and CQL3? </blockquote>Yes.<blockquote>If so,
then what do you think about requiring both P.UPDATE and P.DELETE for inserts/updates with
TTL set?</blockquote>Yes, we should.  (This is why I'm not 100% sure it makes sense to
distinguish between UPDATE and DELETE at all, but "require both for ttl" is probably the
best compromise.) 


New Comment: 
<blockquote>I'm not 100% sure it makes sense to distinguish between UPDATE and DELETE at
all</blockquote>I'd agree with that. From a security perspective I don't see the
difference between updating a value with crap or deleting it, so imo both permission will
always be set together and so it seems to me that having both only help people at making
the mistake of revoking one permission without the other. Just my 2 cents though. 


New Comment: 
<blockquote>I don't see the difference between updating a value with crap or deleting
it</blockquote>Most time there is no difference, unless you have a null-column in the
first place and only care about the column name. 


New Comment: 
<blockquote>unless you have a null-column in the first place and only care about the
column name</blockquote>Not sure I follow. 


New Comment: 
Imagine a wide row representing a time series, where every column's name is a timestamp
and every column's value is already null - you don't care about the value. In this case
there is a difference between overwriting the value with crap (doesn't matter) and
removing the column entirely (matters). 


New Comment: 
Btw I'm not advocating for keeping P.DELETE, just saying that there is sometimes a
difference from security standpoint. 


New Comment: 
Ok, I understand that example. It's a fairly specific use case imo (in term of security I
mean), and there will always been cases where whatever permissions we allow won't be
precise enough for someone. I'm still of the opinion that it's not worth the potential
foot shooting of setting P.DELETE without P.UPDATE by mistake, but that's just an opinion. 


New Comment: 
Also, if we are getting rid of P.DELETE in favor of one unified permission for
insert/update/delete, then I'd rather add some new name that won't match any of the
operations, to avoid confusion. Say, P.MODIFY. 


New Comment: 
Single patch for <a href="https://issues.apache.org/jira/browse/CASSANDRA-4874"
title="Possible authorizaton handling impovements" class="issue-link"
data-issue-key="CASSANDRA-4874"><del>CASSANDRA-4874</del></a> and <a
href="https://issues.apache.org/jira/browse/CASSANDRA-4875" title="Revert IAuthority2
interface" class="issue-link"
data-issue-key="CASSANDRA-4875"><del>CASSANDRA-4875</del></a>. 


New Comment: 
v2 is almost identical to v1 (differs by 2 lines, one of which is a comment).<br/>This way
it will work with SimpleAuthenticator. 


New Comment: 
v3: Pulled out NativeAuthority. Still, please have a look at it while reviewing the issue
- it might explain some implementation decisions. 


New Comment: 
Looks pretty good to me.  Comments:<ul class="alternate" type="square">	<li>Should
document what happened to IAuth/LegacyAuth in News</li>	<li>grantOption feels like
premature complexity to me &#8211; why not just a single GRANT permission?</li></ul>Nits:
<ul class="alternate" type="square">	<li>unrelated cqlsh cleanup should be
separate.</li>	<li>Not 100% sure that IResource is going to be useful in its present form
(for e.g. functions) so I'd be inclined to just use DataResource everywhere for now, but
it's probably okay the way it is for now.</li></ul> 


New Comment: 
Thanks.<blockquote>Should document what happened to IAuth/LegacyAuth in
News</blockquote>Will do.<blockquote>grantOption feels like premature complexity to me –
why not just a single GRANT permission?</blockquote>I assume having P.GRANT would give a
user ability to grant and revoke any permission on the resource (including P.GRANT
itself). This would also simplify grant and revoke implementations (check for P.GRANT and
that's all). If so then I agree and I like it.<blockquote>unrelated cqlsh cleanup should
be separate.</blockquote>Sorry. Couldn't resist.<blockquote>Not 100% sure that IResource
is going to be useful in its present form (for e.g. functions) so I'd be inclined to just
use DataResource everywhere for now, but it's probably okay the way it is for
now.</blockquote>The idea was to avoid breaking IAuthority interface in the future. Hence
the only assumptions were that any new resource type will be hierarchical, and every level
will have a printable name. TBH I don't have a strong opinion on this point. We can just
see what happens (if?) to functions/triggers/what not and if necessary slightly alter
IAuthority in 1.3/1.4. It's YAGNI vs. not breaking stuff. Just using DataResource
everywhere for now is fine by me. A second opinion maybe? 


New Comment: 
BTW unfortunately just replacing "implements IAuthority" with "extends LegacyAuthority"
won't be enough if a particular implementation used Permission.ALL and/or Permission.NONE.
They were returning (mutable) EnumSet-s and I had to replace them with ImmutableSet-s. I
wish there was an immutable subclass of EnumSet, but there isn't, because Java. That's the
only issue though. 


New Comment: 
<blockquote>I assume having P.GRANT would give a user ability to grant and revoke any
permission on the resource (including P.GRANT itself)</blockquote>Right.<blockquote>The
idea was to avoid breaking IAuthority interface in the future</blockquote>That makes
sense. 


New Comment: 
Actually, that wouldn't work (a single GRANT permission).<br/>I looked at two options, but
both don't work:<br/>1. Allow GRANT owners GRANT and REVOKE any permission on the resource
(even those they don't have) - now we get the old FULL_ACCESS and all the associated
problems (you have to check for GRANT and not just the requested permission and, secondly,
REVOKE &lt;perm&gt; won't work as expected if a user still has GRANT permission on the
resource).<br/>2. Allow GRANT owners GRANT and REVOKE only the permissions they already
have on the resource. This one is trickier:<br/>2.1 Make P.GRANT non-recursive (disallow
granting P.GRANT). Now you need to involve a superuser every time you want to allow
someone grant permissions. This is bad since it involves superusers unnecessarily.<br/>2.2
Make P.GRANT recursive (allow granting P.GRANT). Now we've got ourselves easy permission
escalation. User A has every permission but P.GRANT. User B has P.SELECT and P.GRANT (or
just P.GRANT). User B grants P.GRANT to user A. A grants B every permission he has. Now
the two of them together have more permissions than the sum of their old ones. 


New Comment: 
So WITH GRANT OPTION is here to stay. It's simple to understand and doesn't leak
permissions. 


New Comment: 
As for IResource and functions - my idea was that each resource type will have its own
root (no common global root). DataResources start with 'data', FunctionResources will be
represented as 'functions<span class="error">&#91;/..&#93;</span>. So there will usually
be at least two levels independent of the resource type. This might even allow
user-specified resource types as long as they follow the convention and as long as we have
a map root name -&gt; resource class.<br/>So I vote for leaving IResource alone. 


New Comment: 
<blockquote>REVOKE &lt;perm&gt; won't work as expected if a user still has GRANT
permission on the resource).</blockquote>Of course you'd need to revoke GRANT as well. 
Works as designed!<blockquote>I vote for leaving IResource alone</blockquote>WFM. 


New Comment: 
<blockquote>Of course you'd need to revoke GRANT as well. Works as designed!</blockquote>I
don't like this design <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/sad.png" height="16" width="16"
align="absmiddle" alt="" border="0"/> P.GRANT (P.AUTHORIZE) would be an equivalent of the
old FULL_ACCESS, but on steroids. A super-permission that includes other
permissions.<br/>No, permissions should not intersect. 


New Comment: 
It's a meta-permission really (permission to grant permissions). It just doesn't belong
there. 


New Comment: 
Also queries like "LIST ALTER PERMISSIONS ON data/ks" now won't show everybody capable of
altering data/ks. Will have to list grant permissions as well (since a user with P.GRANT
will be able to just give P.ALTER to himself at any moment). 


New Comment: 
You're overthinking it.  You still have that problem with fine-grained grant, it's just
more complex.  Nor does "include user with GRANT as a user with LIST" make sense, because
if you want to include users who could POTENTIALLY have LIST, well, a user with GRANT can
give LIST to anyone, not just himself. 


New Comment: 
I probably am. I'll think about it.<br/>But, to clarify - by LIST you meant ALTER, right? 


New Comment: 
To match your example, yes. 


New Comment: 
<a href="https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jbellis"
class="user-hover" rel="jbellis">Jonathan Ellis</a><br/>Now I do think you are more right
than I am.<br/>What do you think about this option: introduce Permission.AUTHORIZE. Let
users with AUTHORIZE on a resource GRANT and REVOKE permissions on that resource to/from
others, but only the permissions they already have (on that resource or its parent,
recursively), including AUTHORIZE itself? I considered this before, but I did overthink it
back then. 


New Comment: 
This will allow to get rid of grantOption and the permission checks in grant() and
authorize() in IAuthority implementations. I'll just add two checks to grant statement and
revokestatement: hasAccess(AUTHORIZE, resource) and
hasAccees(permissiionToBeGratnedOrRevoked, resource). 


New Comment: 
Limiting it to the permissions you already have at least means that you won't be able to
re-grant the revoked permission back to yourself on your own. 


New Comment: 
I previously did overthink 2.2 in <a
href="https://issues.apache.org/jira/browse/CASSANDRA-4874?focusedCommentId=13500289&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13500289"
class="external-link"
rel="nofollow">https://issues.apache.org/jira/browse/CASSANDRA-4874?focusedCommentId=13500289&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13500289</a><br/>It's
not really an escalation - these two users will still be limited to the permissions they
collectively own. So 2.2 should actually work. 


New Comment: 
<blockquote>Limiting it to the permissions you already have at least means that you won't
be able to re-grant the revoked permission back to yourself on your own.</blockquote>Makes
sense to me. 


New Comment: 
v3 vs. v4 changes:<ul class="alternate" type="square">	<li>moved cqlsh and Cql.g cleanup
to a separate patch (remove-consistency-vestigest-cqlsh-and-cqlg.txt) - apply it
first</li>	<li>renamed IAuthority to IAuthorizer to be consistent with
IAuthenticator</li>	<li>renamed {AllowAll,Simple,Legacy}Authority to
*Authorizer</li>	<li>Permission.AUTHORIZE replaced WITH GRANT OPTION</li>	<li>CREATE
KEYSPACE now requires CREATE on ALL KEYSPACES (used to require CREATE on the
not-yet-existing keyspace)</li>	<li>CREATE TABLE now requires CREATE on the parent
keyspace (used to require CREATE on the not-yet-existing table)</li>	<li>new
IAuthorizer.revokeAll(IResource droppedResource) method is called for cleanup when a
keyspace/table gets dropped</li>	<li>IAuthorizer.protectedResources now returns a set of
IResource, not DataResource (future-proofing the
interface)</li>	<li>QueryProcessor.processStatement() now calls validate() first and then
checkAccess() (used to be the other way around)</li>	<li>GRANT, REVOKE and LIST all check
the existence of the resource in question (boolean exists() method has been added to
IResource)</li>	<li>updated NEWS.txt</li>	<li>modified CQL3 syntax (cqlsh autocompletion
has been updated as well)</li></ul>The new CQL3 statements:<ul class="alternate"
type="square">	<li>LIST { ALL [PERMISSIONS] | &lt;perm&gt; [PERMISSION] } <span
class="error">&#91;OF &lt;user&gt;&#93;</span><br/>- LIST { ALL [PERMISSIONS] |
&lt;perm&gt; [PERMISSION] } ON ALL KEYSPACES <span class="error">&#91;OF
&lt;user&gt;&#93;</span> <span class="error">&#91;NORECURSIVE&#93;</span></li>	<li>LIST {
ALL [PERMISSIONS] | &lt;perm&gt; [PERMISSION] } ON KEYSPACE &lt;keyspace&gt; <span
class="error">&#91;of &lt;user&gt;&#93;</span> <span
class="error">&#91;NORECURSIVE&#93;</span><br/>- LIST { ALL [PERMISSIONS] | &lt;perm&gt;
[PERMISSION] } ON <span class="error">&#91;TABLE&#93;</span> <span
class="error">&#91;&lt;keyspace&gt;.&#93;</span>&lt;table&gt; <span class="error">&#91;of
&lt;user&gt;&#93;</span> <span class="error">&#91;NORECURSIVE&#93;</span></li>	<li>GRANT {
ALL [PERMISSIONS] | &lt;perm&gt; [PERMISSION] } ON ALL KEYSPACES TO &lt;user&gt;<br/>-
GRANT { ALL [PERMISSIONS] | &lt;perm&gt; [PERMISSION] } ON KEYSPACE &lt;keyspace&gt; TO
&lt;user&gt;</li>	<li>GRANT { ALL [PERMISSIONS] | &lt;perm&gt; [PERMISSION] } ON <span
class="error">&#91;TABLE&#93;</span> <span
class="error">&#91;&lt;keyspace&gt;.&#93;</span>&lt;table&gt; TO &lt;user&gt;<br/>- REVOKE
{ ALL [PERMISSIONS] | &lt;perm&gt; [PERMISSION] } ON ALL KEYSPACES FROM
&lt;user&gt;</li>	<li>REVOKE { ALL [PERMISSIONS] | &lt;perm&gt; [PERMISSION] } ON KEYSPACE
&lt;keyspace&gt; FROM &lt;user&gt;<br/>- REVOKE { ALL [PERMISSIONS] | &lt;perm&gt;
[PERMISSION] } ON <span class="error">&#91;TABLE&#93;</span> <span
class="error">&#91;&lt;keyspace&gt;.&#93;</span>&lt;table&gt; FROM &lt;user&gt;</li></ul> 


New Comment: 
Not to self: one authentication rewrite is complete, make sure to:<br/>1) Validate user
existence in GRANT/REVOKE/LIST PERMISSIONS<br/>2) Call IAuthority#revokeAll(String
droppedUser) when a user is dropped 


New Comment: 
Attached 'warn-authority.txt' patch that<br/>1. Prints a warning on startup if it detects
'authority' param<br/>2. Throws ConfigurationException if 'authority' isn't set to
'AllowAllAuthority'This way upgrading users who didn't care about authorization in the
first place won't have to update anything.<br/>This is friendlier than just exiting, but
I'm not 100% sure if we should be friendly. Not 100% but pretty sure still. 


New Comment: 
Looks good overall.  A couple comments:<ul class="alternate" type="square">	<li>Prefer
just returning Permission.NONE|ALL instead of copyOf; copying makes me think that the
original (or possibly the copy) should be mutable, which is not the case here</li>	<li>Why
the rewrite of DropIndexStatement?</li></ul> 


New Comment: 
Do we want to support "show me all the permissions that have been granted to object X?" 


New Comment: 
attached 'move-resource-on-to-iauthorizer.txt' that moves filtering on resource to
IAuthorizer itself away from ListPermissionsStatement#execute. 


New Comment: 
<blockquote>Prefer just returning Permission.NONE|ALL instead of copyOf; copying makes me
think that the original (or possibly the copy) should be mutable, which is not the case
here</blockquote>This is only the case with SimpleAuthorizer. The old IAuthority had
authorize() return a EnumSet and Permission.ALL|NONE don't return a EnumSet anymore
(EnumsSet is mutable). copyOf is there to convert Set&lt;Permission&gt; to
EnumSet&lt;Permission&gt;.<blockquote>Why the rewrite of
DropIndexStatement?</blockquote>There used to be no way to get the CF from
DropIndexStatement and I needed one to do a permission check for DROP INDEX (alter on
parent cf). Now there is a way, but that required a rewrite.<blockquote>Do we want to
support "show me all the permissions that have been granted to object X?"</blockquote>We
do, of cource. The latest (last?) patch makes this more explicit. 


New Comment: 
+1 


