Pattern changes caused by commit: c2d748c061f58ad5fa0e022ae6116fd92a1a93f3

From: Flyweight-2
To:   Flyweight-4


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-1850.txt 

commit c2d748c061f58ad5fa0e022ae6116fd92a1a93f3
Author: Gary Dusbabek <gdusbabek@apache.org>

    split OutputBuffer from DataOutputBuffer. patch by stuhood, reviewed by gdusbabek. CASSANDRA-1186



==================================
 Issue CASSANDRA-1186 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-1186] futureproof [KS|CF]MetaData
-----------------

-----------------
Summary: futureproof [KS|CF]MetaData
-----------------

-----------------
Issue type: Improvement
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Sun, 13 Jun 2010 04:37:47 +0000
-----------------

-----------------
Resolved at: Wed, 21 Jul 2010 15:15:29 +0000
-----------------

-----------------
Assigned to: Stu Hood
-----------------

-----------------
Description: 

KSMetaData/CFMetaData serialization is fragile.  We need to be able to add fields easily
without breaking when we read old-style serialized bytes.

Avro and Thrift are designed to
handle this.  We should probably use one of those rather than re-inventing the wheel.  If
Avro is mature enough for this then let's use that, otherwise let's use Thrift.
 

-----------------

-----------------
Comments: 

New Comment: 
I feel comfortable saying that the serialization format for Avro will not change again in
the 1.x series, and the object file container almost certainly will not change. 


New Comment: 
since we have CfDef/KsDef classes from Avro and Thrift already, maybe we should just let
those deal w/ the serialization and wrap them in a class containing our internal logic. 


New Comment: 
Moving to Avro/Thrift serialization isn't going to fix this.  If anything, it will make
things more brittle since we would yield control the the serialization/deserialization
process to outside code (we wouldn't be able to slip in default values to old versions
when they are deserialized against the new schema, etc.).A simple test of serializing an
instance, adding a new field to the class, regenerating it, and then attempting to
deserialize the old version confirmed that Avro can't handle this.  I suspect the same
thing will happen with Thrift.If we use Avro and serialize to JSON, it would be easy to
provide a migration tool that would update serialized schema from version to version. 


New Comment: 
Thrift can absolutely handle this if the new field is marked optional (and doesn't change
the order of the old fields).  I imagine something similar applies to Avro, since this is
very much a use case it is designed for. 


New Comment: 
<blockquote>I imagine something similar applies to Avro, since this is very much a use
case it is designed for.</blockquote>It can. This is the purpose of a default in Avro (as
confusing as that has proven to be). 


New Comment: 
Attaching users/roles to keyspaces for <a
href="https://issues.apache.org/jira/browse/CASSANDRA-1237" title="Store AccessLevels
externally to IAuthenticator" class="issue-link"
data-issue-key="CASSANDRA-1237"><del>CASSANDRA-1237</del></a> will require KSMetaData
changes. 


New Comment: 
0001<br/>Renames config.Keyspace and config.ColumnFamily to match
RawColumnDefinition.0002<br/>Creates an Avro protocol (with no methods) for internal
serialization use. This one will probably cause debate, but I'm fairly sure we want to
separate interface from internal. A better name than 'protocol' would be nice
though.0003<br/>Separates OutputBuffer from DataOutputBuffer, in case someone doesn't need
the DataOutput interface.0004<br/>Adds the SerDeUtils class, which should be a sufficient
replacement for all ICompactSerializers (as more objects are converted to Avro
serialization).0005<br/>Port the config metadata classes to Avro
serialization.0006<br/>Use Avro serialization in the Definitions table and for the
metadata portion of Migrations.0007<br/>Remove duplication/improve encapsulation between
DefsTable and Migrations 


New Comment: 
These patches (in particular 0002 and 0004) begin to lay the groundwork for using Avro
serialization throughout Cassandra.EDIT: It's important to note that only one-shot/object
serialization (where an object is serialized along with its Avro schema) is implemented at
this point. It might be worth considering storing the Avro schemas for all supported
versions within the application so that we can pass around schema/protocol 'versions'
instead of full schemas.The only other significant change is that rows in the definitions
table now store a single column contain a list of all keyspaces for a version.Should be
ready for review. 


New Comment: 
Stu, can you rebase? 


New Comment: 
Rebased for trunk. 


New Comment: 
Minor nits:  <ul>	<li>DOB.buffer() could be private.</li>	<li>No point in implementing
OB.reset().</li>	<li>Why OB.asByteArray instead of overwriting toByteArray?</li></ul>Less
minor:<ul>	<li>I don't see the utility of 0007. I think it increases the
coupling.</li>	<li>Why store the keyspace in a single column? Writes were atomic before
when they were in a single ColumnFamily.</li></ul>I think you should go further and get
rid of all the members in CFMD and KSMD.  Those classes should just end up as statics
collectors that act on avro objects.  When I first investigated this, the only schema
departure I found was adding a cfid to CfDef.  I think things would be tidier if
CfDef/ColumnFamily and KsDef/Keyspace were the same.  The duplication bothers me and I
think we can do better. 


New Comment: 
&gt; DOB.buffer() could be private.<br/>&gt; No point in implementing OB.reset().<br/>I'll
fix these in the next round.&gt; Why OB.asByteArray instead of overwriting
toByteArray?<br/>Because toByteArray makes a guarantee to copy the data, but asByteArray
can avoid copies fairly regularly for one-time use buffers.&gt; I don't see the utility of
0007. I think it increases the coupling.<br/>It does actually add a few lines, its true:
but makeDefinitionsMutation only mutates the Definitions table, and it was duplicating the
serialization logic in loadFromStorage. 0007 removes that duplication.&gt; Why store the
keyspace in a single column? Writes were atomic before when they were in a single
ColumnFamily.<br/>I was worried about multiple Migrations running at once, and needing
isolation: perhaps only one Migration should run at once, so this isn't necessary?&gt; I
think you should go further and get rid of all the members in CFMD and KSMD.<br/>I'll give
this a shot.&gt; I think things would be tidier if CfDef/ColumnFamily and KsDef/Keyspace
were the same.<br/>I agree, but I didn't see a good way to handle the private field:
options seem to be:<ul>	<li>validation that rejects CfDefs with an ID set (likely to bite
everyone)</li>	<li>ignoring the ID on a CfDef (likely to confuse people)</li>	<li>having
private and public objects</li></ul> 


New Comment: 
Rebased for trunk, and applied the following changes:<ul>	<li>Removed the 'private' Avro
schema that was in pre-0002: left behind the build.xml generalization	<ul>		<li>Instead,
serialization of config.KS/CF/CMetaData uses
avro.Ks/Cf/ColumnDef</li>	</ul>	</li>	<li>Switched back to a 'column per keyspace'
datamodel in the "Schema" cf, with a magic column name to store the Avro
schema</li>	<li>Squashed pre-0005 and pre-0006 to 0006</li>	<li>Removed
pre-0007</li></ul>Ready for another look. Thanks for your patience! 


New Comment: 
Rebased for trunk. 


New Comment: 
+1. Excellent work. 


