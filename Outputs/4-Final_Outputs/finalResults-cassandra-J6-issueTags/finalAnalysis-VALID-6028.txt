Pattern changes caused by commit: e48b29a6b0b15f9e1c8d8e462a573daa04d1ec5e

From: Abstract Factory-3
To:   Abstract Factory-2

From: Factory Method-3
To:   Factory Method-2

From: Facade-1
To:   Facade-0

From: Flyweight-3
To:   Flyweight-4


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-6028.txt 

commit e48b29a6b0b15f9e1c8d8e462a573daa04d1ec5e
Author: Brandon Williams <brandonwilliams@apache.org>

    Pig: inferred and actual schema match, smoke tests.
    Patch by brandonwilliams, reviewed by xedin for CASSANDRA-3371



==================================
 Issue CASSANDRA-3371 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-3371] Cassandra inferred schema and actual data don't match
-----------------

-----------------
Summary: Cassandra inferred schema and actual data don't match
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Mon, 17 Oct 2011 10:25:03 +0000
-----------------

-----------------
Resolved at: Mon, 13 Feb 2012 23:45:18 +0000
-----------------

-----------------
Assigned to: Brandon Williams
-----------------

-----------------
Description: 

It's looking like there may be a mismatch between the schema that's being reported by the
latest CassandraStorage.java, and the data that's actually returned. Here's an
example:

rows = LOAD 'cassandra://Frap/PhotoVotes' USING CassandraStorage();<br/>DESCRIBE
rows;<br/>rows: {key: chararray,columns: {(name: chararray,value: bytearray,photo_owner:
chararray,value_photo_owner: bytearray,pid: chararray,value_pid: bytearray,matched_string:
chararray,value_matched_string: bytearray,src_big: chararray,value_src_big:
bytearray,time: chararray,value_time: bytearray,vote_type: chararray,value_vote_type:
bytearray,voter: chararray,value_voter: bytearray)}}<br/>DUMP
rows;<br/>(691831038_1317937188.48955,
{(photo_owner,1596090180),(pid,6855155124568798560),(matched_string,),(src_big,),(time,Thu
Oct 06 14:39:48 -0700 2011),(vote_type,album_dislike),(voter,691831038)}
)

getSchema() is
reporting the columns as an inner bag of tuples, each of which contains 16 values. In
fact, getNext() seems to return an inner bag containing 7 tuples, each of which contains
two values. 

It appears that things got out of sync with this change:<br/><a
href="http://svn.apache.org/viewvc/cassandra/branches/cassandra-0.8/contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java?r1=1177083&amp;r2=1177082&amp;pathrev=1177083"
class="external-link"
rel="nofollow">http://svn.apache.org/viewvc/cassandra/branches/cassandra-0.8/contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java?r1=1177083&amp;r2=1177082&amp;pathrev=1177083</a>

See
more discussion at:<br/><a
href="http://cassandra-user-incubator-apache-org.3065146.n2.nabble.com/pig-cassandra-problem-quot-Incompatible-field-schema-quot-error-tc6882703.html"
class="external-link"
rel="nofollow">http://cassandra-user-incubator-apache-org.3065146.n2.nabble.com/pig-cassandra-problem-quot-Incompatible-field-schema-quot-error-tc6882703.html</a>
 

-----------------

-----------------
Comments: 

New Comment: 
Pete, can you attach this patch as a file?  It's difficult to read in the description. 


New Comment: 
Messy patch to implement matching schema and data return in CassandraLoader. 


New Comment: 
I've attached the patch as a file (couldn't see how when creating the ticket). It's
definitely not ready for prime-time, but hopefully should get across the idea of what I'm
going for. Some notes:<ul class="alternate" type="square">	<li>I think the Hex handling
has changed between top-of-tree and the 0.8.7 version I'm on, so the diff includes some
reversions so I can compile it against my older version. This shouldn't be in any final
version of the patch.</li></ul><ul class="alternate" type="square">	<li>It has been a long
time since I last wrote Java code, so my changes are probably very
non-idiomatic.</li></ul><ul class="alternate" type="square">	<li>I don't attempt to handle
super-columns in getNext(). Looking at the original getSchema() code, it looks like that
case might be unhandled anyway? I see 'if (cfDef.column_type.equals("Super")) return
null;' near the top.</li></ul> 


New Comment: 
And for completeness, here's the definition of the column family in the examples
above:create column family PhotoVotes with<br/>  comparator = UTF8Type and<br/> 
column_metadata =<br/>  [<br/>    {column_name: voter, validation_class: UTF8Type,
index_type: KEYS},<br/>    {column_name: vote_type, validation_class: UTF8Type},<br/>   
{column_name: photo_owner, validation_class: UTF8Type, index_type: KEYS},<br/>   
{column_name: src_big, validation_class: UTF8Type},<br/>    {column_name: pid,
validation_class: UTF8Type, index_type: KEYS},<br/>    {column_name: matched_string,
validation_class: UTF8Type},<br/>    {column_name: time, validation_class: UTF8Type},<br/>
 ]; 


New Comment: 
This approach has many problems, such as column name and key collisions.  Instead, what we
need to is wrap the column/value pairs in their own tuple and then insert these into an
outer tuple that goes in the bag, causing the schema the match our actual output.  v2 does
this. 


New Comment: 
Is there a reason the columns can't at least go into a map? As things stand, it's
painfully hard to do the natural row.column.value lookup in a script. Or to put it as a
concrete example, I can currently do this:all_votes = LOAD 'cassandra://Frap/PhotoVotes'
USING CassandraStorage();<br/>album_votes = FILTER all_votes BY ((vote_type EQ
'album_like') OR (vote_type EQ 'album_dislike'));What does this example look like with
your approach? 


New Comment: 
I had what I thought would be a good idea to accomodate this: I'd alias the tuples
themselves after the index names, allowing you to do something like this:<div
class="preformatted panel" style="border-width: 1px;"><div class="preformattedContent
panelContent"><pre>album_votes = FILTER all_votes BY (columns.vote_type.value EQ
'album_like') OR (columns.vote_type.value EQ 'album_dislike');</pre></div></div>It's not
that easy, however.  When you dereference a bag, it automatically dereferences the tuple
inside it (programmatically, a bag can only have one tuple, but that tuple can contain
anything, and thus the automatic deref to mask this from the user.)  Unfortunately, it
appears to also deref any other tuples inside as well, so you end up in a situation where
'columns.$0' returns the column name, and weird aliasing issues like 'columns.&lt;first
index name&gt;' also returns the column name and the second index returns the value, with
the rest being null.To get around this, I thought I'd nest each tuple inside another bag. 
This of course results in a crazy looking schema:<div class="preformatted panel"
style="border-width: 1px;"><div class="preformattedContent panelContent"><pre>votes: {key:
bytearray,columns: {(matched_string: {(name: chararray,value: chararray)},photo_owner:
{(name: chararray,value: chararray)},pid: {(name: chararray,value: chararray)},src_big:
{(name: chararray,value: chararray)},time: {(name: chararray,value: chararray)},vote_type:
{(name: chararray,value: chararray)},voter: {(name: chararray,value:
chararray)})}}</pre></div></div>but if it still derefs as elegantly, it won't be too bad. 
The problem here is that it still can't deref correctly, you end up with nonsensical
parsing errors such as:<div class="preformatted panel" style="border-width: 1px;"><div
class="preformattedContent panelContent"><pre>ERROR 1200: Pig script failed to parse:
&lt;file photo.pig, line 5, column 8&gt; pig script failed to validate:
org.apache.pig.impl.logicalLayer.FrontendException: ERROR 1128: Cannot find field name in
matched_string:bag{:tuple(name:chararray,value:chararray)</pre></div></div>even though the
'name' alias is clearly there and 'matched_string' was already being deref'd.So I decided
to just get rid of the all the bags, and instead did a tuple of tuples.  This worked!  But
the problem here is that a tuple has to fit into memory, where a bag can spill to disk if
it is very large.  Currently this won't be an issue since we have to fit the entire row
into memory via thrift anyway, but in the future when we have large row support the
contract may have to change again.  Maybe this is the best option though since right now
it Just Works and nothing else is viable.While going through all this I noticed two other
problems we currently have.  We need to put the indexed columns at the beginning so they
can match the schema (since any amount of non-indexed columns may fall between them in
sorting order) and the default validator is always being used due to a bad lookup.  These
are trivial to solve, however.  v3 fixes these issues and takes the 'tuple of tuples'
approach, for better or worse. 


New Comment: 
<blockquote>Is there a reason the columns can't at least go into a map? </blockquote>Maps
only support string keys as far as I know (and also have the unspillable problem.) 


New Comment: 
Thanks Brandon, sounds very promising, excited to try it out. 


New Comment: 
Works like a charm, thanks again Brandon. 


New Comment: 
Brandon, Jacob Perkins, and Jeremy (me) had a long discussion about how to address this as
well as other issues with CassandraStorage.  We came down to a list of 3-4 things that if
implemented would resolve the problem with pig 0.9 as well as make CassandraStorage much
more usable.1. Fix schema so that this ticket's problem is resolved - this goes along with
#2.2. have the default return value from CassandraStorage be (key, column, value) as is
thought of for transposing wide rows.  If in the constructor, something like pygmalion's
FromCassandraBag is specified, then return that.  See pygmalion's doc for that.3. Inspect
what is passed in for the output and if it conforms to pygmalion's ToCassandraBag - namely
a key and a bunch of columns, it will introspect the pig schema and use those pig variable
names for the column names.4. Optionally handle the uniqueness case with some kind of
context/random identifier so that multiple CassandraStorage instances writing out don't
get confused with the schema. 


New Comment: 
Thanks for digging into this. To help me understand better, do you have a concrete example
of how the example script I mentioned would look? With Brandon's current solution it's
like this:all_votes = LOAD 'cassandra://Frap/PhotoVotes' USING
CassandraStorage();<br/>album_votes = FILTER all_votes BY ((columns.vote_type.value EQ
'album_like') OR (columns.vote_type.value EQ 'album_dislike'));This is very usable, and my
only concern would be that alternative solutions wouldn't make this common use case as
easy. 


New Comment: 
I think with the pygmalion style of specification, it might require a bit more on the
load, but less on the filter.  The columns var wouldn't be needed on the filter, for
example.  It would just look like the pygmalion examples except you wouldn't need
FromCassandraBag, you would specify that in "USING CassandraStorage('vote_type')"So I
think it would just be:<br/>all_votes = LOAD 'cassandra://Frap/PhotoVotes' USING
CassandraStorage('vote_type'); &#8211; you can add any additional columns<br/>album_votes
= FILTER all_votes BY (vote_type EQ 'album_like') OR (vote_type EQ 'album_dislike');You
can add other columns as you need them in the CassandraStorage section. 


New Comment: 
That makes sense, and looks very approachable, thanks. I'll keep an eye on the comments
here so I can give it a try as soon as a prototype is available. Thanks again Brandon,
Jacob and Jeremy for your hard work on this one. 


New Comment: 
I've been following this thread and am actively trying to use CassandraStorage. Before I
found this thread, I tried a bunch of stuff on my own with varying degrees of success. My
most pressing issue right now is regarding rows with different columns. I do not believe
the Pig schema that gets generated supports that. Please advise. Thanks! 


New Comment: 
<blockquote>1. Fix schema so that this ticket's problem is resolved</blockquote>v4 does
this, however it's not quite all of what we want.<blockquote>2. have the default return
value from CassandraStorage be (key, column, value) as is thought of for transposing wide
rows</blockquote>After thinking about this more, that's the wrong way to approach that,
because if you DO want to work within the row, now you have to do an expensive group to
get back what we had before &#8211; a nest structure &#8211; where breaking that structure
up into (k, c, v) is extremely cheap if that's what you want.  So ultimately, we need to
stick with a bag for spillage, and thus keep the existing schema.  v4 does this.v4 also
names the <b>values</b> of indexed/validated columns after their name, which is more
pygmalion-style, since you'll always want to filter the value, not the name.The problem,
however, is strange parsing problems again:<div class="preformatted panel"
style="border-width: 1px;"><div class="preformattedContent panelContent"><pre>ERROR 1200:
Pig script failed to parse: &lt;file foo.pig, line 3, column 7&gt; pig script failed to
validate: org.apache.pig.impl.logicalLayer.FrontendException: ERROR 1128: Cannot find
field owner_id in :tuple(name:chararray,owner_id:chararray)</pre></div></div>The seems
related to the fact that schema-wise, a bag can only contain a single tuple - but that
tuple can then contain any number of items.  Apparently this is only a hard requirement in
0.9 or later, but I tested it up to trunk so it doesn't look like it's going anywhere.In
practice, however, getNext doesn't actually return this 'container' tuple.  If you do you
get casting errors.I'm not really sure how we can fix this, and finding other examples of
LoadMetadata implemented with bags are hard to come by. 


New Comment: 
I resolved <a href="https://issues.apache.org/jira/browse/PIG-2485" title="Unable to find
alias in a bag with nested schema" class="issue-link"
data-issue-key="PIG-2485"><del>PIG-2485</del></a> as invalid.  You can read the
explanation there, but I'll go ahead and summarize: a bag's schema can only contain one
tuple because it is assumed that all tuples in the bag have the same schema.  Obviously
this won't be true in Cassandra since we allow any column to have any schema that you
like.  However, after talking with Dmitriy Ryaboy, I have a plan.  We got good results out
of tuple-of-tuples, but this won't work with wide rows.  Another thing it won't work with
is small rows where some columns have metadata, and some do not, because when you define a
tuple-of-tuples that is a hard constraint; you can't define 4 and then return 20.  So what
I propose is that we change the output format to be a tuple-of-tuples for all columns that
have metadata, and then a bag with the rest of the columns with a single schema (the
default comparator/validator.)  This will work for both static and wide rows, unless you
manage to define metadata on so many columns in a wide row that they themselves qualify as
wide.To give an example, let's continue with what Pete started with a slight
modification:<div class="preformatted panel" style="border-width: 1px;"><div
class="preformattedContent panelContent"><pre>create column family PhotoVotes
withcomparator = UTF8Type andcolumn_metadata =[{column_name: voter, validation_class:
UTF8Type, index_type: KEYS},{column_name: vote_type, validation_class:
UTF8Type},{column_name: photo_owner, validation_class: UTF8Type, index_type:
KEYS},{column_name: src_big, validation_class: UTF8Type},{column_name: pid,
validation_class: UTF8Type, index_type: KEYS},{column_name: matched_string,
validation_class: UTF8Type},{column_name: time, validation_class:
LongType},];</pre></div></div>Loading this from pig produces a schema like:<br/>(key:
bytearray,matched_string: (name: chararray,value: chararray),photo_owner: (name:
chararray,value: chararray),pid: (name: chararray,value: chararray),src_big: (name:
chararray,value: chararray),time: (name: chararray,value: long),vote_type: (name:
chararray,value: chararray),voter: (name: chararray,value: chararray),columns: {(name:
chararray,value: bytearray)})This should allow you do things like:FILTER rows by
vote_type.value eq 'album_like'Note that the <b>tuple</b> is named after the index, and
inside the tuple we still have 'name' and 'value'.  This is because if we don't have the
name accessible, this is going to be hard to store later (and schema introspection is a
bit more magic than I'd care to use.) 


New Comment: 
v5 implements this schema.  No work on the putNext side of things yet since I haven't
quite decided how to handle that. 


New Comment: 
Rebased v5 after <a href="https://issues.apache.org/jira/browse/CASSANDRA-3251"
title="CassandraStorage uses comparator for both super column names and sub column names."
class="issue-link" data-issue-key="CASSANDRA-3251"><del>CASSANDRA-3251</del></a> 


New Comment: 
This issue also affects 1.0.7. Banged my head against the wall for an hour or so before I
found this issue. The patch does not apply cleanly on 1.0.7 either :-/ 


New Comment: 
New patches build upon v5 and adds output storage to match.  The catch, however, is that
either the tuples (indexed/validated columns) or the bag (unknown columns) are optional,
so if you are dealing with narrow output, you can just make a tuple like (key,
(name,value), (name,value)) and that will work. 


New Comment: 
v6 is rebased and contains minor cleanups, smoke_test contains a file to be replayed by
the cli and a pig script to exercise loading/storing every cassandra type. 


New Comment: 
+1 on the v6 with cleanup patch attached - replaced ArrayList, HashMap with interfaces,
added generic description to reader/writer so no more blind casts, changed thrift
{Super}Column to user setX(...) methods and removed whitespaces. 


