Pattern changes caused by commit: d2c98b024d85bf72a6ce3e03d0b8d2994199c254

From: Abstract Factory-3
To:   Abstract Factory-2

From: Factory Method-3
To:   Factory Method-2

From: Mediator-2
To:   Mediator-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-4038.txt 

commit d2c98b024d85bf72a6ce3e03d0b8d2994199c254
Author: Jonathan Ellis <jbellis@apache.org>

    avoid using cached position of a keywhen GTis requested
    patch by Richard Low and slebresne; reviewed by jbellis for CASSANDRA-2633



==================================
 Issue CASSANDRA-2633 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-2633] Keys get lost in bootstrap
-----------------

-----------------
Summary: Keys get lost in bootstrap
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Wed, 11 May 2011 10:36:19 +0000
-----------------

-----------------
Resolved at: Wed, 11 May 2011 20:55:23 +0000
-----------------

-----------------
Assigned to: Richard Low
-----------------

-----------------
Description: 

When bootstrapping a new node, the key at the upper end of the new node's range can get
lost.  To reproduce:
<ul>	<li>Set up one cassandra node, create a keyspace and column
family and perform some inserts</li>	<li>Read every row back</li>	<li>Bootstrap a second
node</li>	<li>Read every row back</li></ul>
You find one row is missing, whose row key is
exactly equal to the token the new node gets (for OPP - for RP it's the key whose hash is
equal to the token).  If you don't do the reads after the inserts, the key is not lost.  I
tracked the problem down to o.a.c.io.sstable.SSTableReader in getPosition.  The problem is
that the cached position is used if it is there (so only if the reads were performed). 
But this is incorrect because the cached position is the start of the row, not the end. 
This means the end row itself is not transferred.  This causes the last key in the range
to get lost.

Although I haven't seen it, this may occur during antientropy repairs
too.

The attached patch (against the 0.7 branch) fixes it by not using the cache for
Operator.GT.  I haven't tested with 0.8 but from looking at the code I think the problem
is present.

This might be related to <a
href="https://issues.apache.org/jira/browse/CASSANDRA-1992" title="Bootstrap breaks data
stored (missing rows, extra rows, column values modified)" class="issue-link"
data-issue-key="CASSANDRA-1992"><del>CASSANDRA-1992</del></a>
 

-----------------

-----------------
Comments: 

New Comment: 
So say we have a node A with rows A B C D on it.We bootstrap a node C.C requests (A, C]
from A.A will do a GT scan starting with A.  So a cache hit will result in <span
class="error">&#91;A, C&#93;</span> being transferred instead. That is a bug, I'll see if
I can create a unit test that demonstrates that separately.But I don't see how this
affects the C row? 


New Comment: 
A cache hit results in [A, C) being returned.  All GT scans with cache hits give positions
at the start of the row rather than the end.  The above patch fixes both ends - skip over
A, but include C. 


New Comment: 
getPosition only affects start of scan, not end. 


New Comment: 
Good catch. Attaching a unit test to catch the bug. 


New Comment: 
It looks to me that for client reads, getPosition is just used for the start of an
iterator, as you say.  But for streaming, getPosition is used for the end position too in
SSTableReader.getPositionsForRanges.  Or have I misunderstood what's going on? 


New Comment: 
<blockquote>But I don't see how this affects the C row?</blockquote>This affects the C row
because it will use the position of C found as the position where to stop scanning. But
the position of C is the start of C, so when used as an end position, it excludes it. That
is, getPositionForRanges will return (start of A, start of C), which results in scanning
[A, C) as Richard says.So +1 on this. 


New Comment: 
got it.  committed, thanks! 


