Pattern changes caused by commit: 4d637f1f1b62593e0c52e49966e3f286bf65c3e9

From: Decorator-2
To:   Decorator-1

From: Flyweight-2
To:   Flyweight-1

From: Mediator-3
To:   Mediator-1

From: Strategy-0
To:   Strategy-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-7681.txt 

commit 4d637f1f1b62593e0c52e49966e3f286bf65c3e9
Author: Dave Brosius <dbrosius@apache.org>

    fix get_range_slices with startkey and endtoken specified
    patch by Nikolay (nmmm) reviewed by dbrosius for CASSANDRA-4804



==================================
 Issue CASSANDRA-4804 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-4804] Wrong assumption for KeyRange about range.end_token in get_range_slices().
-----------------

-----------------
Summary: Wrong assumption for KeyRange about range.end_token in get_range_slices().
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Sun, 14 Oct 2012 15:45:27 +0000
-----------------

-----------------
Resolved at: Wed, 17 Oct 2012 04:01:42 +0000
-----------------

-----------------
Assigned to: Nikolay
-----------------

-----------------
Description: 

In get_range_slices() there is parameter KeyRange range.

There you can pass start_key -
end_key, start_token - end_token, or start_key - end_token.

This is described in the
documentation.

in thrift/ThriftValidation.java there is validation function
validateKeyRange() (line:489) that validates correctly the KeyRange, including the case
start_key - end_token.

However in thrift/CassandraServer.java in function
get_range_slices() on line: 686 wrong assumption is made:

   if (range.start_key ==
null)
   {      ... // populate tokens   }<br/><br/>   else<br/><br/>   {      bounds =
new Bounds&lt;RowPosition&gt;(RowPosition.forKey(range.start_key, p),
RowPosition.forKey(range.end_key, p));   }<br/><br/>This means if there is start key, no
end token is checked.<br/>The opposite - null is "inserted" as
end_key.<br/><br/>Solution:<br/>same file - thrift/CassandraServer.java on next function -
get_paged_slice(), on line:741 same code is written correctly<br/><br/>   if
(range.start_key == null)<br/><br/>   {      ... // populate tokens   }
   else
   {     
RowPosition end = range.end_key == null ?
p.getTokenFactory().fromString(range.end_token).maxKeyBound(p)                           :
RowPosition.forKey(range.end_key, p);      bounds = new
Bounds&lt;RowPosition&gt;(RowPosition.forKey(range.start_key, p), end);   } 

-----------------

-----------------
Comments: 

New Comment: 
patch tested in 1.1.5 and 1.1.6<br/>did not check in 1.2, but is trivial. 


New Comment: 
Can you review, Dave? 


New Comment: 
it seems to me you should check range.isSetEnd_key() and range.isSetEnd_token() to see
what option you should use as i believe it's valid for the value to be null, meaning end
of range.bah... ignore this comment. new byte<span class="error">&#91;0&#93;</span> is the
way to specify end of range. 


New Comment: 
1.2 patch doesn't apply cleanly. remove commented out codeotherwise patch works as
expected. 


