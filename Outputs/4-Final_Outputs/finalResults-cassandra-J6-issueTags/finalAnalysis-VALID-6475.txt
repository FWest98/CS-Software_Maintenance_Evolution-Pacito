Pattern changes caused by commit: f956569dbd7848eadbe5e70b12fadb7e25e0fc4a

From: Flyweight-1
To:   Flyweight-3

From: Mediator-1
To:   Mediator-2


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-6475.txt 

commit f956569dbd7848eadbe5e70b12fadb7e25e0fc4a
Author: Vijay Parthasarathy <vijay2win@gmail.com>

    avoid seg faults during compaction
    patch by Vijay; reviewed by jbellis for CASSANDRA-4111



==================================
 Issue CASSANDRA-4111 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-4111] Serializing cache can cause Segfault in 1.1
-----------------

-----------------
Summary: Serializing cache can cause Segfault in 1.1
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Mon, 2 Apr 2012 23:29:50 +0000
-----------------

-----------------
Resolved at: Tue, 3 Apr 2012 19:35:35 +0000
-----------------

-----------------
Assigned to: Vijay
-----------------

-----------------
Description: 

Rare but this can happen per sure, looks like this issue is after <a
href="https://issues.apache.org/jira/browse/CASSANDRA-3862" title="RowCache misses
Updates" class="issue-link" data-issue-key="CASSANDRA-3862"><del>CASSANDRA-3862</del></a>
hence affectes only 1.1

        FreeableMemory old = map.get(key);<br/>        if (old ==
null)<br/>            return false;

        // see if the old value matches the one we
want to replace<br/>        FreeableMemory mem = serialize(value);<br/>        if (mem ==
null)<br/>            return false; // out of memory.  never mind.<br/>        V oldValue
= deserialize(old);<br/>        boolean success = oldValue.equals(oldToReplace) &amp;&amp;
map.replace(key, old, mem);

        if (success)<br/>            old.unreference();<br/> 
      else<br/>            mem.unreference();<br/>        return success;

in the above
code block we deserialize(old) without taking reference to the old memory, this can case
seg faults when the old is reclaimed (free is called)<br/>Fix is to get the reference just
for deserialization

        V oldValue;<br/>        // reference old guy before
de-serializing<br/>        old.reference();<br/>        try
        {             oldValue
= deserialize(old);        }
        finally
        {            old.unreference();      
 } 

-----------------

-----------------
Comments: 

New Comment: 
Noticed it when compaction was serializing it and update was freeing it. 


New Comment: 
good catch.  also need to handle old.reference() returning false tho. 


New Comment: 
ahaaa missed that.... V2 fixes it. Thanks! 


New Comment: 
+1 


