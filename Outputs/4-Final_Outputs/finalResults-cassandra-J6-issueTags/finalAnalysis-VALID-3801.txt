Pattern changes caused by commit: 0fb4df971685d7616131063205b93007330a4ad6

From: Abstract Factory-3
To:   Abstract Factory-2

From: Factory Method-3
To:   Factory Method-2

From: Mediator-2
To:   Mediator-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-3801.txt 

commit 0fb4df971685d7616131063205b93007330a4ad6
Author: Sylvain Lebresne <slebresne@apache.org>

    Invalidate cache for streamed rows
    patch by slebresne; reviewed by jbellis for CASSANDRA-2420



==================================
 Issue CASSANDRA-2420 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-2420] row cache / streaming aren't aware of each other
-----------------

-----------------
Summary: row cache / streaming aren't aware of each other
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Tue, 5 Apr 2011 21:26:50 +0000
-----------------

-----------------
Resolved at: Mon, 18 Apr 2011 14:52:25 +0000
-----------------

-----------------
Assigned to: Sylvain Lebresne
-----------------

-----------------
Description: 

SSTableWriter.Builder.build() takes tables that resulted from streaming, repair,
bootstrapping, et cetera and builds the indexes and bloom filters before "adding" it so
the current node is aware of it.

However, if there is data present in the cache for a row
that is also present in the streamed table the row cache can over shadow the data in the
newly built table.  In other words, until the row in row cache is removed from the cache
(e.g. because it's pushed out because of size, the node is restarted, the cache is
manually cleared) the data in the newly built table will never be returned to
clients.

The solution that seems most reasonable at this point is to have
SSTableWriter.Builder.build() (or something below it) update the row cache if the row key
in the table being built is also present in the cache.
 

-----------------

-----------------
Comments: 

New Comment: 
There is a very simple patch for this issue. It consists in invalidating the cache for
each key we index. The downside is that this will invalidate all key that gets repaired,
but updating the cache (instead of invalidating) implies reading on disk so doing this
during the indexing or at the next read may not matter much. In any case, this is better
that the current situation and after all .I however attached a patch (against trunk for
now) that 'do the right thing' and will update the cache in the case of repair instead of
invalidating. I mentioned the first solution in case we consider that the 'right one' is
too disruptive for 0.7 for instance (not that the patch is very complicated).Note that the
patch fixes a tiny unrelated issue: the writeStat are not updated during a write if the
used cache has 'isPutCopying' (this could be fixed separately). 


New Comment: 
I would be more comfortable having LCR throw UnsupportedOperation if asked for full row,
since You Shouldn't Do That.Would prefer the updateCache case to be AES: ... default:
invalidate and break; it's more obvious looking at it what the point is, and "unnecessary"
invalidate calls will be harmless. 


New Comment: 
<blockquote>I would be more comfortable having LCR throw UnsupportedOperation if asked for
full row, since You Shouldn't Do That.</blockquote>Updated patch defines
getFullColumnFamily() only for AbstractCompactedRow. However I think it would be a bad
idea to fail in the Builder, so the Builder now simply invalidate the cache if he is
facing a big row (hence not fitting it in memory) and log a warning since if that happens
"you're doing it wrong".I've also changed the switch case in updateCache. 


New Comment: 
+1 


New Comment: 
nit: s/higly/highly/ in the logged warning 


New Comment: 
Integrated in Cassandra #854 (See <a
href="https://hudson.apache.org/hudson/job/Cassandra/854/" class="external-link"
rel="nofollow">https://hudson.apache.org/hudson/job/Cassandra/854/</a>)<br/>    Merge <a
href="https://issues.apache.org/jira/browse/CASSANDRA-2420" title="row cache / streaming
aren&#39;t aware of each other" class="issue-link"
data-issue-key="CASSANDRA-2420"><del>CASSANDRA-2420</del></a> from 0.8 


New Comment: 
Integrated in Cassandra-0.8 #13 (See <a
href="https://hudson.apache.org/hudson/job/Cassandra-0.8/13/" class="external-link"
rel="nofollow">https://hudson.apache.org/hudson/job/Cassandra-0.8/13/</a>)<br/>    Update
row cache post streaming<br/>patch by slebresne; reviewed by jbellis for <a
href="https://issues.apache.org/jira/browse/CASSANDRA-2420" title="row cache / streaming
aren&#39;t aware of each other" class="issue-link"
data-issue-key="CASSANDRA-2420"><del>CASSANDRA-2420</del></a> 


New Comment: 
Committed to 0.8 and trunk.<br/>Was should we do about 0.7 ? I realized that we do not
differentiate between the different reason for streaming in 0.7, so the simplest way to
deal with this would probably be to just blindly invalidate the cache. Sounds reasonable ? 


New Comment: 
Yes. 


New Comment: 
Attaching simple patch targeting 0.7. I put it for review individually because it's
different enough from previous patch (but it's a one-liner, so should be too long to
review anyway) 


New Comment: 
+1 


New Comment: 
Committed to 0.7 and 0.7/trunk 


