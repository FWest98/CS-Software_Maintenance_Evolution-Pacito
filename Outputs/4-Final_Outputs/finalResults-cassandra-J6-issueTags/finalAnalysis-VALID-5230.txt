Pattern changes caused by commit: 122da04f989673b3c912929b2d88ff8cbc811509

From: Decorator-1
To:   Decorator-0

From: Facade-1
To:   Facade-0

From: Flyweight-4
To:   Flyweight-5

From: Strategy-1
To:   Strategy-0


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-5230.txt 

commit 122da04f989673b3c912929b2d88ff8cbc811509
Author: Sylvain Lebresne <slebresne@apache.org>

    Only count compaction as active (for throttling) once the compaction lock has been acquired.
    patch by Fabien Rousseau and slebresne; reviewed by jbellis for CASSANDRA-3344



==================================
 Issue CASSANDRA-3344 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-3344] Compaction throttling can be too slow
-----------------

-----------------
Summary: Compaction throttling can be too slow
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Tue, 11 Oct 2011 10:29:52 +0000
-----------------

-----------------
Resolved at: Fri, 14 Oct 2011 08:55:18 +0000
-----------------

-----------------
Assigned to: Sylvain Lebresne
-----------------

-----------------
Description: 

Compaction throttling needs to know how many active compactions are running (to divide
bandwith for each active compaction).

The way active compaction is counted can be broken
because it counts the number of active threads in the executor BUT the thread starts by
acquiring a lock.<br/>If the lock can't be acquired immediately : the thread is seen as
"active" but does not participate in IO operations.<br/>The case can happen when major
compaction are triggered (major compaction acquire a write lock, while minor compactions
acquire a read lock).

Having compaction througput to 16Mb/s, we observed is the following
 (two times) :
<ul class="alternate" type="square">	<li>only 1 active compaction (a long
one for a few hours) starting at 16Mb/s, then after some time running at 2Mb/s, thus
taking a very long time to complete</li>	<li>many pending compactions</li></ul>
Using JMX
and monitoring the stack trace of the compaction threads showed that :
<ul
class="alternate" type="square">	<li>1 thread was effectively compacting</li>	<li>1 thread
was waiting to acquire the write lock (due to a major compaction)</li>	<li>6 threads were
waiting to acquire the read lock (probably due to the thread above trying to acquire the
write lock)</li></ul>
Attached is a proposed patch (very simple, not yet tested) which
counts only active compactions.
 

-----------------

-----------------
Comments: 

New Comment: 
Good diagnostic, I think you are right that this can happen. However the patch seems to
replace the body of getActiveCompactions() by a recursive call to itself. 


New Comment: 
Attaching a simple patch to add a counter that we only increment once we really do
compaction. 


New Comment: 
Thanks for catching that.<br/>The intent was to return the size of the
CompactionExecutor.compactions list 


New Comment: 
Right, that's indeed even simpler. Attaching v2 to do that instead. 


New Comment: 
+1 v2 


New Comment: 
Committed, thanks 


