Pattern changes caused by commit: 6f31aba0e1183a9ad3977bd8e0ed97b42bc7d1d5

From: Decorator-2
To:   Decorator-1

From: Flyweight-2
To:   Flyweight-1

From: Mediator-3
To:   Mediator-1

From: Strategy-0
To:   Strategy-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-7731.txt 

commit 6f31aba0e1183a9ad3977bd8e0ed97b42bc7d1d5
Author: Jonathan Ellis <jbellis@apache.org>

    initialize column iteration lazily so filter will be ready when it's first used
    patch by slebresne and Piotr Ko≈Çaczkowski; reviewed by jbellis for CASSANDRA-4816



==================================
 Issue CASSANDRA-4816 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-4816] Broken get_paged_slice
-----------------

-----------------
Summary: Broken get_paged_slice
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Tue, 16 Oct 2012 14:21:27 +0000
-----------------

-----------------
Resolved at: Wed, 24 Oct 2012 19:48:43 +0000
-----------------

-----------------
Assigned to: Piotr Kolaczkowski
-----------------

-----------------
Description: 

get_paged_slice doesn't reset the start column filter for the second returned row
sometimes. So instead of getting a slice:

row 0:
&lt;start_column&gt;...&lt;last_column_in_row&gt;<br/>row 1: &lt;first column in a
row&gt;...&lt;last_column_in_row&gt;<br/>row 2: &lt;first column in a row&gt;...

you
sometimes get:

row 0: &lt;start_column&gt;...&lt;last_column_in_row&gt;<br/>row 1:
&lt;start_column&gt;...&lt;last_column_in_row&gt;<br/>row 2: &lt;first column in a
row&gt;...
 

-----------------

-----------------
Comments: 

New Comment: 
My bet would be that this is due to the memtable iterator. The way we implement
get_paged_slice, we reset the start of the QueryFilter used after the first row have been
read. Which means that for each row, we need to make sure the filter is not used until
we've processed the preceding row. This is the case for the sstable iterator, but not for
the memtable one. Attaching patch to change that (I haven't tested the patch though). 


New Comment: 
Scratch that patch, brain fart. The AbstractIterator.computeNext() is called no sooner
than on hasNext() so we should be good on that front. Still don't know what is the problem
here. 


New Comment: 
Ok, second attempt. Looking more closing it does seem that this is a problem with the
interaction of the mergeIterator and the SSTableScanner. Basically the mergeIterator
always needs to know what his "the next row" (during the reducing phase). If that next row
was the one that the reducer ended up returning, we were fine (so with 1 sstable or if all
sstables had the same rows, it was ok), but otherwise it might end up using the
QueryFilter before it should for our get_paged_slice "hack".Anyway, all that the
mergeIterator needs during its reduction phase is to know the next key. So attaching a
patch that delay the use of the filter until the row data is actually queried. 


New Comment: 
Attaching 3rd version of the patch. LazyColumnIterator is used both for SSTableScanners
and Memtable.<br/>This version works for me. 


New Comment: 
+1 this version fixes my tests as well. 


New Comment: 
To be clear, I'm also good on version 3 but I'll let Jonathan review since I've wrote
version 2 on which version 3 is based. 


