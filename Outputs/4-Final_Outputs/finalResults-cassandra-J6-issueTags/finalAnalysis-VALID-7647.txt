Pattern changes caused by commit: 178c934aa14b0653bf92de4083177a2a32637a7c

From: Decorator-2
To:   Decorator-1

From: Flyweight-2
To:   Flyweight-1

From: Mediator-3
To:   Mediator-1

From: Strategy-0
To:   Strategy-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-7647.txt 

commit 178c934aa14b0653bf92de4083177a2a32637a7c
Author: Jonathan Ellis <jbellis@apache.org>

    ignore replayposition in sstables that may not be generated by time-in-millis
    patch by jbellis; reviewed by Fabien Rousseau for CASSANDRA-4782



==================================
 Issue CASSANDRA-4782 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-4782] Commitlog not replayed after restart
-----------------

-----------------
Summary: Commitlog not replayed after restart
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Tue, 9 Oct 2012 16:51:29 +0000
-----------------

-----------------
Resolved at: Thu, 11 Oct 2012 13:59:06 +0000
-----------------

-----------------
Assigned to: Jonathan Ellis
-----------------

-----------------
Description: 

It seems that there are two corner cases where commitlog is not replayed after a restart
:
<ul class="alternate" type="square">	<li>After a reboot of a server + restart of
cassandra (1.1.0 to 1.1.4)</li>	<li>After doing an upgrade from cassandra 1.1.X to
cassandra 1.1.5</li></ul>
This is due to the fact that the commitlog segment id should
always be an  incrementing number (see this condition : <a
href="https://github.com/apache/cassandra/blob/trunk/src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java#L247"
class="external-link"
rel="nofollow">https://github.com/apache/cassandra/blob/trunk/src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java#L247</a>
)

But this assertion can be broken :<br/>In the first case, it is generated by
System.nanoTime() but it seems that System.nanoTime() is using the boot time as the
base/reference (at least on java6 &amp; linux), thus after a reboot, System.nanoTime() can
return a lower number than before the reboot (and the javadoc says the reference is a
relative point in time...)<br/>In the second case, this was introduced by #4601 (which
changes System.nanoTime() by System.currentTimeMillis() thus people starting with 1.1.5
are safe)

This could explain the following tickets : #4741 and #4481
 

-----------------

-----------------
Comments: 

New Comment: 
Thanks for the summary.  What are you proposing we do? 


New Comment: 
To solve the first case, it's probably better, when possible, to upgrade to a newer
version, then rewrite all SSTables (or at least all SSTables metadata)<br/>For the second
case, just rewrite all SSTables (or at least all SSTables metadata)Each SSTable metadata
contains the ReplayPosition (and the max is taken to know which commitlog to replay), thus
if System.nanoTime() returned a number which is a timestamp in the future, previous
commitlogs will be ignored),<br/>thus a drain should prevent from losing data (because
there is no commitlog to replay).<br/>And because SSTables are immutables, then rewriting
them completely seems a better option (rather than modifying previously written
metadata)Maybe the simplest to do is to have a new option to nodetool (or a new option to
nodetool upgradesstables) which only changes the metadata using the following rule
:<br/>if the replayPosition.segment of the SSTable is in the future, then reset it to NONE
otherwise, let it to its current value. (NONE is valid value if node was drained and
restarted)By using this rule :<ul class="alternate" type="square">	<li>if a sstable was
generated previously using a higher System.nanoTime() then it is reset</li>	<li>if a
sstable was generated previously using a lower System.nanoTime() OR
System.currentTimeMillis() then it is left as is</li>	<li>if a sstable is generated
between the start &amp; this rewriting process, then it is left as is</li></ul>Thus the
upgrade should be :<ul class="alternate" type="square">	<li>drain
node</li>	<li>upgrade</li>	<li>start</li>	<li>run the process described
above</li></ul>What do you think ? 


New Comment: 
Thanks, Fabien.  I admit that I didn't realize at first the implications of the millis fix
on existing sstable metadata.Patch attached that bumps the sstable version to hf as a
marker that we know metadata with that version has sane replay positions.  Replay
positions from older metadata will be treated as NONE.This will force a full replay the
first restart on 1.1.6; afterwards, any newly flushed sstables will have the
sane-replay-position marker and future restarts will not need to replay data
unnecessarily.What do you think? 


New Comment: 
(patch revised to update CURRENT_VERSION as well) 


New Comment: 
Thanks for the patch. This solution is more simple and elegant than the one I proposed.I
tested it and it worked like a charm.<br/>Nevertheless, if there are counters CF, a drain
is probably necessary to avoid replaying the full commitlog and avoid having overcounts.
(I don't think it is a problem, just something to know before the upgrade...) 


New Comment: 
By the way, I just noticed that the commitlog files were not replayed in the order of
their ids.<br/>It seems that they are sorted by "last modification date" before being
replayed, but this does not corresponds to their ids.<br/>Moreover, "last modification
date" is changed when a file is copied, so, this could also change the order of archived
commitlogs.I suppose the sort order of commit log files is for schemas ?Maybe it's safer
to sort them using the id in the file name ? 


New Comment: 
Committed with a warning in NEWS to drain.Go ahead and open a separate ticket to fix sort
order. 


New Comment: 
If drain is required between versions to avoid this issue then <a
href="https://issues.apache.org/jira/browse/CASSANDRA-4446" title="nodetool drain
sometimes doesn&#39;t mark commitlog fully flushed" class="issue-link"
data-issue-key="CASSANDRA-4446"><del>CASSANDRA-4446</del></a>, where drain sometimes
doesn't actually drain, seems to have become more significant. 


New Comment: 
<a href="https://issues.apache.org/jira/browse/CASSANDRA-4446" title="nodetool drain
sometimes doesn&#39;t mark commitlog fully flushed" class="issue-link"
data-issue-key="CASSANDRA-4446"><del>CASSANDRA-4446</del></a> does not happen to me any
more (so far) when restarting 1.1.6 into 1.1.6. I could observe <a
href="https://issues.apache.org/jira/browse/CASSANDRA-4446" title="nodetool drain
sometimes doesn&#39;t mark commitlog fully flushed" class="issue-link"
data-issue-key="CASSANDRA-4446"><del>CASSANDRA-4446</del></a> on upgrade from 1.1.3 to
1.1.6 though. 


New Comment: 
+1. I think the issue I had with data loss after node restart, actually had to do with
this bug. Thanks for the fix. 


New Comment: 
Hi,<br/>I know this is bug is fixed now, but I got  a loss of data in production with
several nodes in Cassandra 1.1.0 (java 6 + Red Hat)<br/>I've been told that NTP and
network issues occured, also the Cassandra servers have been restarted  probably due to
power outage.<br/>How can I identify that the loss of data are due to the bug described
here? Is it reproducible ?I can't decide to upgrade my servers in production without a
solid evidence...Thanks,Hervé 


New Comment: 
anyone can help ? how can I confirm I reproduced the bug ? <br/>something in the
logs?<br/>a specific cassandra-cli command ?Thanks in advance. 


New Comment: 
<a href="https://issues.apache.org/jira/secure/ViewProfile.jspa?name=htoulan"
class="user-hover" rel="htoulan">Hervé Toulan</a> :1) JIRA is not a support forum,
generally. You would get a better response from the #cassandra IRC channel on freenode or
the cassandra-user@ mailing list.2) Cassandra 1.1.0 is an extremely old and extremely
broken version. You should update to at least the final released version of the 1.1 line.
Much better would be (first 1.2.x and then) at least the most recent 2.0.x version.3) No
commit log replay bug, including this one, should be capable of losing data if you write
with a sufficient ConsistencyLevel and Replication Factor and repair regularly. 


