Pattern changes caused by commit: 23785c37360e04cead8a2f036f7ee79a4d6eaaab

From: Facade-0
To:   Facade-1

From: Flyweight-4
To:   Flyweight-3


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-5712.txt 

commit 23785c37360e04cead8a2f036f7ee79a4d6eaaab
Author: Jonathan Ellis <jbellis@apache.org>

    Optimize key count estimation when opening sstable on startup
    patch by Melvin Wang and jbellis; reviewed by slebresne for CASSANDRA-2988



==================================
 Issue CASSANDRA-2988 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-2988] Improve SSTableReader.load() when loading index files
-----------------

-----------------
Summary: Improve SSTableReader.load() when loading index files
-----------------

-----------------
Issue type: Improvement
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Wed, 3 Aug 2011 01:32:28 +0000
-----------------

-----------------
Resolved at: Fri, 23 Dec 2011 18:09:01 +0000
-----------------

-----------------
Assigned to: Michael Wu
-----------------

-----------------
Description: 
<ul>	<li>when we create BufferredRandomAccessFile, we pass skipCache=true. This hurts the
read performance because we always process the index files sequentially. Simple fix would
be set it to false.</li>	<li>multiple index files of a single column family can be loaded
in parallel. This buys a lot when you have multiple super large index files.</li>	<li>we
may also change how we buffer. By using BufferredRandomAccessFile, for every read, we need
bunch of checking like</li></ul><ul class="alternate" type="square">	<li>do we need to
rebuffer?</li>	<li>isEOF()?</li>	<li>assertions<br/>  These can be simplified to some
extent.  We can blindly buffer the index file by chunks and process the buffer until a key
lies across boundary of a chunk. Then we rebuffer and start from the beginning of the
partially read key. Conceptually, this is same as what BRAF does but w/o the overhead in
the read**() methods in BRAF.</li></ul> 

-----------------

-----------------
Comments: 

New Comment: 
<blockquote>when we create BufferredRandomAccessFile, we pass
skipCache=true</blockquote>right, the point of skipCache is to say "don't cache this data
because we're probably not using it soon, so don't treat it as more fresh than the hot
data you have already in the page cache." which totally applies to the index sampling both
after a restart and when opening a new streamed file.<blockquote>multiple index files of a
single column family can be loaded in parallel</blockquote>i think there's two scenarios:
initial server startup (probably want to parallelize) and loading a new, streamed sstable
(probably don't).<blockquote>we may also change how we buffer</blockquote>that sounds like
a great idea. 


New Comment: 
<blockquote>which totally applies to the index sampling both after a restart and when
opening a new streamed file.</blockquote>Does it? If you are using and warming the
keycache, then maybe you don't want the index to be warm, but in any other case, the index
should essentially be locked in ram. Also, the streaming case is no longer linked to
SSTableReader.load in trunk.<blockquote>loading a new, streamed sstable (probably
don't)</blockquote>Same comment as above: .load() isn't involved.EDIT: The disconnect may
be that Melvin is only suggesting disabling skipCache for r/w on the index file, not the
data file.<hr />Melvin: either way, you should post the numbers that you collected. 


New Comment: 
Some stats data from my experiments. The experiment is about an isolated node. I just
measure the time spent (in ms) in ColumnFamilyStore constructor where we call
SSTableReader.load(). We have one keyspace consisting of 3 column families. The total size
of index files are marked in the parenthesis.Two optimization was tried. I will upload the
patches shortly.<br/>1) load all the index file of a single column family in parallel
(abbr. as parallel in the following table)<br/>2) changed the way we buffer the file. Hard
to put into words, but it is clear to look at the patch for it. It can be considered as an
improved version of BRAF. (abbr. as modified bytebuffer in the follow table)Also these two
methods can be easily combined together because they are touching different classes.
(abbr. as combined in the following table)<br/>First line in each method (longer time) is
about not using the cache, second line is about using the cache.<div
class='table-wrap'><table class='confluenceTable'><tbody><tr><th
class='confluenceTh'>&nbsp;</th><td class='confluenceTd'>cf1(13.5G)</td><td
class='confluenceTd'>cf2(26.3G)</td><td class='confluenceTd'>cf3(8.5G)</td></tr><tr><th
class='confluenceTh'>current</th><td class='confluenceTd'>125380</td><td
class='confluenceTd'>235722</td><td class='confluenceTd'>79531</td></tr><tr><th
class='confluenceTh'>&nbsp;</th><td class='confluenceTd'>24399</td><td
class='confluenceTd'>	59494	</td><td class='confluenceTd'>31577</td></tr><tr><th
class='confluenceTh'>parallel   </th><td class='confluenceTd'>  94028</td><td
class='confluenceTd'>	153820</td><td class='confluenceTd'>	65966</td></tr><tr><th
class='confluenceTh'>&nbsp;</th><td class='confluenceTd'>15826</td><td
class='confluenceTd'>	16672</td><td class='confluenceTd'>	20773</td></tr><tr><th
class='confluenceTh'>modified bytebuffer</th><td class='confluenceTd'>   110476</td><td
class='confluenceTd'>	197089</td><td class='confluenceTd'>	71348</td></tr><tr><th
class='confluenceTh'>&nbsp;</th><td class='confluenceTd'>16455	</td><td
class='confluenceTd'>38496	</td><td class='confluenceTd'>19498</td></tr><tr><th
class='confluenceTh'>combined </th><td class='confluenceTd'>     88897</td><td
class='confluenceTd'>	146750</td><td class='confluenceTd'>	62344</td></tr><tr><th
class='confluenceTh'>&nbsp;</th><td class='confluenceTd'>9768	</td><td
class='confluenceTd'>10518	</td><td
class='confluenceTd'>12726</td></tr></tbody></table></div> 


New Comment: 
dough, it messed up my table. Anyway, the 3 columns of numbers correspond to cf1, cf2 and
cf3. 


New Comment: 
parallel loading index files 


New Comment: 
modified the way we use the buffer to read index files. 


New Comment: 
First of all I would like to point you to <a
href="http://wiki.apache.org/cassandra/CodeStyle" class="external-link"
rel="nofollow">http://wiki.apache.org/cassandra/CodeStyle</a>, please modify your code
according to conventions listed in there.According to c2988-modified-buffer.patch:<ul
class="alternate" type="square">	<li>please encapsulate your modifications because if you
compare how it was and how it is in your patch it's hard to undertand and just looks like
a mess, I would like to suggest moving those modifications to separate inner class
(IndexReader maybe?) and replace only RandomAccessReader initialization in the
SSTableReader.load(...) method...</li>	<li>let's add a test comparing
"getEstimatedRowSize().count();" and "SSTable.estimateRowsFromIndex(input);" just to be
sure it works correctly.</li></ul>Also I don't quiet understand logic behind "while
(buffer.remaining() &gt; 10) {" in SSTableReader.loadByteBuffer, let's avoid any
hardcoding or at least comment why you did that.I'm going to take a closer look at patch
for parallel index file loading after we will be done with index reader patch
(c2988-modified-buffer.patch). 


New Comment: 
<blockquote>First of all I would like to point you to <a
href="http://wiki.apache.org/cassandra/CodeStyle" class="external-link"
rel="nofollow">http://wiki.apache.org/cassandra/CodeStyle</a>, please modify your code
according to conventions listed in there.</blockquote>Sure. This boils down to where to
put the curly braces<blockquote>please encapsulate your modifications because if you
compare how it was and how it is in your patch it's hard to undertand and just looks like
a mess, I would like to suggest moving those modifications to separate inner class
(IndexReader maybe?) and replace only RandomAccessReader initialization in the
SSTableReader.load(...) method...</blockquote>This patch is about changing the most part
of the load() method. I am not clear how we could only change the initialization of
RandomAcessReader.<blockquote>Also I don't quiet understand logic behind "while
(buffer.remaining() &gt; 10) {" in SSTableReader.loadByteBuffer, let's avoid any
hardcoding or at least comment why you did that.</blockquote>Sorry for lacking comments. I
will add it. However, this is not a hard coding in the sense that, Short consists of 2
bytes and Long consists of 8 bytes, the sum is 10 bytes. It is just a quick checking if we
reach the end.<blockquote>I'm going to take a closer look at patch for parallel index file
loading after we will be done with index reader patch
(c2988-modified-buffer.patch).</blockquote>FYI, these two patches are completely
independent with each other. 


New Comment: 
<blockquote>Short consists of 2 bytes and Long consists of 8 bytes, the sum is 10
bytes</blockquote>IMO that's more obvious if you leave it as "2 + 8," or use the
DBConstants class. 


New Comment: 
<blockquote>This patch is about changing the most part of the load() method. I am not
clear how we could only change the initialization of RandomAcessReader.</blockquote>Why
can't we just leave SST.load() as is but instead make a separate class where that special
buffering will be done? If index read is sequential then just extend DataInputStream and
override read(...) methods that should do the trick.<blockquote>FYI, these two patches are
completely independent with each other.</blockquote>I know that and I already took a brief
look at it but lets go with review sequentially one-by-one. 


New Comment: 
I'll do the opposite of Pavel and start with the second. <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>v2 of parallel sstable opening attached. 
Better code reuse, and caps the thread pool at #cores to avoid too much contention. 


New Comment: 
I'd add that this makes a big difference with LeveledCompaction turned on, since that
creates <b>many</b> small sstables. 


New Comment: 
+1 


New Comment: 
committed; leaving open to address the i/o patch 


New Comment: 
Integrated in Cassandra #1119 (See <a href="https://builds.apache.org/job/Cassandra/1119/"
class="external-link"
rel="nofollow">https://builds.apache.org/job/Cassandra/1119/</a>)<br/>    parallelize
sstable open at server startup<br/>patch by Melvin Wang and jbellis; reviewed by
pyaskevich for <a href="https://issues.apache.org/jira/browse/CASSANDRA-2988"
title="Improve SSTableReader.load() when loading index files" class="issue-link"
data-issue-key="CASSANDRA-2988"><del>CASSANDRA-2988</del></a>jbellis : <a
href="http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&amp;view=rev&amp;rev=1173606"
class="external-link"
rel="nofollow">http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&amp;view=rev&amp;rev=1173606</a><br/>Files
:
<ul>	<li>/cassandra/trunk/CHANGES.txt</li>	<li>/cassandra/trunk/src/java/org/apache/cassandra/concurrent/DebuggableThreadPoolExecutor.java</li>	<li>/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java</li>	<li>/cassandra/trunk/src/java/org/apache/cassandra/io/sstable/SSTableReader.java</li></ul> 


New Comment: 
I'm ready to help with the buffer patch if Melvin can rebase. 


New Comment: 
<ul>	<li>rebased to trunk</li>	<li>try to make as few changes in load() as possible by
encapsulating the logic in another class</li></ul> 


New Comment: 
-cleaned patch attached reformatted and some typos fixed.Using histogram information for a
more accurate key count is a good idea.I don't see any substantial difference between the
IndexFileUtil and RandomAccessReader (aka BRAF) with skipCache=false.  In particular the
comment that "When we read from RandomAccessReader, data is copied one byte after another
out of the internal buffer" is incorrect; RAF uses System.arrayCopy for readFully, which
is the same thing ByteBuffer.get invokes in IFU. 


New Comment: 
ah, I was wrong about that comment. Looks like they are pretty much alike except one
place, where in RandomAccessFile.reBuffer(), it uses super.read to read whereas the patch
uses FileChannel to read. If java.io.RandomAccessFile.read performs same as
FileChannel.read, I will discard this patch. 


New Comment: 
v2 attached that makes the improvement to the key estimation, but falls back to the old
code if the stats component is missing.  (Besides improving backwards-compatibility this
makes it more robust; we've seen broken stats files and been able to say "just remove it
and restart.") 


New Comment: 
Melvin, can you review that patch?  (Verified that it still applies to 1.0 branch.) 


New Comment: 
+1 (on 2988-2-v2) with 2 nits:<ul>	<li>It's probably worth caching the value of
<tt>sstableMetadata.estimatedRowSize.count()</tt> to avoid the double computation most of
the time.</li>	<li>I think<div class="preformatted panel" style="border-width: 1px;"><div
class="preformattedContent panelContent"><pre>long current = buckets.get(i);if (current
&gt; 0)    sum += current;</pre></div></div>can be condensed to <tt>sum +=
buckets.get&#40;i);</tt> (given current can't be negative).</li></ul> 


New Comment: 
committed to 1.1 w/ Sylvain's improvements (and also a check on EH.isOverflowed) 


