Pattern changes caused by commit: f5b030a657c1263e0b15856991b239f9d3c15214

From: Abstract Factory-3
To:   Abstract Factory-2

From: Factory Method-3
To:   Factory Method-2

From: Mediator-2
To:   Mediator-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-3817.txt 

commit f5b030a657c1263e0b15856991b239f9d3c15214
Author: Jonathan Ellis <jbellis@apache.org>

    add assert that repair keys arrive in-order
    patch by jbellis; reviewed by stuhood for CASSANDRA-2316



==================================
 Issue CASSANDRA-2316 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-2316] NoSuchElement exception on node which is streaming a repair
-----------------

-----------------
Summary: NoSuchElement exception on node which is streaming a repair
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Sat, 12 Mar 2011 07:12:22 +0000
-----------------

-----------------
Resolved at: Mon, 18 Apr 2011 23:04:07 +0000
-----------------

-----------------
Assigned to: Jonathan Ellis
-----------------

-----------------
Description: 

Running latest SVN snapshot of 0.7.

When I ran a repair on a node, that node's neighbor
threw the following exception. Let me know what other info could be helpful.
<div
class="code panel" style="border-width: 1px;"><div class="codeContent panelContent"><pre
class="code-java"> INFO 23:43:44,358 Streaming to /10.251.166.15ERROR 23:50:21,321 Fatal
exception in thread <span
class="code-object">Thread</span>[CompactionExecutor:1,1,main]java.util.NoSuchElementException
       at com.google.common.collect.AbstractIterator.next(AbstractIterator.java:146)      
 at
org.apache.cassandra.service.AntiEntropyService$Validator.add(AntiEntropyService.java:366)
       at
org.apache.cassandra.db.CompactionManager.doValidationCompaction(CompactionManager.java:825)
       at org.apache.cassandra.db.CompactionManager.access$800(CompactionManager.java:56) 
      at org.apache.cassandra.db.CompactionManager$6.call(CompactionManager.java:358)     
  at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)        at
java.util.concurrent.FutureTask.run(FutureTask.java:166)        at
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)        at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)        at
java.lang.<span class="code-object">Thread</span>.run(<span
class="code-object">Thread</span>.java:636)</pre></div></div> 

-----------------

-----------------
Comments: 

New Comment: 
The loop in validator.add apparently assumes that <em>some</em> range will contain any
given row. But<ul class="alternate" type="square">	<li>ranges is supposed to be "invalid"
ranges not all ranges</li>	<li>comments in validator.add say it is called for each row in
the CF</li>	<li>so any rows that are not part of an "invalid" range will cause this
exception</li></ul>So either my superficial understanding of what "invalid" ranges are is
broken, or the comments are wrong, or I'm surprised we're not hitting this a lot more
frequently. 


New Comment: 
Looks like this dates back to 0.6. 


New Comment: 
"Invalid" ranges in the tree are ranges that need to be hashed. The idea was that the tree
could be persisted between repair sessions, and ranges would be invalidated as writes
arrived: then the validation compaction would only need to compact invalid ranges of the
tree.In the current implementation, the tree will only contain invalid ranges, since it is
being created from scratch for every repair. 


New Comment: 
I wonder if this is a keys-out-of-order problem? 


New Comment: 
Since we iterate over each key in the CF, order shouldn't actually matter should it? 


New Comment: 
Order matters, because there will be up to 2^16 invalid ranges. If keys arrive out of
order we will consume ranges that should have contained keys, possibly leading us to
consume all invalid ranges.Either way, an assert that keys are arriving in order would be
handy here. 


New Comment: 
proposed assert attached 


New Comment: 
+1 For the assert. 


