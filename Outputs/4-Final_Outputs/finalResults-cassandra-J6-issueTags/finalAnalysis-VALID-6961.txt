Pattern changes caused by commit: 2820f050db002d653e3e6474ea5351db198ac71b

From: Decorator-2
To:   Decorator-1

From: Flyweight-2
To:   Flyweight-1

From: Mediator-3
To:   Mediator-1

From: Strategy-0
To:   Strategy-1

From: Template Method-3
To:   Template Method-2


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-6961.txt 

commit 2820f050db002d653e3e6474ea5351db198ac71b
Author: Jonathan Ellis <jbellis@apache.org>

    skip tombstones during hint replay
    patch by Vijay; reviewed by jbellis for CASSANDRA-4320



==================================
 Issue CASSANDRA-4320 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-4320] Assertion error while delivering the hints.
-----------------

-----------------
Summary: Assertion error while delivering the hints.
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Fri, 8 Jun 2012 00:25:39 +0000
-----------------

-----------------
Resolved at: Fri, 15 Jun 2012 03:04:03 +0000
-----------------

-----------------
Assigned to: Vijay
-----------------

-----------------
Description: 

java.lang.AssertionError<br/>        at
org.apache.cassandra.db.HintedHandOffManager.deliverHintsToEndpointInternal(HintedHandOffManager.java:351)<br/>
       at
org.apache.cassandra.db.HintedHandOffManager.deliverHintsToEndpoint(HintedHandOffManager.java:269)<br/>
       at
org.apache.cassandra.db.HintedHandOffManager.access$400(HintedHandOffManager.java:88)<br/>
       at
org.apache.cassandra.db.HintedHandOffManager$4.runMayThrow(HintedHandOffManager.java:442)<br/>
       at org.apache.cassandra.utils.WrappedRunnable.run(WrappedRunnable.java:26)<br/>    
   at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)<br/>
       at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)<br/>      
 at java.lang.Thread.run(Thread.java:636)

Did some digging and looks like we just need to
skip the deleted columns.
 

-----------------

-----------------
Comments: 

New Comment: 
So...  I guess the deletion during one page, doesn't get purged by removeDeleted in the
next since it's happening in the same ms?What if we just increased the gcBefore in the
removeDeleted call to MAX_VALUE? 


New Comment: 
ahaaa that works too <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> Plz see the attached. Thanks! 


New Comment: 
Actually v2 wont work because RowMutation.hintFor we do <div class="code panel"
style="border-width: 1px;"><div class="codeContent panelContent"><pre
class="code-java">ttl = <span class="code-object">Math</span>.min(ttl,
cf.metadata().getGcGraceSeconds()); </pre></div></div>so v1 is still better. 


New Comment: 
I don't follow, using max_value means that if an ExpiringColumn has expired we will ignore
it, if it has not then we don't want to. 


New Comment: 
Sorry i should have been clear, because of CFS.removeDeletedSuper<div class="code panel"
style="border-width: 1px;"><div class="codeContent panelContent"><pre
class="code-java"><span class="code-keyword">if</span> (subColumn.getLocalDeletionTime()
&lt; gcBefore                    || cf.deletionInfo().isDeleted(c.name(),
subColumn.timestamp())                    || c.deletionInfo().isDeleted(subColumn))       
        {                    subIter.remove();                }</pre></div></div>Hence we
will remove everything and never replay any column if we set the max_value. Makes sense? 


