Pattern changes caused by commit: 7980429c52dded61e4e89eca16d0ea739d6626b1

From: Decorator-0
To:   Decorator-1

From: Flyweight-5
To:   Flyweight-4

From: Strategy-0
To:   Strategy-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-5328.txt 

commit 7980429c52dded61e4e89eca16d0ea739d6626b1
Author: Jonathan Ellis <jbellis@apache.org>

    "defragment" rows for name-based queries under STCS
    patch by jbellis; reviewed by slebresne for CASSANDRA-2503



==================================
 Issue CASSANDRA-2503 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-2503] Eagerly re-write data at read time ("superseding / defragmenting")
-----------------

-----------------
Summary: Eagerly re-write data at read time ("superseding / defragmenting")
-----------------

-----------------
Issue type: New Feature
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Tue, 19 Apr 2011 02:16:01 +0000
-----------------

-----------------
Resolved at: Wed, 23 Nov 2011 14:08:08 +0000
-----------------

-----------------
Assigned to: Jonathan Ellis
-----------------

-----------------
Description: 

Oncdsed. This basic approach would improve read performance considerably, but would cause
a lot of duplicate data to be written, and would make compaction's work more
necessary.

Augmenting the basic idea, if when we superseded data in a file we marked it
as superseded somehow, the next compaction that touched that file could remove the data.
Since our file format is immutable, the values that a particular sstable superseded could
be recorded in a component of that sstable. If we always supersede at the "block" level
(as defined by <a href="https://issues.apache.org/jira/browse/CASSANDRA-674" title="New
SSTable Format" class="issue-link"
data-issue-key="CASSANDRA-674"><del>CASSANDRA-674</del></a> or <a
href="https://issues.apache.org/jira/browse/CASSANDRA-47" title="SSTable compression"
class="issue-link" data-issue-key="CASSANDRA-47"><del>CASSANDRA-47</del></a>), then the
list of superseded blocks could be represented using a generation number and a bitmap of
block numbers. Since 2498 would already allow for sstables to be eliminated due to
timestamps, this information would probably only be used at compaction time (by loading
all superseding information in the system for the sstables that are being
compacted).

Initially described on <a
href="https://issues.apache.org/jira/secure/EditComment!default.jspa?id=12477095&amp;commentId=12920353"
class="external-link" rel="nofollow">1608</a>.
 

-----------------

-----------------
Comments: 

New Comment: 
Straightforward patch attached. 


New Comment: 
On the technical side:<ul>	<li>we probably should skip the commit log (by using
Table.apply(rm, false) directly).</li>	<li>what is the reason for limiting this to
SizeTieredCompaction?</li></ul>On the idea itself, I won't hide that I'm less than
enthusiastic. It feels to me like the wrong fix to the 'compaction is behind' problem.
This will be basically be triggered when compaction is behind, but is basically solving
the problem temporarily by adding more pressure on compaction. I'd really like it if we
could benchmark/evaluate this before adding it because I kind of fear there is scenario
where it will do more harm than help. 


New Comment: 
Good point on skipping the commitlog.The reason to limit to STC is that I don't think of
this as a band-aid for compaction-is-behind (although I suppose it accomplishes that as
well) so much as a limit on the worst-case behavior; even when STC is "fully" compacted
(i.e. not major compacted but there is nothing left for the bucketing to do) you can have
an arbitrary number of sstables contain columns for a given row.  Thus, I think using
min_compaction_threshold as the cutoff here makes a lot of sense. 


New Comment: 
v2 attached w/ commitlog optimization 


New Comment: 
+1 on the technical sideI'm still far from excited by this because I'm neither convinced
that this will be very useful (especially with the max timestamp optimization) nor that it
won't be counterproductive in some cases. But for the same reasons I'm not opposing it
either if others are more convinced. 


New Comment: 
It's a pretty simple piece of code, and it's trivially clear that if max timestamp makes
it unnecessary, then it's simply a no-op. <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 


New Comment: 
committed for 1.0.2, that gives us plenty of time to back it out if necessary 


New Comment: 
reopening for 1.1 since we reverted it out of 1.0.3 in <a
href="https://issues.apache.org/jira/browse/CASSANDRA-3491" title="Recursion bug in
CollationController" class="issue-link"
data-issue-key="CASSANDRA-3491"><del>CASSANDRA-3491</del></a> 


New Comment: 
v3 adds "boolean updateIndexes" to Table.apply; this is safe to turn off for the
defragment write, since we're updating w/ exactly the existing data, timestamp and
all.Also adds a check for <tt>cfs.getMinimumCompactionThreshold() &gt; 0</tt>. 


New Comment: 
Two small nits:<ul>	<li>I would prefer using <tt>sstablesIterated &gt;
cfs.getMinimumCompactionThreshold()</tt> rather than <tt>&gt;=</tt>. I guess I'm afraid
that this 'limit worst-case' would get trigger too often. Typically for minThreshold == 2,
hoisting as soon as we hit more than 1 sstable feels a bit too much. Again, I have no big
argument, it just feels a tad more reasonable with &gt;.</li>	<li>We probably should use
<tt>!CFS.isCompactionDisabled()</tt> instead of <tt>cfs.getMinimumCompactionThreshold()
&gt; 0</tt></li></ul>But those minor nits apart, patch lgtm. +1 with or without the
changes. 


New Comment: 
committed w/ both changes 


