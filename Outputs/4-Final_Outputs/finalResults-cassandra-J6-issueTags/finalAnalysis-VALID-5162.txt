Pattern changes caused by commit: 9494d31e294ddfad04cdc5a7c1d3ef0fb9aadd5d

From: Decorator-0
To:   Decorator-1

From: Flyweight-5
To:   Flyweight-4

From: Strategy-0
To:   Strategy-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-5162.txt 

commit 9494d31e294ddfad04cdc5a7c1d3ef0fb9aadd5d
Author: Jonathan Ellis <jbellis@apache.org>

    remove statements from connection's list, when closed manually
    patch by Rick Shaw; reviewed by Patricio Echague and jbellis for CASSANDRA-3244



==================================
 Issue CASSANDRA-3244 Description 
=======================================

Project: Cassandra
-----------------

-----------------
Title: [CASSANDRA-3244] JDBC CassandraConnection may lead to memory leak when used in a pool
-----------------

-----------------
Summary: JDBC CassandraConnection may lead to memory leak when used in a pool
-----------------

-----------------
Issue type: Improvement
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Fri, 23 Sep 2011 00:15:10 +0000
-----------------

-----------------
Resolved at: Wed, 5 Oct 2011 19:04:42 +0000
-----------------

-----------------
Assigned to: Rick Shaw
-----------------

-----------------
Description: 

I may be wrong here but I noticed that the implementations of
CassandraConnection#createStatement() and CassandraConnection#prepareStatement()
keep(cache) the created Statement/PrepareStatement internally in a List.

They list is
freed up only during CassandraConnection.close() which makes me think that, if the
connection object is used in a pool implementation, it will lead to a memory leak as it
will hold every single statement that is used to interact with the DB until the connection
gets closed. 
 

-----------------

-----------------
Comments: 

New Comment: 
what is the list used for? 


New Comment: 
The list just holds statement objects 


New Comment: 
It keeps them on a list because <tt>Statement</tt> structures are associated with the
creating <tt>Connection</tt>. Closing the <tt>Connection</tt> closes all
<tt>Statement</tt> items. <tt>Statement</tt>  structures are re-usable; you
<em>usually</em> only open one or maybe a few.  But it does keep track of all you create.
I don't see how that implies a memory leak? 


New Comment: 
Hi Rick. I browsed Spring source code, and I saw the JDBCTemplate creates a statement
every time a query is executed.This is a snippet of code:<div class="code panel"
style="border-width: 1px;"><div class="codeContent panelContent"><pre
class="code-java">	<span
class="code-comment">//-------------------------------------------------------------------------</span>	<span
class="code-comment">// Methods dealing with <span class="code-keyword">static</span> SQL
(java.sql.Statement)</span>	<span
class="code-comment">//-------------------------------------------------------------------------</span>	<span
class="code-keyword">public</span> &lt;T&gt; T execute(StatementCallback&lt;T&gt; action)
<span class="code-keyword">throws</span> DataAccessException {		Assert.notNull(action,
<span class="code-quote">"Callback object must not be <span
class="code-keyword">null</span>"</span>);		Connection con =
DataSourceUtils.getConnection(getDataSource());		Statement stmt = <span
class="code-keyword">null</span>;		<span class="code-keyword">try</span> {			Connection
conToUse = con;			<span class="code-keyword">if</span> (<span
class="code-keyword">this</span>.nativeJdbcExtractor != <span
class="code-keyword">null</span> &amp;&amp;					<span
class="code-keyword">this</span>.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements())
{				conToUse = <span
class="code-keyword">this</span>.nativeJdbcExtractor.getNativeConnection(con);			}			stmt
= conToUse.createStatement();   <span class="code-comment">// &lt;-------- here
---------</span>			applyStatementSettings(stmt);			Statement stmtToUse = stmt;			<span
class="code-keyword">if</span> (<span class="code-keyword">this</span>.nativeJdbcExtractor
!= <span class="code-keyword">null</span>) {				stmtToUse = <span
class="code-keyword">this</span>.nativeJdbcExtractor.getNativeStatement(stmt);			}			T
result = action.doInStatement(stmtToUse);			handleWarnings(stmt);			<span
class="code-keyword">return</span> result;		}</pre></div></div> 


New Comment: 
Creating a <tt>Statement</tt> every time you need one is unnecessary but not illegal. The
assumption is the <tt>Statement</tt> is closed when Spring is done, which should be just
fine. The problem is the list in <tt>Connection</tt> <em>should</em> be a list of open
<tt>Statements</tt>. The implication being that closing a <tt>Statement</tt> removes
itself from that list. Unfortunately this is not being done. The list is necessary. But it
needs to be maintained by <tt>Statement</tt> because only it knows when it is asked to
close.Thanks for catching this bug. I'll create a fix for this. 


New Comment: 
Rick, thanks for the patch.I think think it will lead to a leak. The statement cache needs
to be handled by the pool instead of by the driver itself.Pools like BoneCP do not close
the connection.Also DBCP doesn't either. See: <a
href="http://svn.apache.org/viewvc/commons/proper/dbcp/trunk/src/java/org/apache/commons/dbcp2/PoolableConnection.java?view=markup"
class="external-link"
rel="nofollow">http://svn.apache.org/viewvc/commons/proper/dbcp/trunk/src/java/org/apache/commons/dbcp2/PoolableConnection.java?view=markup</a>
Thoughts? 


New Comment: 
I think this driver  assumes its connection is not reusable by a pool. It maintains state
and JDBC currently has no interface methods to manage the notion of clearing and cleaning
up its state separate from closing the physical connection, just <tt>close()</tt>. It
needs to be done by cooperating <tt>protected</tt> methods. This will be fine if we
implement our own <tt>PooledConnection</tt> classes but is not really practical for
frameworks that want to wrap our <tt>Connection</tt> implementation. The drastic solution
is to give up maintaining state and therefor (at least in my opinion) breaking the best
effort contract to adhere to the spec where we can to make an external cooperating
framework function.Note that there is really no problem with not closing the connection if
the <tt>Statement</tt> is closed. It will just leave an empty list of statements. The
patch forces the <tt>Statement</tt> to clean up the list when it closes. But of course the
<em>potential</em> problem remains. This is all done because the spec says the statements
should be closed on premature close of the connection. There is a whole section in the
spec on how pools should be handled. The only approach I can think of is to split
<tt>CassanadraConnection</tt> in two and wrap the physical connection and keep state in
the wrapper. That (I think) is the approach of <tt>PooledConnection</tt> anyway. Do you
think this is urgent? Can it wait toll we implement our own JDBC compliant pooling
classes? 


New Comment: 
Appreciate your thorough analysis.The reason I brought it up is because I'm working on a
connection pool for Cassandra JDBC Driver based on the way Hector handles failover, load
balancing and retry mechanism. I also based the design in the way BoneCP works (although I
haven't implemented yet the statement cache, which is freed up when the connection is
released). 


New Comment: 
Rick, looking again at JDBCTemplate, I realized that Spring closes automatically the
Statement. And since you added a method to remove the statement from the connection once
the statement is closed, I think it should be ok for now. 


New Comment: 
<ul class="alternate" type="square">	<li>It would be cleaner to make the collection of
statements a Set, since ordering is not important and we do "random access" removes on
manual close()</li>	<li>using ConcurrentSkipListSet would allow both thread safety of
using a single Connection (with separate Statements) across multiple threads, as well as
obviate the need for cloning the statements before iterating over them</li></ul> 


New Comment: 
Good suggestion. Re-patched. 


New Comment: 
committed, minus the unused CS.compareTo method 


