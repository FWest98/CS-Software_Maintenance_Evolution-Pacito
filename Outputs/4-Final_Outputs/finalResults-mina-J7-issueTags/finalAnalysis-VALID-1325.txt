Pattern changes caused by commit: 7961a51e78830fcbad9ff2572b7934899b41d2df

From: Facade-7
To:   Facade-5


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-1325.txt 

commit 7961a51e78830fcbad9ff2572b7934899b41d2df
Author: Trustin Lee <trustin@apache.org>

    Fixed issue: DIRMINA-539 - NioDatagramConnector doesn't takes the TrafficClass value set to his DatagramSessionConfig
    * Made sure all datagram socket parameters are configured



==================================
 Issue DIRMINA-539 Description 
=======================================

Project: MINA
-----------------

-----------------
Title: [DIRMINA-539] NioDatagramConnector doesn't takes the TrafficClass value set to his DatagramSessionConfig 
-----------------

-----------------
Summary: NioDatagramConnector doesn't takes the TrafficClass value set to his DatagramSessionConfig 
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Resolved
-----------------

-----------------
Created at: Thu, 6 Mar 2008 14:03:22 +0000
-----------------

-----------------
Resolved at: Thu, 11 Sep 2014 05:48:07 +0000
-----------------

-----------------
Assigned to: Emmanuel LÃ©charny
-----------------

-----------------
Description: 

client sending datagrams without taking care to the trafficClas set in the config, so the
ToS byte is not set in the packet sent from client.

client code:
<div class="code panel"
style="border-width: 1px;"><div class="codeContent panelContent"><pre class="code-java"> 
NioDatagramAcceptor acceptor = <span class="code-keyword">new</span>
NioDatagramAcceptor();  DatagramSessionConfig dcfg =
((NioDatagramAcceptor)acceptor).getSessionConfig();  dcfg.setTrafficClass(tosByte); 
InetSocketAddress bindAddrPort  = <span class="code-keyword">new</span>
InetSocketAddress(originatingIP, port); 
acceptor.bind(bindAddrPort);</pre></div></div>
-&gt; connecting to another computer with
NioDatagramConnector.

for me it looks like in the newHandle method of
NioDatagramConnector is not cared about TrafficClass (like it is done in
NioDatagramAcceptor.open())

The server part with the accceptor is OK and the correct ToS
byte is set in the packet.<br/>(the same problem may be in the socket, i have to check
it)
 

-----------------

-----------------
Comments: 

New Comment: 
It should be fixed now.  Please let me know if it still doesn't work as you expected. 


New Comment: 
thx very much  for quick fix,<br/>unfortunately it takes me more time to go back to this
problem and verify why it does not work correctly.in the
DefaultDatagramSessionConfig<br/>are variables
<br/>GET_TRAFFIC_CLASS_AVAILABLE<br/>SET_TRAFFIC_CLASS_AVAILABLE<br/> both of them are
false, but only the GET_XXXX is setup according the current conditions.the SET_XXX is
never touched and therefore is not possible to set the traffic mask<br/>in
setTrafficClass() method in NioDatagramSessionConfig class since it is always false..Since
I do not understand completely the aim if your design and architecture of the lib, <br/>I
will ask you kindly to look on it and provide some fix... 


New Comment: 
I think that all those checks (can we set/get traffic class on a socket/datagram) is
totally useless. Either you can, or you can't, but in the second case, it simply does
nothing.Now, the current implementation is totally FU, because we do things like :   
public void setTrafficClass(int trafficClass) {<br/>        if
(DefaultDatagramSessionConfig.isSetTrafficClassAvailable()) {<br/>            try {<br/>  
             c.socket().setTrafficClass(trafficClass);<br/>                ...with :<br/> 
  public static boolean isSetTrafficClassAvailable() {        return
SET_TRAFFIC_CLASS_AVAILABLE;    }and, ultimately :    private static final boolean
SET_TRAFFIC_CLASS_AVAILABLE = false;<br/>                ^^^^<br/>This is a dead end : the
isSetTrafficClassAvailable() will always return false.Here is what I suggest : we simply
get rid of all those controls, and let the user set/get the traffic class at will. If the
underlaying network does not support it, well, it's fine, no harm. 


New Comment: 
What we can do is something like :boolean isSetTrafficClassAvailable(Socket socket) {<br/>
 try {    int tc = socket.getTrafficClass();    socket.setTrafficClass((~tc)&amp;0x001E); 
  boolean supported = (tc != socket.getTrafficClass());    socket.setTrafficClass(tc);   
return supported;  } catch (Exception e) {    return false;  }}but it seems a bit
overkilling... 


New Comment: 
what about this one ?boolean setTrafficClassIfAvailable(Socket socket) { <br/>  try {    
int tc = socket.getTrafficClass();     socket.setTrafficClass((~tc)&amp;0x001E);    
return (tc != socket.getTrafficClass());   } catch (Exception e) {     return false;   }
<br/>} does the job and informs the user if not done + no unnecessary tests like the
previous one which would have lead to something likeif
(isSetTrafficClassAvailable(mysocket)) {<br/>  // set traffic class<br/> ....;<br/>} 


New Comment: 
Well, itwon't work :<ul class="alternate" type="square">	<li>first, you don't pass a new
traffic class</li>	<li>second, I don't think that it's necessary anyway.</li></ul>The
contract is pretty clear :<br/>"As the underlying network implementation may ignore this 
value applications should consider it a hint.   "<a
href="http://java.sun.com/j2se/1.4.2/docs/api/java/net/Socket.html#setTrafficClass(int"
class="external-link"
rel="nofollow">http://java.sun.com/j2se/1.4.2/docs/api/java/net/Socket.html#setTrafficClass(int</a>)Let's
do simple things, and when it becomes complicated, just think twice before injected
convoluted code. 


New Comment: 
indeed, the example was just intended to highlight the unnecesseray redundant tests
happening with the use of a isSetTrafficClassAvailable(...) method.<a
href="http://java.sun.com/j2se/1.4.2/docs/api/java/net/Socket.html#getTrafficClass("
class="external-link"
rel="nofollow">http://java.sun.com/j2se/1.4.2/docs/api/java/net/Socket.html#getTrafficClass(</a>)<br/>also
states that "the underlying network implementation may ignore the traffic class or
type-of-service set using #setTrafficClass()" <br/>If any error throws an exception i just
wonder why the hell this code got so complicated ?ps : tried to search through mina jira
db but found nothing proving that it could fail silently 


New Comment: 
The question is : do we really need this method in 2.0 (ie, isSetTrafficClassAvailable).
The main problem is that we need an open socket in order to check that, and we have to set
the traffic class, and reset it, to be sure that it's possible. As the Traffic Class is
absolutely not guaranteed to be used by the underlying network layer, I think it's a lot
of effort for a small improvement.Now, this can be discussed. I understand that, from the
user POV, masking all this complexity is good, but when a user tries to manipulate such
advanced features, I think that it should be explicit. 


New Comment: 
Agree with Emmanuel, so much glue and troubles for masking few of the complexity of a such
advanced feature. 


New Comment: 
Postponed to 2.0.1 


