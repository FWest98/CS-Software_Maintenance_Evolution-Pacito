Pattern changes caused by commit: 6c7ad9c34415531d6bb1e27ed1b06fe7c93fb4a3

From: Facade-4
To:   Facade-5

From: Proxy-1
To:   Proxy-0


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-1658.txt 

commit 6c7ad9c34415531d6bb1e27ed1b06fe7c93fb4a3
Author: Emmanuel Lecharny <elecharny@apache.org>

    The fix I applied for DIRMINA-672 was not sufficient : we have to get out of the loop if the decode method returns false.



==================================
 Issue DIRMINA-672 Description 
=======================================

Project: MINA
-----------------

-----------------
Title: [DIRMINA-672] CumulativeProtocolDecoder/ DemuxingProtocolDecoder
-----------------

-----------------
Summary: CumulativeProtocolDecoder/ DemuxingProtocolDecoder
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Closed
-----------------

-----------------
Created at: Fri, 13 Mar 2009 18:26:51 +0000
-----------------

-----------------
Resolved at: Wed, 6 May 2009 12:14:28 +0000
-----------------

-----------------
Assigned to: Emmanuel LÃ©charny
-----------------

-----------------
Description: 

Excerpt from forum discussion at: <a
href="http://www.nabble.com/Potential-DemuxingProtocolDecoderBug-td22489974.html"
class="external-link"
rel="nofollow">http://www.nabble.com/Potential-DemuxingProtocolDecoderBug-td22489974.html</a>

I'm
using 2.0.0-M4.  Upon inspection of the source code, I can tell it's going to be a JDK /
OS independent issue.  Also upon inspection, I've discovered the bug is actually in the
CumulativeProtocolDecoder (starting @ line 125):

if
(!session.getTransportMetadata().hasFragmentation()) {<br/>      doDecode(session, in,
out);<br/>      return;<br/>}

This breaks the contract with the doDecode method as it is
only called once (the documentation says it should be called repeatedly until it returns
false).  The following changes makes my previous test case pass, but it's probably a
little simplistic.

if (!session.getTransportMetadata().hasFragmentation()) {<br/>     
while(in.hasRemaining() &amp;&amp; doDecode(session, in, out))
{             //Do nothing 
    }
      return;<br/>}

The code should probably make sure that if doDecode returns
true, some of the buffer was actually consumed (as the code for fragmented transports
does).  Also, it may make sense to provide another method (i.e.
finishNonFragmentedDecode(...)), for handling the remainder of the buffer after doDecode
returns false.

I see where the author was headed with this code.  Transports (such as
UDP) that don't support fragmentation probably don't jive with the concept of an
accumulating buffer (what do we do with the accumulation buffer if we drop a UDP packet?).
 It does however make perfect sense to use such transports with the concept of a
DemuxingProtocolDecoder.  Perhaps it would be better to refactor the
DemuxingProtocolDecoder so that it's not a subclass of CumulativeProtocolDecoder.  Create
a helper class that handles the fragment accumulation aspect. CumulativeProtocolDecoder
would always use said helper class (throwing an error if the protocol doesn't support
fragmentation), but DemuxingProtocolDecoder could opt to use it depending on the protocol
it encounters.
 

-----------------

-----------------
Comments: 

New Comment: 
Test case that shows how this issue impacts the DemuxingProtocolDecoder class. 


New Comment: 
It seems pretty obvious that there is a problem <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>I'm testing the test and patching the
code. Thanks ! 


New Comment: 
Ok, patch applied, test added.Thanks James !<a
href="http://svn.apache.org/viewvc?rev=756242&amp;view=rev" class="external-link"
rel="nofollow">http://svn.apache.org/viewvc?rev=756242&amp;view=rev</a> 


New Comment: 
Current patch will loop endlessly if it's a nonFragmented transport and doDecode never
fully consumes the buffer (i.e. it wants to discard the remainder of the buffer).Take the
"CrLfTerminatedCommandLineDecoder" example from the JavaDoc.  If you send it 
"Line1\r\nLine2\r\nLine3"  it will parse the first two lines and loop endlessly.  We
should check the result of doDecode to make sure it wants us to continue. The fragmented
transport code also checks to make sure that some of the buffer is consumed if doDecode
returns true (this would likely mean that the doDecode method had a bug, but we should
probably check for it and throw an exception) 


New Comment: 
Sorry, my bad. I moved the decode() method call out of the while just for clarity sake,
without adding a check to get out of the loop if it returns false. Probably did that too
late ...Fixed in <a href="http://svn.apache.org/viewvc?rev=756989&amp;view=rev"
class="external-link"
rel="nofollow">http://svn.apache.org/viewvc?rev=756989&amp;view=rev</a>PS: I would really
appreciate if you can also provide a test with the Crlf decoder, I'm a bit too lazy and
busy to add it myself <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/wink.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>Thanks ! 


