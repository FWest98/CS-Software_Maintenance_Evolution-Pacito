Pattern changes caused by commit: bba4ada3b774421afa0c8b7ccd02c796fa9ab8e2

From: Adapter-2
To:   Adapter-4

From: Facade-3
To:   Facade-7

From: Flyweight-4
To:   Flyweight-6


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-803.txt 

commit bba4ada3b774421afa0c8b7ccd02c796fa9ab8e2
Author: Trustin Lee <trustin@apache.org>

    Fixed issue: DIRMINA-367 (1.1 proxy example broken with svn revision: 522721)
    * Now uses closeOnFlush() instead of immediate close().



==================================
 Issue DIRMINA-367 Description 
=======================================

Project: MINA
-----------------

-----------------
Title: [DIRMINA-367] 1.1 proxy example broken with svn revision: 522721
-----------------

-----------------
Summary: 1.1 proxy example broken with svn revision: 522721
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Closed
-----------------

-----------------
Created at: Tue, 10 Apr 2007 18:52:19 +0000
-----------------

-----------------
Resolved at: Sun, 30 Sep 2007 11:47:30 +0000
-----------------

-----------------
Assigned to: Trustin Lee
-----------------

-----------------
Description: 

I just updated to the latest version of mina and my server app broke.  It is partially
based on the proxy example.  Looking back through the svn logs, things seem to break on
r522721.   I've confirmed this with the stock proxy example.

The proxy sometimes closes
sessions without writing results to the client.  Client gets back zero bytes.   My clients
have lots of HTTP like calls....quick in and out exchanges with the server.  

The line in
question is in:
core/src/main/java/org/apache/mina/transport/socket/nio/SocketIoProcessor.java

in the
doFlush() method the added line from that svn revision is:

if( key.isWritable() )   ~
line 426

breaks things.  If I comment it out, things work fine.  

Looking more closely
at the code I don't quite understand how the method is supposed to work.  My nio knowledge
is somewhat limited but.  

When the method is entered we do the following:

// Clear
OP_WRITE<br/>        SelectionKey key = session.getSelectionKey();<br/>       
key.interestOps( key.interestOps() &amp; ( ~SelectionKey.OP_WRITE ) );

We clear
OP_WRITE.

then in the for loop we do the:

if( key.isWritable() ) 

test.

How is it ever
supposed to report back as writable if we clear OP_WRITE.  Does it work sometimes now
because of a race condition with further writes on the socket?
 

-----------------

-----------------
Comments: 

New Comment: 
The additional check is added to fix <a
href="https://issues.apache.org/jira/browse/DIRMINA-362" title="Channel writes being made
without OP_WRITE selector ready" class="issue-link"
data-issue-key="DIRMINA-362"><del>DIRMINA-362</del></a>.  isWritable() ans isReadable() is
related with readyOps rather than with interestOps, so removing the flag from interestOps
won't change the return value of isWritable().I think there's possibility that data is not
written when the connection is closed from the server.  In the proxy example, the client
connection is closed immediately if the server connection is closed.  Any write requests
not yet flushed out to the channel can be swallowed.  Instead of closing the client
connection immediately after the server closes the connection, you could make sure all
data received from server is forwarded to the client thoroughly.You could also provide a
stripped down version of your code that reproduces the problem so I can test it. 


New Comment: 
Thanks.  I think you are right on the money.  There is a race condition <br/>in the
sessionClosed() call and any pending writes.  What is the best <br/>way to ensure the data
is written?  In messageReceived() I could get a <br/>WriteFuture from the write() call and
join on the write?  Will that <br/>inhibit concurrency within the server?  Is there a
better way? Thanks!Keith 


New Comment: 
I'm just now getting a chance to check performance of my proxy server.  With the fix from
r522721 and doing a WriteFuture.join() in messageReceived peformance isn't so good
compared to the non-proxy version.  If I undo the fix from r522721 and don't do the join
in messageRecieved() then performance is better.  Is there a better way to avoid the race
condition rather than doing the join in messageRecieved()?  Is there some way to instead
wait in close until all of the writes are flushed?  Though that seems like it would tricky
with race conditions also.Thanks!Keith 


