Pattern changes caused by commit: 30a0b5dee0b00b4037b1c95d116f7b45f4af624d

From: Adapter-4
To:   Adapter-2

From: Facade-3
To:   Facade-4

From: Proxy-0
To:   Proxy-1


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-903.txt 

commit 30a0b5dee0b00b4037b1c95d116f7b45f4af624d
Author: Trustin Lee <trustin@apache.org>

    Related issue: DIRMINA-144 (Traffic shaping filter)
    * More precise traffic control by adjusting MaxReadBufferSize as soon as possible.



==================================
 Issue DIRMINA-144 Description 
=======================================

Project: MINA
-----------------

-----------------
Title: [DIRMINA-144] Traffic shaping filter
-----------------

-----------------
Summary: Traffic shaping filter
-----------------

-----------------
Issue type: New Feature
-----------------

-----------------
Current status: Closed
-----------------

-----------------
Created at: Mon, 12 Dec 2005 03:03:09 +0000
-----------------

-----------------
Resolved at: Wed, 14 Nov 2007 05:40:06 +0000
-----------------

-----------------
Assigned to: Trustin Lee
-----------------

-----------------
Description: 

MINA now has basic support for suspending/resuming reads and writes on an IoSession for
all transport types. We should use this feature to implement a traffic shaping filter
which lets the user configure bandwidth limitations. Both globally and for individual
sessions. Here are some configuration options I can come to think of:
<ul>	<li>Globally
specify a maximum data rate for individual sessions (e.g. max 10 kb/s for all
sessions).</li>	<li>Specify a maximum data rate on a per session basis (e.g. max 1 Mb/s
for a particular session).</li>	<li>Specify a maximum upper limit on the bandwidth used by
all sessions in total (e.g. all sessions share a total of 10 Mb/s).</li>	<li>Configure
different traffic classes with different limits to allow for high/low priority traffic and
partition sessions into these priority classes.</li></ul>
I'm not sure how advanced it
would have to be so please share your thoughts. Maybe point 1 and 2 would suffice? I think
3 and 4 add a lot of complexity since they need some kind of scheduling algorithm to
provide fairness between sessions.
 

-----------------

-----------------
Comments: 

New Comment: 
If this filter goes too phat, then we could split it into more than one small filters.Plus
we need a way to limit the maximum number of unprocessed bytes, so too fast network
doesn't lead the codec implementation to throw OutOfMemoryError. 


New Comment: 
We need to find a way to provide one-stop solution for read/write throttling and traffic
shaping.... so let's fix this issue in 2.0.0-M1. 


New Comment: 
I've just added TrafficShapingFilter, which works on a per-session basis.  It seems to
work pretty well so far.I have no idea on how to implement global or per-service traffic
shaping yet.  Probably we could resolve it in other newly created issue. 


New Comment: 
You can test the throughput using the following sample application and netcat (UNIX nc)
command:public class TrafficShapingFilterTest {<br/>    public static void main(String[]
args) throws Exception {<br/>        ScheduledExecutorService executor =
Executors.newScheduledThreadPool(1);        SocketAcceptor acceptor = new
NioSocketAcceptor();<br/>        acceptor.getFilterChain().addLast(<br/>               
"traffic", <br/>                new TrafficShapingFilter(executor, 1024, 1024));<br/>     
  acceptor.setHandler(new IoHandlerAdapter() {<br/>            @Override<br/>           
public void messageReceived(IoSession session, Object message)<br/>                   
throws Exception {                session.write(((IoBuffer) message).duplicate());        
   }            @Override<br/>            public void sessionClosed(IoSession session) {  
             long currentTime = System.currentTimeMillis();               
System.out.println("elapsedTime: " + (currentTime - session.getCreationTime()));          
     System.out.println("readBytes: " + session.getReadBytes());               
System.out.println(                        "readThroughput: " + session.getReadBytes() *
1000 / (currentTime - session.getCreationTime()));               
System.out.println("writtenBytes: " + session.getWrittenBytes());               
System.out.println(                        "writeThroughput: " + session.getWrittenBytes()
* 1000 / (currentTime - session.getCreationTime()));            }        });<br/>       
acceptor.setLocalAddress(new InetSocketAddress(8080));<br/>        acceptor.bind();<br/>  
 }<br/>} 


New Comment: 
I think this looks great! How about somehow extracting the calculation of the suspendTime
values in messageReceived and messageSent into a separate class,
PerSessionTrafficShapingStrategy, to make the shaping strategy pluggable? Then we could
implement a PerFilterChainTrafficShapingStrategy or PerService...Strategy in the future
when we know how to do that. One could even chain strategies using a
CombinedTrafficShapingStrategy to combine global and per session shaping. WDYT? 


New Comment: 
Sounds like a great idea.  But I have no idea on how to implement traffic shaping for a
service or globally without sacrificing performance.  Any good idea? 


New Comment: 
Let me reopen it to address Niklas's idea. 


New Comment: 
Niklas, I thought about adding some extension point for TrafficShapingFilter like you
suggested, but I still don't have any idea on how to implement it.  Instead I thought
about just improving TrafficShapingFilter to support per-session, per-service and global
max throughput property so users won't need such an extension point, like
Read/WriteThrottleFilter does.  WDYT? 


New Comment: 
I think that would work too. Do you know how to do this without sacrificing performance?
Maybe we should just wait with per-service and global shaping? Open up a new issue for
those things and see whether people actually request it? I think the
Read/WriteThrottleFilters are what most users will need. To prevent OOMs. IMO
TrafficShapingFilter is much less important. 


New Comment: 
Good idea.  ReadThrottleFilter is already bleeding due to performance issue.  I think
IoEventQueueThrottle will be enough for 99% cases.  Let me mark it as resolved then. <img
class="emoticon" src="https://issues.apache.org/jira/images/icons/emoticons/smile.png"
height="16" width="16" align="absmiddle" alt="" border="0"/> 


