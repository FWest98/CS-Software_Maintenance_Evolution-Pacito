Pattern changes caused by commit: 9cf1bfdb9ba2ffa79733b57e824af93010e92488


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-232.txt 

commit 9cf1bfdb9ba2ffa79733b57e824af93010e92488
Author: Trustin Lee <trustin@apache.org>

    Fixed issue: DIRMINA-231 (SocketConnector thread leak)
    * PooledThreadModel now manages the instances of PooledThreadModels, and therefore the number of PooledThreadModel per service never exceeds 1.



==================================
 Issue DIRMINA-231 Description 
=======================================

Project: MINA
-----------------

-----------------
Title: [DIRMINA-231] SocketConnector thread leak
-----------------

-----------------
Summary: SocketConnector thread leak
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Closed
-----------------

-----------------
Created at: Mon, 31 Jul 2006 10:57:49 +0000
-----------------

-----------------
Resolved at: Wed, 9 Aug 2006 08:13:19 +0000
-----------------

-----------------
Assigned to: Trustin Lee
-----------------

-----------------
Description: 

A few new threads are created for new SocketConnectors when they attempt to connect to a
remote host. Two of these (AnonymousIoService-x-y) are not cleaned up which can eventually
lead to OutOfMemoryError or other strange behaviour. 

It can be avoided by reusing
SocketConnectors, but I don't think this should be necessary.  
 

-----------------

-----------------
Comments: 

New Comment: 
Attaching ConnectingTest which shows problem using VmPipes as well (adapted from <a
href="http://issues.apache.org/jira/secure/attachment/20356/ConnectionTest.java"
class="external-link"
rel="nofollow">http://issues.apache.org/jira/secure/attachment/20356/ConnectionTest.java</a>). 


New Comment: 
Warning - running attached ConnectionTest may bring your machine to its knees!The
PooledThreadModel which is used by the default configuration creates a new
ThreadPoolFilter which is what is creating these wayward threads. I don't think the
destroy method of this filter ever gets called. If the PooledThreadModel used a
ReferenceCountingIoFilter to wrap the ThreadPoolFilter before adding it to the chain then
would destroy be called? 


New Comment: 
You're right. destroy() won't be called unless the PooledThreadModel uses a
ReferenceCountingIoFilter to wrap the ThreadPoolFilter. Previously destroy() was called
automatically by MINA when a filter wasn't used anymore. This caused deadlock problems
with the ThreadPoolFilter (see <a href="https://issues.apache.org/jira/browse/DIRMINA-169"
title="Deadlock in ThreadPoolFilter" class="issue-link"
data-issue-key="DIRMINA-169"><del>DIRMINA-169</del></a>). Because of some other changes
made to the way filters work in MINA 0.9 (as compared to 0.8) init/destroy would be called
very often in some circumstances causing the deadlocks. You will either have to call
destroy() manually in your test after the session has been closed or create your own
ThreadModel which wraps the ThreadPoolFilter in a ReferenceCountingIoFilter.I suggest that
you either reuse the connector or at least make sure all the connectors you create use the
same thread model instance. What you get now is seperate thread pools for each connection.
Is that really what you want? 


New Comment: 
Thanks for the background info Niklas.  I noticed the problem in an app that was
originally using MINA 0.8, so that is probably how the error crept in (see <a
href="http://www.quickfixj.org/jira/browse/QFJ-34" class="external-link"
rel="nofollow">http://www.quickfixj.org/jira/browse/QFJ-34</a>). I guess my concern is
that the out of the box behaviour of the connector is for two new threads to be created
with no obvious way of shutting them down.  Actually, how do you shut them down if using
the PooledThreadModel?Thanks,<br/>Brad. 


New Comment: 
To shut them down you will have to call destory() on the
ThreadPoolFilter:session.getFilterChain().get(PooledThreadModel.class.getName()).destroy();or
you create your own ThreadModel which wraps the ThreadPoolFilter in a
ReferenceCountingIoFilter instance.If you weren't using a ThreadPoolFilter with MINA 0.8
and you want the same behaviour with MINA 0.9 you must specify the ThreadModel.MANUAL
thread model as you suggest in <a href="http://www.quickfixj.org/jira/browse/QFJ-34"
class="external-link" rel="nofollow">http://www.quickfixj.org/jira/browse/QFJ-34</a>.If
you use the default config each connection will get its own thread pool. The threads in
the pool (these are named AnonymousIoService-x-y by default) will by default be terminated
after 1 minute of inactivity. If the threads do hang around for more than 1 minute that
would be a bug. In QFJ-34 you state that the Anonymous... threads never die off so there
may very well be a bug here.Is there anyway you could refactor your code to use a single
shared connector? Or use a shared ThreadPoolFilter (use MANUAL and add your own
ThreadPoolFilter to each connectors filter chain)? I think this is more "in tune" with how
MINA is supposed to be used. 


New Comment: 
I did a test to see if threads are killed off after 1 minute or not. It seems that after
running your test for 1000 cycles some of the threads created are killed after being
inactive but there are some threads which don't. All of them seem to block on
BlockingQueue.waitForItem(). waitForItem() blocks indefinitely and will only be
interrupted when destroy() is called on the ThreadPoolFilter. I think we need to add a
method which takes a timeout as well. I'll take a look at it. Please note that even if
this is fixed your problem probably won't go away because of the default 1 minute timeout.
IMO, having seperate thread pools for each session defeats one of the purposes of using
MINA since you will end up with at least one thread (which should die within 1 minute of
inactivity) per connection. I don't think this is what we want MINA users to do. If you do
what I suggested and use a single connector or ThreadPoolFilter instance your problem will
go away. 


New Comment: 
Actually, I was wrong about the waitForItem() method. The way the
LeaderFollowersThreadPool (used by default) works is that there is always at least one
thread (the leader) alive. The keepAliveTime doesn't apply to this thread so destroy()
must be called to kill it. 


New Comment: 
Hi Niklas,Thanks for all that.  My apps that use MINA are still on 0.8.x but they do reuse
the socket connectors so they should be ok when we upgrade, and for quickfixj the problem
has been resolved by not using a thread pool filter.  So I don't have any current problems
- I just wanted to make sure the MINA crew were aware of the issue and it sounds like you
are <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>My only concern is that the default
configuration isn't consistent with how you want MINA to be used and is a bit of a trap
for beginners.  I'd suggest including a warning that using the default config implicitly
creates a thread pool for each instance along with your suggestions for proper use in the
javadoc and/or tutorial (or is it already there/planned for 1.x?).Thanks,<br/>Brad. 


New Comment: 
Please test with mina-core-0.9.5-SNAPSHOT.jar which fixes this issue, and close this issue
after you confirm the fix works. 


New Comment: 
Trustin, won't this fix potentially bring back the problems from <a
href="https://issues.apache.org/jira/browse/DIRMINA-169" title="Deadlock in
ThreadPoolFilter" class="issue-link"
data-issue-key="DIRMINA-169"><del>DIRMINA-169</del></a>? I don't think it's a good idea to
wrap the default ThreadPoolFilter in a ReferenceCountingIoFilter. 


New Comment: 
You're right.  I removed it as soon as I noticed it. <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 


