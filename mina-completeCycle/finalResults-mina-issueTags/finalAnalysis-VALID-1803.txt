Pattern changes caused by commit: 7b2707ebf121bb92cf84e52f9f4ff38d721fae64

From: Bridge-16
To:   Bridge-15


=========================
       NEW GIT LOG
=========================

This commit refers to file: VALID-1803.txt 

commit 7b2707ebf121bb92cf84e52f9f4ff38d721fae64
Author: Emmanuel Lecharny <elecharny@apache.org>

    o Changed an error message which was misleading
    o Removed the disposalFuture which is totally useless
    o When calling dispose, kill the executor by calling shutdownNow
    o Don't wait for the dispose() to be done, as we were waiting on our own thread to signal itself on terminaison : a dead eand !
    This is a fix for DIRMINA-755



==================================
 Issue DIRMINA-755 Description 
=======================================

Project: MINA
-----------------

-----------------
Title: [DIRMINA-755] IoConnectot.dispose blocks forever
-----------------

-----------------
Summary: IoConnectot.dispose blocks forever
-----------------

-----------------
Issue type: Bug
-----------------

-----------------
Current status: Closed
-----------------

-----------------
Created at: Wed, 13 Jan 2010 10:50:14 +0000
-----------------

-----------------
Resolved at: Sun, 17 Jan 2010 17:30:44 +0000
-----------------

-----------------
Assigned to: Unassigned
-----------------

-----------------
Description: 

(Extracted from the ML)

I recently switched from 2.0.0-M6 to 2.0.0-RC1 and now
discovered a<br/>problem with the IoConnector (I'm using the nio stuff)...

I'll try to
explain:

In case of network connection shutdown I try to clean up as good
as<br/>possible. I terminate tread pools, I close the session, and finally I try<br/>to
dispose the IoConnector. 

Here's a small code-snippet from my shutdown-code:
<hr
/>
CloseFuture closeFuture = ctsc.getSession().close(false);

                   
closeFuture.addListener(new<br/>IoFutureListener&lt;IoFuture&gt;() {

                    
   public void operationComplete(IoFuture future) 
{                           
ctsc.getFilterchainWorkerPool().shutdown();                           
System.out.println("managed session count="+ctsc.getConnector().getManagedSessionCount());
                           ctsc.getConnector().dispose();                        }
       
            });
<hr />
"ctsc" is a simple container which contains the session
(getSession) and<br/>the used connection (getConnector). First I try to close the session.
Then,<br/>if this operation is completed, I try to shutdown a thread pool and
finally<br/>dispose the connector. I read in the api doc, that this dispose call
may<br/>block in case of still open session related to this connector.

I tried to print
out the number of still open sessions. On the console I<br/>get: "managed session count=
0"<br/>But the next call, the dispose() call, blocks and prevents the
remaining<br/>threads from shutdown to get a clean application termination.

If I switch
from RC1 backt o M6, this works quite well. 

Am I doing something wrong? Has the behavior
changed? *little bit<br/>confused*
 

-----------------

-----------------
Comments: 

New Comment: 
Hi there,I now found time to build a small reproducer... (I hope attachments
are<br/>working properly in this mailinglist?!)It's a tiny maven project, containing a
echo-server and a simple client<br/>that just sends "Hello World" and exits. Run the
client&amp;server with MINA 2.0.0-M6 and you will see, the client<br/>terminates after
sending the message.<br/>Try the same with 2.0.0-RC1. The clients hangs in the
connector.dispose()<br/>call. I hope someone has to to look into  <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 


New Comment: 
Ok, I'm clearly able to reproduce the lock, and I think I can explain what's going on.In
your client, you close the session waiting for all the messages to be processed before the
closure. So far, so good.You get back a CloseFuture, and you associate a listener to it,
which get called immediately after the last message has been processed. In this listener,
you have this method :            public void operationComplete(IoFuture future) {        
       System.out.println("managed session count=" + connector.getManagedSessionCount()); 
              System.out.println("Disposing connector ...");               
connector.dispose();                System.out.println("Disposing connector ...
*finished*");            }The problem here is that this listener will be called in a
thread, and then the dispose() method will be called, using the very same thread. As the
dispose() will create internally a DisposalFuture, which waits until the internal 'ready'
flag is set to true by another thread, it will wait forever just because no thread will be
here to flip the flag to true.You can fix this by simply moving the dispose() out of the
listener :<br/>...<br/>        // Get the close future for this session<br/>       
CloseFuture closeFuture = cf.getSession().getCloseFuture();       
closeFuture.addListener((IoFutureListener&lt;?&gt;) new IoFutureListener&lt;IoFuture&gt;()
{            @Override<br/>            public void operationComplete(IoFuture future) {   
            System.out.println("managed session count=" +
connector.getManagedSessionCount());            }        });        // wait for session
close and then dispose the connector<br/>        System.out.println( "Closing the
session..." );<br/>        closeFuture.getSession().close(false);       
System.out.println( "Waiting for the session to be closed..." );<br/>       
closeFuture.awaitUninterruptibly();<br/>        System.out.println( "Session closed !!!"
);        System.out.println("Disposing connector ...");<br/>       
connector.dispose();<br/>        System.out.println("Disposing connector ...
<b>finished</b>");<br/>}FYI, I have also called the close() method after having grabbed
the CloseFuture and affected the listener to it.Just tell me if this fix your problem. 


New Comment: 
Thanks a lot. I will try it. But then my application behavior would be different. It will
then block until all things are cleaned up <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/sad.png" height="16" width="16"
align="absmiddle" alt="" border="0"/>As this is not really documented (or?): Is it
possible to throw an exception in that case? Or note it in the javadoc? I'm sure other's
will trying to do the same. For me it was clear that the rigth time to dispose the
connector is, when the session is closed. So the end of the listener was the ideal way. No
need to hang around and wait for the end of the session, as the listener will do the job.
But as I learned now, this isn't possible <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/sad.png" height="16" width="16"
align="absmiddle" alt="" border="0"/> <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/sad.png" height="16" width="16"
align="absmiddle" alt="" border="0"/> <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/sad.png" height="16" width="16"
align="absmiddle" alt="" border="0"/> 


New Comment: 
If you don't care about the pending messages, why don't you try a close(true) ? 


New Comment: 
I'm shutting down thread-pools which are related to the session. So they can only be
closed after the session is closed. That was the initial cause for using the CloseFuture. 


New Comment: 
Alex, using a ClosFuture in conjonction with a listener is plain fine. In fact, this is
the way to go.The problem is that it's not possible to call connector.dispose() in the
listener.I'm currently checking the dispose() code to try to understand why it can't exit
when there are no more active sessions on it. Sounds fishy to me at this point :/ 


New Comment: 
&gt; The problem is that it's not possible to call connector.dispose() in the listener.
That's the point I don't understand. With M6 ist was possible. Now it's not possible.
Either there was a major change that lead to the decision that connector.dispose() isn't
possible in the listener any more (that I could accept), or this is a bug, especially when
I read your next sentence:&gt; I'm currently checking the dispose() code to try to
understand why it can't exit when there are no more active sessions on it. Sounds fishy to
me at this point :/ 


New Comment: 
Alex, as you noted, the issue is still opened and marked as Bug <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>We may have introduced a regression
between MINA 2.0-M6 and RC1, I'm investigating it atm. 


New Comment: 
Regaring the call to dispose() in the listener, it's really a bad practice : a Connector
may be linked to more than one session, and considering the dispose() is working (well, it
should :/), all of the opened session will be brutally closed too.I really suggest you
dispose() outside of the listener.At the same time, I'm currently starting from 2.0.0-M6
code, applying each modification since this version up to 2.0.0-RC1 to see where the
regression has been introduced... Damn ! 


New Comment: 
Ok, it took me a hell of a time to understand what's going on.Basically, in 2.0-M6, the
dispose() called in the listener works because we wait until a timeout is reached. We use
a DEAD_LOCK_CHECK_INTERVAL delay (5 seconds) and we iterate until either the 'ready' flag
is swapped to true (it never happens) or until we have reached a timemout, which is set to
MAX_LONG in this very case.In M6, the code looks like : <br/>    long endTime =
System.currentTimeMillis() + timeoutMillis;<br/>    ...<br/>    if (endTime &lt;
System.currentTimeMillis()) {        return ready;    }When timeoutMillis == MAX_LONG,
it's easy to realize that we exit just because endTime is always &lt; 0 !I fixed this bug
in <a href="http://svn.apache.org/viewvc?view=revision&amp;revision=713708"
class="external-link"
rel="nofollow">http://svn.apache.org/viewvc?view=revision&amp;revision=713708</a> (14
months ago ...) and then in <a
href="http://svn.apache.org/viewvc?view=revision&amp;revision=781711"
class="external-link"
rel="nofollow">http://svn.apache.org/viewvc?view=revision&amp;revision=781711</a> (7
months ago) by adding these lines :+        if (endTime &lt; 0) {+            endTime =
Long.MAX_VALUE;+        }So now, the wait() never exists from the loop, thus the
hang...Now, we have to find a way to get out of this loop the normal way... 


