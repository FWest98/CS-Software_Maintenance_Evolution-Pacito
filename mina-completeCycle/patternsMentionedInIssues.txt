On issue key DIRMINA-231 the adapt pattern might have been discussed on the following comment: 
==============================
Attaching ConnectingTest which shows problem using VmPipes as well (adapted from <a
href="http://issues.apache.org/jira/secure/attachment/20356/ConnectionTest.java"
class="external-link"
rel="nofollow">http://issues.apache.org/jira/secure/attachment/20356/ConnectionTest.java</a>). 
==============================

On issue key DIRMINA-231 the chain pattern might have been discussed on the following comment: 
==============================
Warning - running attached ConnectionTest may bring your machine to its knees!The
PooledThreadModel which is used by the default configuration creates a new
ThreadPoolFilter which is what is creating these wayward threads. I don't think the
destroy method of this filter ever gets called. If the PooledThreadModel used a
ReferenceCountingIoFilter to wrap the ThreadPoolFilter before adding it to the chain then
would destroy be called? 
==============================

On issue key DIRMINA-231 the  state  pattern might have been discussed on the following comment: 
==============================
To shut them down you will have to call destory() on the
ThreadPoolFilter:session.getFilterChain().get(PooledThreadModel.class.getName()).destroy();or
you create your own ThreadModel which wraps the ThreadPoolFilter in a
ReferenceCountingIoFilter instance.If you weren't using a ThreadPoolFilter with MINA 0.8
and you want the same behaviour with MINA 0.9 you must specify the ThreadModel.MANUAL
thread model as you suggest in <a href="http://www.quickfixj.org/jira/browse/QFJ-34"
class="external-link" rel="nofollow">http://www.quickfixj.org/jira/browse/QFJ-34</a>.If
you use the default config each connection will get its own thread pool. The threads in
the pool (these are named AnonymousIoService-x-y by default) will by default be terminated
after 1 minute of inactivity. If the threads do hang around for more than 1 minute that
would be a bug. In QFJ-34 you state that the Anonymous... threads never die off so there
may very well be a bug here.Is there anyway you could refactor your code to use a single
shared connector? Or use a shared ThreadPoolFilter (use MANUAL and add your own
ThreadPoolFilter to each connectors filter chain)? I think this is more "in tune" with how
MINA is supposed to be used. 
==============================

On issue key DIRMINA-231 the chain pattern might have been discussed on the following comment: 
==============================
To shut them down you will have to call destory() on the
ThreadPoolFilter:session.getFilterChain().get(PooledThreadModel.class.getName()).destroy();or
you create your own ThreadModel which wraps the ThreadPoolFilter in a
ReferenceCountingIoFilter instance.If you weren't using a ThreadPoolFilter with MINA 0.8
and you want the same behaviour with MINA 0.9 you must specify the ThreadModel.MANUAL
thread model as you suggest in <a href="http://www.quickfixj.org/jira/browse/QFJ-34"
class="external-link" rel="nofollow">http://www.quickfixj.org/jira/browse/QFJ-34</a>.If
you use the default config each connection will get its own thread pool. The threads in
the pool (these are named AnonymousIoService-x-y by default) will by default be terminated
after 1 minute of inactivity. If the threads do hang around for more than 1 minute that
would be a bug. In QFJ-34 you state that the Anonymous... threads never die off so there
may very well be a bug here.Is there anyway you could refactor your code to use a single
shared connector? Or use a shared ThreadPoolFilter (use MANUAL and add your own
ThreadPoolFilter to each connectors filter chain)? I think this is more "in tune" with how
MINA is supposed to be used. 
==============================

On issue key DIRMINA-231 the Chain pattern might have been discussed on the following comment: 
==============================
To shut them down you will have to call destory() on the
ThreadPoolFilter:session.getFilterChain().get(PooledThreadModel.class.getName()).destroy();or
you create your own ThreadModel which wraps the ThreadPoolFilter in a
ReferenceCountingIoFilter instance.If you weren't using a ThreadPoolFilter with MINA 0.8
and you want the same behaviour with MINA 0.9 you must specify the ThreadModel.MANUAL
thread model as you suggest in <a href="http://www.quickfixj.org/jira/browse/QFJ-34"
class="external-link" rel="nofollow">http://www.quickfixj.org/jira/browse/QFJ-34</a>.If
you use the default config each connection will get its own thread pool. The threads in
the pool (these are named AnonymousIoService-x-y by default) will by default be terminated
after 1 minute of inactivity. If the threads do hang around for more than 1 minute that
would be a bug. In QFJ-34 you state that the Anonymous... threads never die off so there
may very well be a bug here.Is there anyway you could refactor your code to use a single
shared connector? Or use a shared ThreadPoolFilter (use MANUAL and add your own
ThreadPoolFilter to each connectors filter chain)? I think this is more "in tune" with how
MINA is supposed to be used. 
==============================

On issue key DIRMINA-209 the singleton pattern might have been discussed, namely here: 
==============================
SocketIoProcessor singleton causes performance wall under load 
==============================

On issue key DIRMINA-587 the proxy pattern might have been discussed, namely here: 
==============================
The proxy sample does not work - results in a NullPointerException 
==============================

On issue key DIRMINA-185 the decorator pattern might have been discussed on the following comment: 
==============================
I would like to see the IoFilterLCM go away.IoFilter's that want the current behavior can
implement ref'counting themselves (via a decorator or abstract superclass). 
==============================

On issue key DIRMINA-185 the decorator pattern might have been discussed on the following comment: 
==============================
I agree with Peter.  So, here's my idea:<ul>	<li>Remove IoFilter.init() and
IoFilter.destroy();</li>	<li>Create a new utility decorator class. say,
'IoFilterWithLifeCycle' (Please suggest better names), which</li>	<li>provides a protected
void init() and destroy().</li>	<li>implements other lifecycle methods in IoFilter so it
calls init() and destroy() properly.</li></ul>WDYT? 
==============================

On issue key DIRMINA-454 the mediate pattern might have been discussed on the following comment: 
==============================
Thank you very much for the patch and the inspiration.  The bug has been fixed.  I made
sure OOM is not thrown anymore and decoder continues to decode even after too long text
line.  Please confirm if the bug has been fixed and close this issue.One difference from
no-dos.patch is that OOM is not thrown immediately.  It keeps discarding incoming data
when client sends too long line, and throws an OOM error when EOL (line delimiter) is
encountered.  It was necessary behavior to make the decoder continue to work even after
encountering broken data.  ProtocolCodecFilter also has been improved to continue decoding
after an exception is thrown.  Please refer to the svn commit log for the detailed
information.  All these changes shouldn't affect existing applications. 
==============================

On issue key DIRMINA-184 the Chain pattern might have been discussed on the following comment: 
==============================
Peter, I have a few questions about your commit:1)<br/>At line 187 of
LeaderFollowerThreadPool:    //TODO this should be in the filter, inits on pre-add if we
have not been init'ed<br/>    public void onPreAdd( IoFilterChain parent, String name,
IoFilter.NextFilter nextFilter )<br/>        throws Exception<br/>    {<br/>        if(
leader == null )        {            init();        }    }Do we need this method?  I guess
this method is not invoked by anyone.2) If LeaderFollowerThreadPool and
ThreadPoolThreadPoolFilter provides exactly the same functionality with ThreadPoolFilter,
why don't we replace it?  ThreadPoolThreadPoolFilter could become a ThreadPoolFilter which
uses LeaderFollowerThreadPool by default, and the pool implementation could be changed if
a user specifies his or her favorite pool implementation.3) Can't we simply expose
ProcessEventRunnable to users and make ThreadPool.submit accept it instead of Object? 
==============================

On issue key DIRMINA-454 the mediate pattern might have been discussed on the following comment: 
==============================
Thank you very much for the patch and the inspiration.  The bug has been fixed.  I made
sure OOM is not thrown anymore and decoder continues to decode even after too long text
line.  Please confirm if the bug has been fixed and close this issue.One difference from
no-dos.patch is that OOM is not thrown immediately.  It keeps discarding incoming data
when client sends too long line, and throws an OOM error when EOL (line delimiter) is
encountered.  It was necessary behavior to make the decoder continue to work even after
encountering broken data.  ProtocolCodecFilter also has been improved to continue decoding
after an exception is thrown.  Please refer to the svn commit log for the detailed
information.  All these changes shouldn't affect existing applications. 
==============================

On issue key DIRMINA-162 the builder pattern might have been discussed on the following comment: 
==============================
I think you're right on the issue with sessions being opened / closed. Main thing is that
only the higher level protocol (on top of UDP) can really determine the meaning of
a<br/>'session' in its very own context. It might be possible to design some kind of
protocol filter which implements generic session tracking on top of simple message
delivery by:<ul class="alternate" type="square">	<li>tracking received message from the
remote peer and fire off a sessionOpened() event BEFORE passing the message onto the next
filter in the chain</li>	<li>implement a timeout-based mechanism that tracks the data
messages passing through and closes the session if the timeout passes by (including firing
the event)<br/>But it does not seem feasible to implement this as a generic behauviour of
the datagram acceptor (as there are protocol which do not have the concept of a session at
all)</li></ul>But I do think that it is a bug in the implementation of the datagram
acceptor if it does not assembly the filter chains when the individual session get create.
I understand that it is currently needed ot create a session per received message but it
should then assemble the filter chain per session as one should expect from the
documentation. It would then be <br/>necessary to document this as an user might need to
take special precautions in this chain builder implementation. 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
I think you're right on the issue with sessions being opened / closed. Main thing is that
only the higher level protocol (on top of UDP) can really determine the meaning of
a<br/>'session' in its very own context. It might be possible to design some kind of
protocol filter which implements generic session tracking on top of simple message
delivery by:<ul class="alternate" type="square">	<li>tracking received message from the
remote peer and fire off a sessionOpened() event BEFORE passing the message onto the next
filter in the chain</li>	<li>implement a timeout-based mechanism that tracks the data
messages passing through and closes the session if the timeout passes by (including firing
the event)<br/>But it does not seem feasible to implement this as a generic behauviour of
the datagram acceptor (as there are protocol which do not have the concept of a session at
all)</li></ul>But I do think that it is a bug in the implementation of the datagram
acceptor if it does not assembly the filter chains when the individual session get create.
I understand that it is currently needed ot create a session per received message but it
should then assemble the filter chain per session as one should expect from the
documentation. It would then be <br/>necessary to document this as an user might need to
take special precautions in this chain builder implementation. 
==============================

On issue key DIRMINA-162 the strategy pattern might have been discussed on the following comment: 
==============================
This is a great idea.  We could provide a generic session tracking strategy interface so
users can choose their favorite session management method.  For instance:/** A kind of
cache? */<br/>public interface ConnectionlessSessionTracker {<br/>    /**<ul>	<li>@return
null if no session is found<br/>     */<br/>    IoSession getSession( SocketAddress
localAddress, SocketAddress remoteAddress );<br/>}</li></ul>WDYT? 
==============================

On issue key DIRMINA-162 the facade pattern might have been discussed on the following comment: 
==============================
I already approached this but I found out that it will not work without a acceptor facade
which encapsulates the "real" datagram acceptor and does the session tarcking on behalf
of<br/>the client. This thing is in fact second-next on my to-do list for my current
project. <br/>Once this facade works, it can easily implement the proposed tracker
interface. If it works, I will supply my implementation as a diff to mina-0.9.0 
==============================

On issue key DIRMINA-162 the strategy pattern might have been discussed on the following comment: 
==============================
Here's my first stab at fixing this. Could somebody please review it? I haven't touched
the MINA code before just tonight <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>The attached diff is against svn revision
440993, the current trunk at this time.Basically, you can implement the methods	void
sessionCreated(IoSession session);<br/>	IoSession getSession(SocketAddress localAddress,
SocketAddress remoteAddress);in a ConnectionlessSessionTracker, and assign that to a
DatagramSessionConfig. From then on, the tracker will perform session management for the
transport.The only current problem is that the session cannot be retrieved until the
remote socket address is known. In DatagramChannel, this happen upon read, so the session
cannot be queried for its read buffer size. I think it should still be the same, but once
again, please review it.Here is also a testing version of a ConnectionlessSessionTracker
(don't use, it doesn't expire or do anything advanced enough):import
java.net.InetSocketAddress;<br/>import java.net.SocketAddress;<br/>import
java.util.HashMap;<br/>import java.util.Map;import
org.apache.mina.common.ConnectionlessSessionTracker;<br/>import
org.apache.mina.common.IoSession;public class TestSessionTracker implements
ConnectionlessSessionTracker<br/>{<br/>	private Map&lt;String, IoSession&gt; sessionMap =
new HashMap&lt;String, IoSession&gt;();	public IoSession getSession(SocketAddress
localAddress, SocketAddress remoteAddress)	{		InetSocketAddress localIsa =
(InetSocketAddress) localAddress;		InetSocketAddress remoteIsa = (InetSocketAddress)
remoteAddress;		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		return
sessionMap.get(key);	}	public void sessionCreated(IoSession
session)<br/>	{<br/>		InetSocketAddress localIsa = (InetSocketAddress)
session.getLocalAddress();<br/>		InetSocketAddress remoteIsa = (InetSocketAddress)
session.getRemoteAddress();		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		if
(!sessionMap.containsKey(key))		{			sessionMap.put(key, session);		}	}<br/>}I imagine that
by integrating iofilters that know of the session tracker, etc you could implement just
about any session management strategy.Let me know what you think! 
==============================

On issue key DIRMINA-162 the Builder pattern might have been discussed on the following comment: 
==============================
Here's my first stab at fixing this. Could somebody please review it? I haven't touched
the MINA code before just tonight <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>The attached diff is against svn revision
440993, the current trunk at this time.Basically, you can implement the methods	void
sessionCreated(IoSession session);<br/>	IoSession getSession(SocketAddress localAddress,
SocketAddress remoteAddress);in a ConnectionlessSessionTracker, and assign that to a
DatagramSessionConfig. From then on, the tracker will perform session management for the
transport.The only current problem is that the session cannot be retrieved until the
remote socket address is known. In DatagramChannel, this happen upon read, so the session
cannot be queried for its read buffer size. I think it should still be the same, but once
again, please review it.Here is also a testing version of a ConnectionlessSessionTracker
(don't use, it doesn't expire or do anything advanced enough):import
java.net.InetSocketAddress;<br/>import java.net.SocketAddress;<br/>import
java.util.HashMap;<br/>import java.util.Map;import
org.apache.mina.common.ConnectionlessSessionTracker;<br/>import
org.apache.mina.common.IoSession;public class TestSessionTracker implements
ConnectionlessSessionTracker<br/>{<br/>	private Map&lt;String, IoSession&gt; sessionMap =
new HashMap&lt;String, IoSession&gt;();	public IoSession getSession(SocketAddress
localAddress, SocketAddress remoteAddress)	{		InetSocketAddress localIsa =
(InetSocketAddress) localAddress;		InetSocketAddress remoteIsa = (InetSocketAddress)
remoteAddress;		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		return
sessionMap.get(key);	}	public void sessionCreated(IoSession
session)<br/>	{<br/>		InetSocketAddress localIsa = (InetSocketAddress)
session.getLocalAddress();<br/>		InetSocketAddress remoteIsa = (InetSocketAddress)
session.getRemoteAddress();		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		if
(!sessionMap.containsKey(key))		{			sessionMap.put(key, session);		}	}<br/>}I imagine that
by integrating iofilters that know of the session tracker, etc you could implement just
about any session management strategy.Let me know what you think! 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
Attached is the next version with IoSessionRecycler per Trustin's and my comments. I still
am not sure about the read buffer size issue (marked by a TODO in the code). Also, after
some thought I don't think this is applicable to transports with connections (seems like
too much abstraction, and doesn't fit well with the MINA session paradigm).I also added a
default implementation, ExpiringSessionRecycler, which uses an ExpiringMap to recycle
sessions. It also calls sessionClosed on the session's filterchain when a session
expires.I hope this helps! I definitely want to contribute something nice that will speed
MINA along to 1.0 <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>Let me know what you think! 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
Minor change to build filter chain only when a session isn't recycled (save some clocks
<img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
And, in an astounding extra $0.02, I also wanted to remind you to update the IoHandler
javadoc since it indicates that sessionOpened/etc will not be called for UDP. I'd also
like to put out there that sessionCreated could be called on the session's filter chain
when it is first created (before sessionOpened), this would make all MINA events
applicable to the UDP transport. I know it doesn't really mean anything different, but it
might be the least surprise to the user.And on that note, I'm going to go do something
else for a while so I don't think of anything else to spam the mailing list with updates
about <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
No problem, happy to lend a hand <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> MINA makes my work easier, so it's more
than a fair trade.I can get to patching the remaining stuff (IoHandler, defaulting to
ExpiringSessionRecycler) within the next couple of days or so. I agree that
ExpiringSessionRecycler should be the default now that I think about all the events flying
around the filter chain with NOOP, and starting the expiration after the first put is a
good compromise. Nice to have util-concurrent for that, since a double check lock is
actually thread-safe with ReentrantReadWriteLock.Do you want me to add an IdentityHashMap
for session lookup? It would mean extra synchronization, and it would affect only the
'remove(IoSession)' method AFAIK. Are the costs to generate the key high enough to justify
that? 
==============================

On issue key DIRMINA-162 the  state  pattern might have been discussed on the following comment: 
==============================
Yargh. In this one (v7), I do the lock upgrade correctly in the startExpiringIfNotStarted
method of ExpiringMap. Sorry 'bout that. Somebody may want to refactor that state locking
code to some common class, cause it would minimize the chances to create bugs like that
<img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-432 the Composite pattern might have been discussed on the following comment: 
==============================
I'd prefer MessageBroadcaster.  And users will want to know which peer failed to receive
the broadcast message, so we need to return something different
like....<ul>	<li>Map&lt;IoSession, WriteFuture&gt; or</li>	<li>CompositeIoFuture (new
interface) that can combine any IoFutures (e.g. ConnectFuture + WriteFuture).</li></ul> 
==============================

On issue key DIRMINA-27 the  state  pattern might have been discussed on the following comment: 
==============================
Yes as a matter of fact the latest Mina OSGi work is still on the apacheDS. You will find
three projects in sandbox/jconlon/osgi-mina.   These projects are for the Mina 1.1.  The
first of these projects is mina-integration-osgi this is a wrapping bundle for mina. The
second mina-osgi-example is a OSGi version of the Chat example.  The third
mina-osgi-example-integration-test is a Spring-OSGi based testing framework for the second
project.I have not moved them to my Mina sandbox or said much about them because many of
the third party dependencies Enrique and I built for OSGi enabling ADS are in the process
of moving to the OSGi felix commons area.  Additionally the Spring-OSGi efforts are in a
state of flux so the testing framework is not very stable nor is it available from stable
maven repos.However the main osgi bundling of mina 1.1 (mina-integration-osgi) should
build for you as it does me right now. The other two projects are a bit more bold in their
use of third party snapshots and thus are more shakey as they require sets of pre-built
dependencies that you won't likely have.  Time will fructify these dependencies and we
should have something provided by third parties soon.Would you like me to create a OSGi
wrapper project for the latest trunk? 
==============================

On issue key DIRMINA-415 the Proxy pattern might have been discussed, namely here: 
==============================
Proxy support 
==============================

On issue key DIRMINA-415 the Proxy pattern might have been discussed on the following comment: 
==============================
Niklas wrote:Now, one thing we should consider is whether we want to
support<br/>specifying proxyHost, proxyPort via system properties, just like
Socket<br/>does. In that case I don't think it will be as simple as wrapping
like<br/>suggested above. Maybe we could support this by having some kind of<br/>factory
which looks at the system properties?Lóránt Pintér wrote:However, I'd vote for supporting
proxyHost and such, because there are a<br/>lot of legacy systems out there moving to
MINA. When they finally<br/>migrate to MINA, their users don't really want to know about
the change,<br/>and don't expect changes in the configuration of the system.I think all of
these systems will then create something like<br/>LegacyProxyConnector inherited from
ProxyingConnector, and set the proxy<br/>parameters from proxyHost etc. As I think a lot
of people would<br/>implement this redundantly, MINA could have it out of the box as well. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Niklas wrote:Now, one thing we should consider is whether we want to
support<br/>specifying proxyHost, proxyPort via system properties, just like
Socket<br/>does. In that case I don't think it will be as simple as wrapping
like<br/>suggested above. Maybe we could support this by having some kind of<br/>factory
which looks at the system properties?Lóránt Pintér wrote:However, I'd vote for supporting
proxyHost and such, because there are a<br/>lot of legacy systems out there moving to
MINA. When they finally<br/>migrate to MINA, their users don't really want to know about
the change,<br/>and don't expect changes in the configuration of the system.I think all of
these systems will then create something like<br/>LegacyProxyConnector inherited from
ProxyingConnector, and set the proxy<br/>parameters from proxyHost etc. As I think a lot
of people would<br/>implement this redundantly, MINA could have it out of the box as well. 
==============================

On issue key DIRMINA-415 the factory pattern might have been discussed on the following comment: 
==============================
Niklas wrote:Now, one thing we should consider is whether we want to
support<br/>specifying proxyHost, proxyPort via system properties, just like
Socket<br/>does. In that case I don't think it will be as simple as wrapping
like<br/>suggested above. Maybe we could support this by having some kind of<br/>factory
which looks at the system properties?Lóránt Pintér wrote:However, I'd vote for supporting
proxyHost and such, because there are a<br/>lot of legacy systems out there moving to
MINA. When they finally<br/>migrate to MINA, their users don't really want to know about
the change,<br/>and don't expect changes in the configuration of the system.I think all of
these systems will then create something like<br/>LegacyProxyConnector inherited from
ProxyingConnector, and set the proxy<br/>parameters from proxyHost etc. As I think a lot
of people would<br/>implement this redundantly, MINA could have it out of the box as well. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
First cut of proxy connector. Supports unauthenticated proxies and proxies with Basic
authentication.Still quite messy - needs some refactoring to work with IoC containers
properly.Tested with MINA 1.1. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Based on James work i hacked around and achieved working NTLM &amp; socks 4 &amp; 4a proxy
support<br/>But it still needs a lot of work : code cleaning, API reworking, socks 5 &amp;
digest support<br/>i'll keep sending infos on  progress made 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Due to personal events i've made less progress than expected.<br/>But Socks5 support is
now added and digest auth is currently in progress.<br/>Code still needs lot of workThe
problem is that it is hard to test the code as i have no dedicated network to test it. For
example, i've been unable to find a free proxy supporting Socks5 with GSSAPI
auth.<br/>Generally speaking i've been forced to use many different proxies because each
of them has a unique combination of auth methods.<br/>So i may need help on this, if some
of you could test the proxy program within their network it would help debbuging.Regarding
a previous comment on IOC containers, i've no idea on how to make code IoC friendly : i'll
accept any clue on this ;pAnother important point is that the code contains some basic
objects (HttpHeader, HttpResponse etc...) that i think should be refactored to use
AsyncWeb (not sure this is the official MINA http project ?) code<br/>WDYT ?That's all for
the moment<br/>Any comments or help is appreciated. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Hi community,This is a great day (althought i spent 3 hours in the strike this morning
<img class="emoticon" src="https://issues.apache.org/jira/images/icons/emoticons/sad.png"
height="16" width="16" align="absmiddle" alt="" border="0"/> ...) <br/>as i'm proud to
announce after 4 months of work that <br/>i'm releasing a proxy support connector for MINA
2.0-M1.This release features :HTTP proxy : <ul class="alternate"
type="square">	<li>Support for NTLM authentication</li>	<li>Support for Digest
authentication</li>	<li>Transparent support for reconnection to a http proxy that does not
support connection keep alive</li>	<li>Support for HTTP/1.1 requests</li>	<li>Support for
multi valued headers</li>	<li>Configuration of prefered authentication
mechanism</li>	<li>Smart proxy authentication system that dynamically and automatically
selects the mechanism to use</li></ul>SOCKS :<ul class="alternate"
type="square">	<li>Support for SOCKS4 and SOCKS4a</li>	<li>Support for SOCKS5 with support
for GSSAPI authentication via Kerberos V</li></ul>Moreover i added some test classes and
junit testcases to test internals and <br/>cover most of the revelant functionnalities.I
hope this work will be usefull for the community as i put great efforts on it<br/>I'm
really excited by looking forward for your questions, comments, etc...Regards,<ul
class="alternate" type="square">	<li>Edouard De Oliveira -<br/><a
href="http://tedorg.free.fr/en/projects.php" class="external-link"
rel="nofollow">http://tedorg.free.fr/en/projects.php</a></li></ul> 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Source code updated to comply with MINA 2.0.0-M2 version.<br/>Some minor refactorings were
madeAdded a telnet test client : tested it by communicating with a SMTP server through a
http &amp; socks proxy. 
==============================

On issue key DIRMINA-415 the Proxy pattern might have been discussed, namely here: 
==============================
Proxy support 
==============================

On issue key DIRMINA-415 the Proxy pattern might have been discussed on the following comment: 
==============================
Niklas wrote:Now, one thing we should consider is whether we want to
support<br/>specifying proxyHost, proxyPort via system properties, just like
Socket<br/>does. In that case I don't think it will be as simple as wrapping
like<br/>suggested above. Maybe we could support this by having some kind of<br/>factory
which looks at the system properties?Lóránt Pintér wrote:However, I'd vote for supporting
proxyHost and such, because there are a<br/>lot of legacy systems out there moving to
MINA. When they finally<br/>migrate to MINA, their users don't really want to know about
the change,<br/>and don't expect changes in the configuration of the system.I think all of
these systems will then create something like<br/>LegacyProxyConnector inherited from
ProxyingConnector, and set the proxy<br/>parameters from proxyHost etc. As I think a lot
of people would<br/>implement this redundantly, MINA could have it out of the box as well. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Niklas wrote:Now, one thing we should consider is whether we want to
support<br/>specifying proxyHost, proxyPort via system properties, just like
Socket<br/>does. In that case I don't think it will be as simple as wrapping
like<br/>suggested above. Maybe we could support this by having some kind of<br/>factory
which looks at the system properties?Lóránt Pintér wrote:However, I'd vote for supporting
proxyHost and such, because there are a<br/>lot of legacy systems out there moving to
MINA. When they finally<br/>migrate to MINA, their users don't really want to know about
the change,<br/>and don't expect changes in the configuration of the system.I think all of
these systems will then create something like<br/>LegacyProxyConnector inherited from
ProxyingConnector, and set the proxy<br/>parameters from proxyHost etc. As I think a lot
of people would<br/>implement this redundantly, MINA could have it out of the box as well. 
==============================

On issue key DIRMINA-415 the factory pattern might have been discussed on the following comment: 
==============================
Niklas wrote:Now, one thing we should consider is whether we want to
support<br/>specifying proxyHost, proxyPort via system properties, just like
Socket<br/>does. In that case I don't think it will be as simple as wrapping
like<br/>suggested above. Maybe we could support this by having some kind of<br/>factory
which looks at the system properties?Lóránt Pintér wrote:However, I'd vote for supporting
proxyHost and such, because there are a<br/>lot of legacy systems out there moving to
MINA. When they finally<br/>migrate to MINA, their users don't really want to know about
the change,<br/>and don't expect changes in the configuration of the system.I think all of
these systems will then create something like<br/>LegacyProxyConnector inherited from
ProxyingConnector, and set the proxy<br/>parameters from proxyHost etc. As I think a lot
of people would<br/>implement this redundantly, MINA could have it out of the box as well. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
First cut of proxy connector. Supports unauthenticated proxies and proxies with Basic
authentication.Still quite messy - needs some refactoring to work with IoC containers
properly.Tested with MINA 1.1. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Based on James work i hacked around and achieved working NTLM &amp; socks 4 &amp; 4a proxy
support<br/>But it still needs a lot of work : code cleaning, API reworking, socks 5 &amp;
digest support<br/>i'll keep sending infos on  progress made 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Due to personal events i've made less progress than expected.<br/>But Socks5 support is
now added and digest auth is currently in progress.<br/>Code still needs lot of workThe
problem is that it is hard to test the code as i have no dedicated network to test it. For
example, i've been unable to find a free proxy supporting Socks5 with GSSAPI
auth.<br/>Generally speaking i've been forced to use many different proxies because each
of them has a unique combination of auth methods.<br/>So i may need help on this, if some
of you could test the proxy program within their network it would help debbuging.Regarding
a previous comment on IOC containers, i've no idea on how to make code IoC friendly : i'll
accept any clue on this ;pAnother important point is that the code contains some basic
objects (HttpHeader, HttpResponse etc...) that i think should be refactored to use
AsyncWeb (not sure this is the official MINA http project ?) code<br/>WDYT ?That's all for
the moment<br/>Any comments or help is appreciated. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Hi community,This is a great day (althought i spent 3 hours in the strike this morning
<img class="emoticon" src="https://issues.apache.org/jira/images/icons/emoticons/sad.png"
height="16" width="16" align="absmiddle" alt="" border="0"/> ...) <br/>as i'm proud to
announce after 4 months of work that <br/>i'm releasing a proxy support connector for MINA
2.0-M1.This release features :HTTP proxy : <ul class="alternate"
type="square">	<li>Support for NTLM authentication</li>	<li>Support for Digest
authentication</li>	<li>Transparent support for reconnection to a http proxy that does not
support connection keep alive</li>	<li>Support for HTTP/1.1 requests</li>	<li>Support for
multi valued headers</li>	<li>Configuration of prefered authentication
mechanism</li>	<li>Smart proxy authentication system that dynamically and automatically
selects the mechanism to use</li></ul>SOCKS :<ul class="alternate"
type="square">	<li>Support for SOCKS4 and SOCKS4a</li>	<li>Support for SOCKS5 with support
for GSSAPI authentication via Kerberos V</li></ul>Moreover i added some test classes and
junit testcases to test internals and <br/>cover most of the revelant functionnalities.I
hope this work will be usefull for the community as i put great efforts on it<br/>I'm
really excited by looking forward for your questions, comments, etc...Regards,<ul
class="alternate" type="square">	<li>Edouard De Oliveira -<br/><a
href="http://tedorg.free.fr/en/projects.php" class="external-link"
rel="nofollow">http://tedorg.free.fr/en/projects.php</a></li></ul> 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Source code updated to comply with MINA 2.0.0-M2 version.<br/>Some minor refactorings were
madeAdded a telnet test client : tested it by communicating with a SMTP server through a
http &amp; socks proxy. 
==============================

On issue key DIRMINA-495 the singleton pattern might have been discussed on the following comment: 
==============================
This is a better version.  It accepts Map&lt;?, ?&gt; rather than Map&lt;Object,Object&gt;
so the user can do Collections.singletonMap() without having to cast or qualify it. 
==============================

On issue key DIRMINA-495 the Proxy pattern might have been discussed on the following comment: 
==============================
I ran into a similar situation some time ago though I wanted to do more with the session
than add attributes. First I thought I could just use an IoFutureListener and access the
new session there. I soon realized that this wouldn't work since I needed my
IoFutureListener to be called before sessionCreate() on my IoHandler. There's no way to
guarantee that that happens in this order with MINA 1.x.I ended up with something
likeconnector.connect(address, new IoHandlerProxy(realIoHandler) {<br/>    public void
sessionCreated(IoSession session) {        // Do whatever it was I needed to do with the
session here        super.sessionCreated(session);    }}IoHandlerProxy is a simple custom
class which let's me intercept calls to the real IoHandler. I think you get the point.My
point here is that there may be other things than adding attributes one might want to do
before sessionCreated() is called. If connect() would take a ConnectCallback as an
argument the user could do whatever she wants before the IoHandler is called, not just add
attributes.ConnectCallback would be very similar to IoFutureListener so maybe we could use
that and connect() would automatically set the IoFutureListener on the ConnectFuture. In
that way it is guaranteed that the listener is called before the IoHandler is called.With
this it would be simple to add attributes to the session:connector.connect(add, new
IoFutureListener&lt;ConnectFuture&gt;() {<br/>    void operationComplete(ConnectFuture
future) {<br/>        if (future.isConnected()) {           
future.getSession().addAttribute(...);        }   }<br/>});We could still also add a
connect(addr, Map) method to IoConnector but it would be implemented like the above.WDYT? 
==============================

On issue key DIRMINA-495 the mediate pattern might have been discussed on the following comment: 
==============================
That seems reasonable - with a general callback you could cleanly add attributes.  BUT
we'd have to ensure that the callback is called <del>immediately</del> after the session
is created.  The regular ConnectFuture callback doesn't happen until the connect completes
- which is too late <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>So maybe a new "SessionFuture" type is
called for?Also the callback method should be allowed to throw exceptions.You could then
do this (which would meet the requirements of this issue):connector.connect(addr, new
IoFutureListener&lt;SessionFuture&gt;() {<br/>    void operationComplete(SessionFuture
future) {        future.getSession.setAttribute(MY_KEY, myVal);    }} 
==============================

On issue key DIRMINA-495 the chain pattern might have been discussed on the following comment: 
==============================
Works for me.  As long as it's definitely called before the sessionCreated() filter
chain/handler method <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-405 the mediate pattern might have been discussed, namely here: 
==============================
IoSession.suspendRead() doesn't suspend read operation immediately when
ProtocolCodecFilter is used. 
==============================

On issue key DIRMINA-546 the Adapter pattern might have been discussed on the following comment: 
==============================
The following test method:    @Test<br/>    public void mina() throws Exception {<br/>    
   SocketAcceptor acceptor = new NioSocketAcceptor();<br/>        acceptor.setHandler(new
IoHandlerAdapter());<br/>        acceptor.setDefaultLocalAddress(new
InetSocketAddress(8080));<br/>        acceptor.bind();        long start =
System.currentTimeMillis();<br/>        for (int i = 0; i &lt; 10000; i ++) {           
new Socket("127.0.0.1", 8080).close();        }        long end =
System.currentTimeMillis();<br/>        System.out.println(end - start);<br/>    }prints
out the following result:Before optimization - 38412<br/>After optimization 11212 
==============================

On issue key DIRMINA-439 the Factory pattern might have been discussed, namely here: 
==============================
DemuxingProtocolEncoder and DemuxingProtocolDecoder by refactoring
DemuxingProtocolCodecFactory 
==============================

On issue key DIRMINA-463 the Factory pattern might have been discussed on the following comment: 
==============================
1) Just checked in a fix for this. There are now MINA specific versions of
StateMachineFactory.<br/>2) Fixed!I'm not sure I like how 1) turned out. There are lots of
code duplication there. Maybe if we changed StateMachineFactory so that it isn't all
static like now and to obtain one you would always have to specifiy the annotations to be
used like so:StateMachineFactory.getInstance(IoHandlerTransition.class).create(...)We need
a way to couple IoHandlerTransition and IoHandlerTransitions together. I think we can use
a special annotation for that:@TransitionsCombiner(IoHandlerTransitions.class)<br/>public
interface @IoHandlerTransition {<br/>...<br/>}That way you won't have to specifiy both
IoHandlerTransition and IoHandlerTransitions in the call to getInstance(...).WDYT? 
==============================

On issue key DIRMINA-463 the Factory pattern might have been discussed on the following comment: 
==============================
&gt; We need a way to couple IoHandlerTransition and IoHandlerTransitions together. I
think we can use a special annotation for that:<br/>&gt;<br/>&gt;
@TransitionsCombiner(IoHandlerTransitions.class)<br/>&gt; public interface
@IoHandlerTransition {&gt; ...&gt; } Does this mean we apply the same technique to
IoFilterTransition(s) and Transition(s)?  Then it sounds great to me.  Probably we could
allow user to specify either annotation
class:StateMachineFactory.getInstance(IoHandlerTransition.class).create(...) =
StateMachineFactory.getInstance(IoHandlerTransitions.class).create(...)Does it make a
sense? 
==============================

On issue key DIRMINA-162 the builder pattern might have been discussed on the following comment: 
==============================
I think you're right on the issue with sessions being opened / closed. Main thing is that
only the higher level protocol (on top of UDP) can really determine the meaning of
a<br/>'session' in its very own context. It might be possible to design some kind of
protocol filter which implements generic session tracking on top of simple message
delivery by:<ul class="alternate" type="square">	<li>tracking received message from the
remote peer and fire off a sessionOpened() event BEFORE passing the message onto the next
filter in the chain</li>	<li>implement a timeout-based mechanism that tracks the data
messages passing through and closes the session if the timeout passes by (including firing
the event)<br/>But it does not seem feasible to implement this as a generic behauviour of
the datagram acceptor (as there are protocol which do not have the concept of a session at
all)</li></ul>But I do think that it is a bug in the implementation of the datagram
acceptor if it does not assembly the filter chains when the individual session get create.
I understand that it is currently needed ot create a session per received message but it
should then assemble the filter chain per session as one should expect from the
documentation. It would then be <br/>necessary to document this as an user might need to
take special precautions in this chain builder implementation. 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
I think you're right on the issue with sessions being opened / closed. Main thing is that
only the higher level protocol (on top of UDP) can really determine the meaning of
a<br/>'session' in its very own context. It might be possible to design some kind of
protocol filter which implements generic session tracking on top of simple message
delivery by:<ul class="alternate" type="square">	<li>tracking received message from the
remote peer and fire off a sessionOpened() event BEFORE passing the message onto the next
filter in the chain</li>	<li>implement a timeout-based mechanism that tracks the data
messages passing through and closes the session if the timeout passes by (including firing
the event)<br/>But it does not seem feasible to implement this as a generic behauviour of
the datagram acceptor (as there are protocol which do not have the concept of a session at
all)</li></ul>But I do think that it is a bug in the implementation of the datagram
acceptor if it does not assembly the filter chains when the individual session get create.
I understand that it is currently needed ot create a session per received message but it
should then assemble the filter chain per session as one should expect from the
documentation. It would then be <br/>necessary to document this as an user might need to
take special precautions in this chain builder implementation. 
==============================

On issue key DIRMINA-162 the strategy pattern might have been discussed on the following comment: 
==============================
This is a great idea.  We could provide a generic session tracking strategy interface so
users can choose their favorite session management method.  For instance:/** A kind of
cache? */<br/>public interface ConnectionlessSessionTracker {<br/>    /**<ul>	<li>@return
null if no session is found<br/>     */<br/>    IoSession getSession( SocketAddress
localAddress, SocketAddress remoteAddress );<br/>}</li></ul>WDYT? 
==============================

On issue key DIRMINA-162 the facade pattern might have been discussed on the following comment: 
==============================
I already approached this but I found out that it will not work without a acceptor facade
which encapsulates the "real" datagram acceptor and does the session tarcking on behalf
of<br/>the client. This thing is in fact second-next on my to-do list for my current
project. <br/>Once this facade works, it can easily implement the proposed tracker
interface. If it works, I will supply my implementation as a diff to mina-0.9.0 
==============================

On issue key DIRMINA-162 the strategy pattern might have been discussed on the following comment: 
==============================
Here's my first stab at fixing this. Could somebody please review it? I haven't touched
the MINA code before just tonight <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>The attached diff is against svn revision
440993, the current trunk at this time.Basically, you can implement the methods	void
sessionCreated(IoSession session);<br/>	IoSession getSession(SocketAddress localAddress,
SocketAddress remoteAddress);in a ConnectionlessSessionTracker, and assign that to a
DatagramSessionConfig. From then on, the tracker will perform session management for the
transport.The only current problem is that the session cannot be retrieved until the
remote socket address is known. In DatagramChannel, this happen upon read, so the session
cannot be queried for its read buffer size. I think it should still be the same, but once
again, please review it.Here is also a testing version of a ConnectionlessSessionTracker
(don't use, it doesn't expire or do anything advanced enough):import
java.net.InetSocketAddress;<br/>import java.net.SocketAddress;<br/>import
java.util.HashMap;<br/>import java.util.Map;import
org.apache.mina.common.ConnectionlessSessionTracker;<br/>import
org.apache.mina.common.IoSession;public class TestSessionTracker implements
ConnectionlessSessionTracker<br/>{<br/>	private Map&lt;String, IoSession&gt; sessionMap =
new HashMap&lt;String, IoSession&gt;();	public IoSession getSession(SocketAddress
localAddress, SocketAddress remoteAddress)	{		InetSocketAddress localIsa =
(InetSocketAddress) localAddress;		InetSocketAddress remoteIsa = (InetSocketAddress)
remoteAddress;		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		return
sessionMap.get(key);	}	public void sessionCreated(IoSession
session)<br/>	{<br/>		InetSocketAddress localIsa = (InetSocketAddress)
session.getLocalAddress();<br/>		InetSocketAddress remoteIsa = (InetSocketAddress)
session.getRemoteAddress();		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		if
(!sessionMap.containsKey(key))		{			sessionMap.put(key, session);		}	}<br/>}I imagine that
by integrating iofilters that know of the session tracker, etc you could implement just
about any session management strategy.Let me know what you think! 
==============================

On issue key DIRMINA-162 the Builder pattern might have been discussed on the following comment: 
==============================
Here's my first stab at fixing this. Could somebody please review it? I haven't touched
the MINA code before just tonight <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>The attached diff is against svn revision
440993, the current trunk at this time.Basically, you can implement the methods	void
sessionCreated(IoSession session);<br/>	IoSession getSession(SocketAddress localAddress,
SocketAddress remoteAddress);in a ConnectionlessSessionTracker, and assign that to a
DatagramSessionConfig. From then on, the tracker will perform session management for the
transport.The only current problem is that the session cannot be retrieved until the
remote socket address is known. In DatagramChannel, this happen upon read, so the session
cannot be queried for its read buffer size. I think it should still be the same, but once
again, please review it.Here is also a testing version of a ConnectionlessSessionTracker
(don't use, it doesn't expire or do anything advanced enough):import
java.net.InetSocketAddress;<br/>import java.net.SocketAddress;<br/>import
java.util.HashMap;<br/>import java.util.Map;import
org.apache.mina.common.ConnectionlessSessionTracker;<br/>import
org.apache.mina.common.IoSession;public class TestSessionTracker implements
ConnectionlessSessionTracker<br/>{<br/>	private Map&lt;String, IoSession&gt; sessionMap =
new HashMap&lt;String, IoSession&gt;();	public IoSession getSession(SocketAddress
localAddress, SocketAddress remoteAddress)	{		InetSocketAddress localIsa =
(InetSocketAddress) localAddress;		InetSocketAddress remoteIsa = (InetSocketAddress)
remoteAddress;		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		return
sessionMap.get(key);	}	public void sessionCreated(IoSession
session)<br/>	{<br/>		InetSocketAddress localIsa = (InetSocketAddress)
session.getLocalAddress();<br/>		InetSocketAddress remoteIsa = (InetSocketAddress)
session.getRemoteAddress();		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		if
(!sessionMap.containsKey(key))		{			sessionMap.put(key, session);		}	}<br/>}I imagine that
by integrating iofilters that know of the session tracker, etc you could implement just
about any session management strategy.Let me know what you think! 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
Attached is the next version with IoSessionRecycler per Trustin's and my comments. I still
am not sure about the read buffer size issue (marked by a TODO in the code). Also, after
some thought I don't think this is applicable to transports with connections (seems like
too much abstraction, and doesn't fit well with the MINA session paradigm).I also added a
default implementation, ExpiringSessionRecycler, which uses an ExpiringMap to recycle
sessions. It also calls sessionClosed on the session's filterchain when a session
expires.I hope this helps! I definitely want to contribute something nice that will speed
MINA along to 1.0 <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>Let me know what you think! 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
Minor change to build filter chain only when a session isn't recycled (save some clocks
<img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
And, in an astounding extra $0.02, I also wanted to remind you to update the IoHandler
javadoc since it indicates that sessionOpened/etc will not be called for UDP. I'd also
like to put out there that sessionCreated could be called on the session's filter chain
when it is first created (before sessionOpened), this would make all MINA events
applicable to the UDP transport. I know it doesn't really mean anything different, but it
might be the least surprise to the user.And on that note, I'm going to go do something
else for a while so I don't think of anything else to spam the mailing list with updates
about <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
No problem, happy to lend a hand <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> MINA makes my work easier, so it's more
than a fair trade.I can get to patching the remaining stuff (IoHandler, defaulting to
ExpiringSessionRecycler) within the next couple of days or so. I agree that
ExpiringSessionRecycler should be the default now that I think about all the events flying
around the filter chain with NOOP, and starting the expiration after the first put is a
good compromise. Nice to have util-concurrent for that, since a double check lock is
actually thread-safe with ReentrantReadWriteLock.Do you want me to add an IdentityHashMap
for session lookup? It would mean extra synchronization, and it would affect only the
'remove(IoSession)' method AFAIK. Are the costs to generate the key high enough to justify
that? 
==============================

On issue key DIRMINA-162 the  state  pattern might have been discussed on the following comment: 
==============================
Yargh. In this one (v7), I do the lock upgrade correctly in the startExpiringIfNotStarted
method of ExpiringMap. Sorry 'bout that. Somebody may want to refactor that state locking
code to some common class, cause it would minimize the chances to create bugs like that
<img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-176 the  state  pattern might have been discussed on the following comment: 
==============================
I'd like time out for ByteBuffers too, it is all we need.To implement application
specified strategies of pooling there will be the JMX support <a
href="https://issues.apache.org/jira/browse/DIRMINA-29" title="JMX integration"
class="issue-link" data-issue-key="DIRMINA-29"><del>DIRMINA-29</del></a>.<br/>With the JMX
we could monitor and manage the pool state for user-defined strategies. 
==============================

On issue key DIRMINA-176 the strategy pattern might have been discussed on the following comment: 
==============================
Retaining smaller buffers can also cause a problem depending on an application's memory
usage characterstics.  What about providing both strategy at the same time? 
==============================

On issue key DIRMINA-176 the command pattern might have been discussed on the following comment: 
==============================
Yes, but, by the pool point of view, what is regarded as a smaller buffer and a bigger
buffer? Supposing to have an application that uses 30 byte buffers and occasionally some
2kb buffers (this is the case of one of the ones I'm working on now), the pool would have
serious problems to understand which ones are "smaller" and "bigger", since all of them
are of the smallest or biggest size available.In this case not to cache smallest and
biggest buffer is a problem, and to limit the maximum size would certainly not be an
improvement.But many low-level byte protocols use short fixed lenght packets for "command"
messages and use long variable lenght packets for "transport" messages, so my case is a
common case.I think what you're suggesting is very good for protocols which use many
different-sized buffers, and should therefore be implemented, but we should also let users
chose whether to use it or not.In the overload control, we should also think about
interrupting  the work when the memory limit of the pool is exceeded, in order to permit
the application to flush and release the buffers that haven't been written yet. 
==============================

On issue key DIRMINA-176 the factory pattern might have been discussed on the following comment: 
==============================
This jakarta api seems to be the right solution, we can do a GenericObjectPool for each
buffer size, at the same way we mantain multiple stacks now.<br/>This api provides the
timeout we thought, it provides also the method that block if the objects are not
available (in case we are over the maximum size of the pool, and we cannot allocate other
buffers).<br/>We have to define better some things, but it looks great to me.One thing is
the following: in this jakarta pool the new objects are provided by a factory that
allocate all the objects equals. So for each partition we will be obliged to allocate only
one kind of buffer, the higher size buffer of the partition, right? I'm not so good with
english, so I hope I have well explained my doubt. 
==============================

On issue key DIRMINA-187 the Factory pattern might have been discussed on the following comment: 
==============================
This solution looks a little bit complicated IMHO.  What do you think about this:interface
IoHandlerFactory<br/>{<br/>    IoHandler getHandler( IoSession session );<br/>}interface
IoAcceptor<br/>{<br/>    void bind( SocketAddress address, IoHandler handler ); // one
handler handles multiple sessions<br/>    void bind( SocketAddress address,
IoHandlerFactory handlerFactory ); // multiple handler handler multiple sessions<br/>   
void bind( SocketAddress address, Class&lt;IoHandler&gt; handlerClass ); // multiple
handler multiple sessions, handlerClass is instantiated whenever a new session is
created.<br/>}&lt;usage 1&gt;class MyHandlerFactory implements IoHandlerFactory<br/>{<br/>
   IoHandler getHandler( IoSession session )    {        return new MyHandler();  //
MyHandler implements IoHandler    }}acceptor.bind( ..., new MyHandlerFactory() );&lt;usage
2&gt;<br/>acceptor.bind(..., MyHandler.class);This will seamlessly integrate per-session
handlers retaining backward compatibility. 
==============================

On issue key DIRMINA-187 the Factory pattern might have been discussed on the following comment: 
==============================
The third option that takes a class should be an IoHandlerFactory that the project
supplies, not a separate method. 
==============================

On issue key DIRMINA-187 the Adapter pattern might have been discussed on the following comment: 
==============================
I'm a bit confused about the following code inside SingleSessionIoHandlerAdapter class:   
public void sessionClosed() throws Exception     {        SessionUtil.initialize(
getSession() );    }Shouldn't this code be placed inside the sessionCreated() method? 
==============================

On issue key DIRMINA-755 the mediate pattern might have been discussed on the following comment: 
==============================
Ok, I'm clearly able to reproduce the lock, and I think I can explain what's going on.In
your client, you close the session waiting for all the messages to be processed before the
closure. So far, so good.You get back a CloseFuture, and you associate a listener to it,
which get called immediately after the last message has been processed. In this listener,
you have this method :            public void operationComplete(IoFuture future) {        
       System.out.println("managed session count=" + connector.getManagedSessionCount()); 
              System.out.println("Disposing connector ...");               
connector.dispose();                System.out.println("Disposing connector ...
*finished*");            }The problem here is that this listener will be called in a
thread, and then the dispose() method will be called, using the very same thread. As the
dispose() will create internally a DisposalFuture, which waits until the internal 'ready'
flag is set to true by another thread, it will wait forever just because no thread will be
here to flip the flag to true.You can fix this by simply moving the dispose() out of the
listener :<br/>...<br/>        // Get the close future for this session<br/>       
CloseFuture closeFuture = cf.getSession().getCloseFuture();       
closeFuture.addListener((IoFutureListener&lt;?&gt;) new IoFutureListener&lt;IoFuture&gt;()
{            @Override<br/>            public void operationComplete(IoFuture future) {   
            System.out.println("managed session count=" +
connector.getManagedSessionCount());            }        });        // wait for session
close and then dispose the connector<br/>        System.out.println( "Closing the
session..." );<br/>        closeFuture.getSession().close(false);       
System.out.println( "Waiting for the session to be closed..." );<br/>       
closeFuture.awaitUninterruptibly();<br/>        System.out.println( "Session closed !!!"
);        System.out.println("Disposing connector ...");<br/>       
connector.dispose();<br/>        System.out.println("Disposing connector ...
<b>finished</b>");<br/>}FYI, I have also called the close() method after having grabbed
the CloseFuture and affected the listener to it.Just tell me if this fix your problem. 
==============================

On issue key DIRMINA-755 the iterate pattern might have been discussed on the following comment: 
==============================
Ok, it took me a hell of a time to understand what's going on.Basically, in 2.0-M6, the
dispose() called in the listener works because we wait until a timeout is reached. We use
a DEAD_LOCK_CHECK_INTERVAL delay (5 seconds) and we iterate until either the 'ready' flag
is swapped to true (it never happens) or until we have reached a timemout, which is set to
MAX_LONG in this very case.In M6, the code looks like : <br/>    long endTime =
System.currentTimeMillis() + timeoutMillis;<br/>    ...<br/>    if (endTime &lt;
System.currentTimeMillis()) {        return ready;    }When timeoutMillis == MAX_LONG,
it's easy to realize that we exit just because endTime is always &lt; 0 !I fixed this bug
in <a href="http://svn.apache.org/viewvc?view=revision&amp;revision=713708"
class="external-link"
rel="nofollow">http://svn.apache.org/viewvc?view=revision&amp;revision=713708</a> (14
months ago ...) and then in <a
href="http://svn.apache.org/viewvc?view=revision&amp;revision=781711"
class="external-link"
rel="nofollow">http://svn.apache.org/viewvc?view=revision&amp;revision=781711</a> (7
months ago) by adding these lines :+        if (endTime &lt; 0) {+            endTime =
Long.MAX_VALUE;+        }So now, the wait() never exists from the loop, thus the
hang...Now, we have to find a way to get out of this loop the normal way... 
==============================

On issue key DIRMINA-495 the singleton pattern might have been discussed on the following comment: 
==============================
This is a better version.  It accepts Map&lt;?, ?&gt; rather than Map&lt;Object,Object&gt;
so the user can do Collections.singletonMap() without having to cast or qualify it. 
==============================

On issue key DIRMINA-495 the Proxy pattern might have been discussed on the following comment: 
==============================
I ran into a similar situation some time ago though I wanted to do more with the session
than add attributes. First I thought I could just use an IoFutureListener and access the
new session there. I soon realized that this wouldn't work since I needed my
IoFutureListener to be called before sessionCreate() on my IoHandler. There's no way to
guarantee that that happens in this order with MINA 1.x.I ended up with something
likeconnector.connect(address, new IoHandlerProxy(realIoHandler) {<br/>    public void
sessionCreated(IoSession session) {        // Do whatever it was I needed to do with the
session here        super.sessionCreated(session);    }}IoHandlerProxy is a simple custom
class which let's me intercept calls to the real IoHandler. I think you get the point.My
point here is that there may be other things than adding attributes one might want to do
before sessionCreated() is called. If connect() would take a ConnectCallback as an
argument the user could do whatever she wants before the IoHandler is called, not just add
attributes.ConnectCallback would be very similar to IoFutureListener so maybe we could use
that and connect() would automatically set the IoFutureListener on the ConnectFuture. In
that way it is guaranteed that the listener is called before the IoHandler is called.With
this it would be simple to add attributes to the session:connector.connect(add, new
IoFutureListener&lt;ConnectFuture&gt;() {<br/>    void operationComplete(ConnectFuture
future) {<br/>        if (future.isConnected()) {           
future.getSession().addAttribute(...);        }   }<br/>});We could still also add a
connect(addr, Map) method to IoConnector but it would be implemented like the above.WDYT? 
==============================

On issue key DIRMINA-495 the mediate pattern might have been discussed on the following comment: 
==============================
That seems reasonable - with a general callback you could cleanly add attributes.  BUT
we'd have to ensure that the callback is called <del>immediately</del> after the session
is created.  The regular ConnectFuture callback doesn't happen until the connect completes
- which is too late <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>So maybe a new "SessionFuture" type is
called for?Also the callback method should be allowed to throw exceptions.You could then
do this (which would meet the requirements of this issue):connector.connect(addr, new
IoFutureListener&lt;SessionFuture&gt;() {<br/>    void operationComplete(SessionFuture
future) {        future.getSession.setAttribute(MY_KEY, myVal);    }} 
==============================

On issue key DIRMINA-495 the chain pattern might have been discussed on the following comment: 
==============================
Works for me.  As long as it's definitely called before the sessionCreated() filter
chain/handler method <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-616 the command pattern might have been discussed on the following comment: 
==============================
It does not work... The 2.2-beta63-SNAPSHOT does not exist anywhere ... (skipped some rude
sentences about maven ...)<span class="error">&#91;INFO&#93;</span> A required plugin was
not found: Plugin could not be found - check that the goal name is correct: Unable to
download the artifact from any repositoryTry downloading the file manually from the
project website.Then, install it using the command: <br/>    mvn install:install-file
-DgroupId=org.apache.maven.plugins -DartifactId=maven-assembly-plugin
-Dversion=2.2-beta-3-SNAPSHOT -Dpackaging=maven-plugin -Dfile=/path/to/fileAlternatively,
if you host your own repository you can deploy the file there: <br/>    mvn
deploy:deploy-file -DgroupId=org.apache.maven.plugins -DartifactId=maven-assembly-plugin
-Dversion=2.2-beta-3-SNAPSHOT -Dpackaging=maven-plugin -Dfile=/path/to/file -Durl=<span
class="error">&#91;url&#93;</span> -DrepositoryId=<span class="error">&#91;id&#93;</span> 
org.apache.maven.plugins:maven-assembly-plugin:maven-plugin:2.2-beta-3-SNAPSHOTfrom the
specified remote repositories:<br/>  central (<a href="http://repo1.maven.org/maven2"
class="external-link" rel="nofollow">http://repo1.maven.org/maven2</a>) 
org.apache.maven.plugins:maven-assembly-plugin:maven-plugin:2.2-beta-3-SNAPSHOTfrom the
specified remote repositories:<br/>  central (<a href="http://repo1.maven.org/maven2"
class="external-link" rel="nofollow">http://repo1.maven.org/maven2</a>) 
==============================

On issue key DIRMINA-456 the Adapter pattern might have been discussed on the following comment: 
==============================
Good call Heath .  You were spot on with everything running in the same thread.  (Cool
name BTW. <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> )Consider the following example:	public
static void main(String[] args) throws IOException {<br/>		NioSocketAcceptor acceptor =
new
NioSocketAcceptor(Executors.newCachedThreadPool());<br/>		acceptor.getFilterChain().addLast("executor",
new ExecutorFilter(Executors.newCachedThreadPool()));<br/>		acceptor.setHandler(new
IoHandlerAdapter() {<br/>			@Override<br/>			public void messageReceived(IoSession
session, Object message) throws Exception {				session.write(IoBuffer.wrap("Have a nice
day\n".getBytes()));				Thread.sleep(2000);				session.write(IoBuffer.wrap("MINA makes me
happy\n".getBytes()));				Thread.sleep(2000);				session.write(IoBuffer.wrap("I like cold
beverages\n".getBytes()));			}		});<br/>		acceptor.setLocalAddress(new
InetSocketAddress(1995));<br/>		acceptor.bind();<br/>	}The above code works just fine.  If
you comment out the executor filter, all the writes are done at once after waiting 4000ms.
 This make sense because the messageReceived is being executed in the I/O thread.However,
if you comment out the executor filter and then append .awaitUninterruptibly(), the server
stalls indefinitely.So the question is, do we put something in the await methods that
checks to see if the await is being called in the I/O thread the await is dependent on and
throw a dead-lock exception?  Is there away that we can execute the desired action from
the await methods instead of blocking in this case? 
==============================

On issue key DIRMINA-456 the Chain pattern might have been discussed on the following comment: 
==============================
Good call Heath .  You were spot on with everything running in the same thread.  (Cool
name BTW. <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> )Consider the following example:	public
static void main(String[] args) throws IOException {<br/>		NioSocketAcceptor acceptor =
new
NioSocketAcceptor(Executors.newCachedThreadPool());<br/>		acceptor.getFilterChain().addLast("executor",
new ExecutorFilter(Executors.newCachedThreadPool()));<br/>		acceptor.setHandler(new
IoHandlerAdapter() {<br/>			@Override<br/>			public void messageReceived(IoSession
session, Object message) throws Exception {				session.write(IoBuffer.wrap("Have a nice
day\n".getBytes()));				Thread.sleep(2000);				session.write(IoBuffer.wrap("MINA makes me
happy\n".getBytes()));				Thread.sleep(2000);				session.write(IoBuffer.wrap("I like cold
beverages\n".getBytes()));			}		});<br/>		acceptor.setLocalAddress(new
InetSocketAddress(1995));<br/>		acceptor.bind();<br/>	}The above code works just fine.  If
you comment out the executor filter, all the writes are done at once after waiting 4000ms.
 This make sense because the messageReceived is being executed in the I/O thread.However,
if you comment out the executor filter and then append .awaitUninterruptibly(), the server
stalls indefinitely.So the question is, do we put something in the await methods that
checks to see if the await is being called in the I/O thread the await is dependent on and
throw a dead-lock exception?  Is there away that we can execute the desired action from
the await methods instead of blocking in this case? 
==============================

On issue key DIRMINA-231 the adapt pattern might have been discussed on the following comment: 
==============================
Attaching ConnectingTest which shows problem using VmPipes as well (adapted from <a
href="http://issues.apache.org/jira/secure/attachment/20356/ConnectionTest.java"
class="external-link"
rel="nofollow">http://issues.apache.org/jira/secure/attachment/20356/ConnectionTest.java</a>). 
==============================

On issue key DIRMINA-231 the chain pattern might have been discussed on the following comment: 
==============================
Warning - running attached ConnectionTest may bring your machine to its knees!The
PooledThreadModel which is used by the default configuration creates a new
ThreadPoolFilter which is what is creating these wayward threads. I don't think the
destroy method of this filter ever gets called. If the PooledThreadModel used a
ReferenceCountingIoFilter to wrap the ThreadPoolFilter before adding it to the chain then
would destroy be called? 
==============================

On issue key DIRMINA-231 the  state  pattern might have been discussed on the following comment: 
==============================
To shut them down you will have to call destory() on the
ThreadPoolFilter:session.getFilterChain().get(PooledThreadModel.class.getName()).destroy();or
you create your own ThreadModel which wraps the ThreadPoolFilter in a
ReferenceCountingIoFilter instance.If you weren't using a ThreadPoolFilter with MINA 0.8
and you want the same behaviour with MINA 0.9 you must specify the ThreadModel.MANUAL
thread model as you suggest in <a href="http://www.quickfixj.org/jira/browse/QFJ-34"
class="external-link" rel="nofollow">http://www.quickfixj.org/jira/browse/QFJ-34</a>.If
you use the default config each connection will get its own thread pool. The threads in
the pool (these are named AnonymousIoService-x-y by default) will by default be terminated
after 1 minute of inactivity. If the threads do hang around for more than 1 minute that
would be a bug. In QFJ-34 you state that the Anonymous... threads never die off so there
may very well be a bug here.Is there anyway you could refactor your code to use a single
shared connector? Or use a shared ThreadPoolFilter (use MANUAL and add your own
ThreadPoolFilter to each connectors filter chain)? I think this is more "in tune" with how
MINA is supposed to be used. 
==============================

On issue key DIRMINA-231 the chain pattern might have been discussed on the following comment: 
==============================
To shut them down you will have to call destory() on the
ThreadPoolFilter:session.getFilterChain().get(PooledThreadModel.class.getName()).destroy();or
you create your own ThreadModel which wraps the ThreadPoolFilter in a
ReferenceCountingIoFilter instance.If you weren't using a ThreadPoolFilter with MINA 0.8
and you want the same behaviour with MINA 0.9 you must specify the ThreadModel.MANUAL
thread model as you suggest in <a href="http://www.quickfixj.org/jira/browse/QFJ-34"
class="external-link" rel="nofollow">http://www.quickfixj.org/jira/browse/QFJ-34</a>.If
you use the default config each connection will get its own thread pool. The threads in
the pool (these are named AnonymousIoService-x-y by default) will by default be terminated
after 1 minute of inactivity. If the threads do hang around for more than 1 minute that
would be a bug. In QFJ-34 you state that the Anonymous... threads never die off so there
may very well be a bug here.Is there anyway you could refactor your code to use a single
shared connector? Or use a shared ThreadPoolFilter (use MANUAL and add your own
ThreadPoolFilter to each connectors filter chain)? I think this is more "in tune" with how
MINA is supposed to be used. 
==============================

On issue key DIRMINA-231 the Chain pattern might have been discussed on the following comment: 
==============================
To shut them down you will have to call destory() on the
ThreadPoolFilter:session.getFilterChain().get(PooledThreadModel.class.getName()).destroy();or
you create your own ThreadModel which wraps the ThreadPoolFilter in a
ReferenceCountingIoFilter instance.If you weren't using a ThreadPoolFilter with MINA 0.8
and you want the same behaviour with MINA 0.9 you must specify the ThreadModel.MANUAL
thread model as you suggest in <a href="http://www.quickfixj.org/jira/browse/QFJ-34"
class="external-link" rel="nofollow">http://www.quickfixj.org/jira/browse/QFJ-34</a>.If
you use the default config each connection will get its own thread pool. The threads in
the pool (these are named AnonymousIoService-x-y by default) will by default be terminated
after 1 minute of inactivity. If the threads do hang around for more than 1 minute that
would be a bug. In QFJ-34 you state that the Anonymous... threads never die off so there
may very well be a bug here.Is there anyway you could refactor your code to use a single
shared connector? Or use a shared ThreadPoolFilter (use MANUAL and add your own
ThreadPoolFilter to each connectors filter chain)? I think this is more "in tune" with how
MINA is supposed to be used. 
==============================

On issue key DIRMINA-380 the chain pattern might have been discussed, namely here: 
==============================
Invocation chaining for IoFuture 
==============================

On issue key DIRMINA-269 the proxy pattern might have been discussed on the following comment: 
==============================
This kind of functionality maybe also needed in a proxy server where the connection to the
proxied server should be closed if the proxy client is closing the connection. 
==============================

On issue key DIRMINA-608 the strategy pattern might have been discussed on the following comment: 
==============================
Attached is a first proposal, please take a look. I'd like to see if there's any initial
feedback now, and I'll work up a more extensive patch the coming weeks before M3 is
released.Open issues:<ul class="alternate" type="square">	<li>should maybe leave the
methodes on the IoService interface for the next milestone, marked deprecated, and don't
remove them until 2.0 final.</li></ul><ul class="alternate" type="square">	<li>interface
naming is open to debate (e.g. the current naming scheme doesn't really allow the same
interfaces to be used for IoSession statistics).</li></ul><ul class="alternate"
type="square">	<li>location of the lastReadTime() / lastWriteTime() / lastIoTime() methods
is open to debate.</li></ul><ul class="alternate" type="square">	<li>to keep the impact of
this first patch low, I just made AbstractIoService implement the statistics interfaces,
rather than factoring them into inner classes. (separation of concerns, high cohesion,
etc.) Factoring them into separate classes gives the ability to deploy those instances
into an MBeanServer, which I think is a big reason to make that change. Not all
application servers use the standard MBeanServer (at least historically; Java 5 may have
changed that) and JMX+OSGi isn't always straightforward, so the actual MBean deployment
should be handled by a pluggable strategy implementation.</li></ul><ul class="alternate"
type="square">	<li>I haven't touched the IoSession statistics yet, but the basic idea is
the same.</li></ul><ul class="alternate" type="square">	<li>anything
else?</li></ul>Thanks,Barend 
==============================

On issue key DIRMINA-375 the Chain pattern might have been discussed on the following comment: 
==============================
First of all, thank you very much Brad for excellent idea and contribution!  Literally
cool! <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/biggrin.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>I think Brad's patch can be easily
integrated into IoSession; IoSession could have a read() method that returns
ReadFuture:<ul>	<li>Object m = session.read().await(10000).getMessage(); // Returns null
unless received within 10 sec.</li>	<li>Object m =
session.read(10000).await().getMessage(); // Throws exception unless received within 10
sec.</li></ul>This could be implemented by adding a queue of ReadFutures to IoSession and
modifying DefaultIoFilterChain to poll the ReadFuture and give notification for each
messageReceived event.  By utilizing existing facilities that IoSession and MINA provides,
the amount of change could become much smaller.Possible list of thrown exceptions would
be:<ul>	<li>EOFException - if the session is closed.</li>	<li>SocketTimeoutException - on
timeout</li></ul>One problem is that these exceptions are not a RuntimeIoException.  We
could create DisconnectionException and ReadTimeoutException that extend
RuntimeIoException though.WDYT everyone? 
==============================

On issue key DIRMINA-375 the  state  pattern might have been discussed on the following comment: 
==============================
+1I really like the idea of having an IoSession.read() method that returns a ReadFuture so
that you can block and/or register a IoFutureListener that handles the next message
received.  This would greatly simplify so much of the state management we currently have
to do in our IoHandler's.Let me know where I can help with integrating this into trunk. 
==============================

On issue key DIRMINA-473 the Chain pattern might have been discussed on the following comment: 
==============================
Hi Trustin,I'm unfortunately still getting the
exception.-RogerException:<br/>java.lang.IllegalStateException: sessionBufferSize:
-696<br/>       at
org.apache.mina.filter.traffic.ReadThrottleFilter.exit(ReadThrottleFilter.java:493)<br/>  
    at
org.apache.mina.filter.traffic.ReadThrottleFilter.messageReceived(ReadThrottleFilter.java:347)<br/>
      at
org.apache.mina.common.DefaultIoFilterChain.callNextMessageReceived(DefaultIoFilterChain.java:399)<br/>
      at
org.apache.mina.common.DefaultIoFilterChain.access$1200(DefaultIoFilterChain.java:38)<br/>
      at
org.apache.mina.common.DefaultIoFilterChain$EntryImpl$1.messageReceived(DefaultIoFilterChain.java:791)<br/>
      at org.apache.mina.common.IoFilterEvent.fire(IoFilterEvent.java:54)<br/>       at
org.apache.mina.common.IoEvent.run(IoEvent.java:62)<br/>       at
java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:885)<br/>  
    at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)<br/>      
at java.lang.Thread.run(Thread.java:619) 
==============================

On issue key DIRMINA-495 the singleton pattern might have been discussed on the following comment: 
==============================
This is a better version.  It accepts Map&lt;?, ?&gt; rather than Map&lt;Object,Object&gt;
so the user can do Collections.singletonMap() without having to cast or qualify it. 
==============================

On issue key DIRMINA-495 the Proxy pattern might have been discussed on the following comment: 
==============================
I ran into a similar situation some time ago though I wanted to do more with the session
than add attributes. First I thought I could just use an IoFutureListener and access the
new session there. I soon realized that this wouldn't work since I needed my
IoFutureListener to be called before sessionCreate() on my IoHandler. There's no way to
guarantee that that happens in this order with MINA 1.x.I ended up with something
likeconnector.connect(address, new IoHandlerProxy(realIoHandler) {<br/>    public void
sessionCreated(IoSession session) {        // Do whatever it was I needed to do with the
session here        super.sessionCreated(session);    }}IoHandlerProxy is a simple custom
class which let's me intercept calls to the real IoHandler. I think you get the point.My
point here is that there may be other things than adding attributes one might want to do
before sessionCreated() is called. If connect() would take a ConnectCallback as an
argument the user could do whatever she wants before the IoHandler is called, not just add
attributes.ConnectCallback would be very similar to IoFutureListener so maybe we could use
that and connect() would automatically set the IoFutureListener on the ConnectFuture. In
that way it is guaranteed that the listener is called before the IoHandler is called.With
this it would be simple to add attributes to the session:connector.connect(add, new
IoFutureListener&lt;ConnectFuture&gt;() {<br/>    void operationComplete(ConnectFuture
future) {<br/>        if (future.isConnected()) {           
future.getSession().addAttribute(...);        }   }<br/>});We could still also add a
connect(addr, Map) method to IoConnector but it would be implemented like the above.WDYT? 
==============================

On issue key DIRMINA-495 the mediate pattern might have been discussed on the following comment: 
==============================
That seems reasonable - with a general callback you could cleanly add attributes.  BUT
we'd have to ensure that the callback is called <del>immediately</del> after the session
is created.  The regular ConnectFuture callback doesn't happen until the connect completes
- which is too late <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>So maybe a new "SessionFuture" type is
called for?Also the callback method should be allowed to throw exceptions.You could then
do this (which would meet the requirements of this issue):connector.connect(addr, new
IoFutureListener&lt;SessionFuture&gt;() {<br/>    void operationComplete(SessionFuture
future) {        future.getSession.setAttribute(MY_KEY, myVal);    }} 
==============================

On issue key DIRMINA-495 the chain pattern might have been discussed on the following comment: 
==============================
Works for me.  As long as it's definitely called before the sessionCreated() filter
chain/handler method <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-623 the proxy pattern might have been discussed, namely here: 
==============================
Failure of test org.apache.mina.proxy.NTLMTest.testType1Message on windows Vista 
==============================

On issue key DIRMINA-405 the mediate pattern might have been discussed, namely here: 
==============================
IoSession.suspendRead() doesn't suspend read operation immediately when
ProtocolCodecFilter is used. 
==============================

On issue key DIRMINA-473 the Chain pattern might have been discussed on the following comment: 
==============================
Hi Trustin,I'm unfortunately still getting the
exception.-RogerException:<br/>java.lang.IllegalStateException: sessionBufferSize:
-696<br/>       at
org.apache.mina.filter.traffic.ReadThrottleFilter.exit(ReadThrottleFilter.java:493)<br/>  
    at
org.apache.mina.filter.traffic.ReadThrottleFilter.messageReceived(ReadThrottleFilter.java:347)<br/>
      at
org.apache.mina.common.DefaultIoFilterChain.callNextMessageReceived(DefaultIoFilterChain.java:399)<br/>
      at
org.apache.mina.common.DefaultIoFilterChain.access$1200(DefaultIoFilterChain.java:38)<br/>
      at
org.apache.mina.common.DefaultIoFilterChain$EntryImpl$1.messageReceived(DefaultIoFilterChain.java:791)<br/>
      at org.apache.mina.common.IoFilterEvent.fire(IoFilterEvent.java:54)<br/>       at
org.apache.mina.common.IoEvent.run(IoEvent.java:62)<br/>       at
java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:885)<br/>  
    at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)<br/>      
at java.lang.Thread.run(Thread.java:619) 
==============================

On issue key DIRMINA-608 the strategy pattern might have been discussed on the following comment: 
==============================
Attached is a first proposal, please take a look. I'd like to see if there's any initial
feedback now, and I'll work up a more extensive patch the coming weeks before M3 is
released.Open issues:<ul class="alternate" type="square">	<li>should maybe leave the
methodes on the IoService interface for the next milestone, marked deprecated, and don't
remove them until 2.0 final.</li></ul><ul class="alternate" type="square">	<li>interface
naming is open to debate (e.g. the current naming scheme doesn't really allow the same
interfaces to be used for IoSession statistics).</li></ul><ul class="alternate"
type="square">	<li>location of the lastReadTime() / lastWriteTime() / lastIoTime() methods
is open to debate.</li></ul><ul class="alternate" type="square">	<li>to keep the impact of
this first patch low, I just made AbstractIoService implement the statistics interfaces,
rather than factoring them into inner classes. (separation of concerns, high cohesion,
etc.) Factoring them into separate classes gives the ability to deploy those instances
into an MBeanServer, which I think is a big reason to make that change. Not all
application servers use the standard MBeanServer (at least historically; Java 5 may have
changed that) and JMX+OSGi isn't always straightforward, so the actual MBean deployment
should be handled by a pluggable strategy implementation.</li></ul><ul class="alternate"
type="square">	<li>I haven't touched the IoSession statistics yet, but the basic idea is
the same.</li></ul><ul class="alternate" type="square">	<li>anything
else?</li></ul>Thanks,Barend 
==============================

On issue key DIRMINA-16 the singleton pattern might have been discussed on the following comment: 
==============================
Now you can create your own TransportType singletons.  Please check out and refer to
JavaDoc. <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>I'm still looking for better way to
separate TransportType constants to each packages, but it looks more clean for
TransportType to have all default constants.  WDYT? 
==============================

On issue key DIRMINA-244 the Factory pattern might have been discussed, namely here: 
==============================
Example HTTP server using ProtocolCodeFactory 
==============================

On issue key DIRMINA-176 the  state  pattern might have been discussed on the following comment: 
==============================
I'd like time out for ByteBuffers too, it is all we need.To implement application
specified strategies of pooling there will be the JMX support <a
href="https://issues.apache.org/jira/browse/DIRMINA-29" title="JMX integration"
class="issue-link" data-issue-key="DIRMINA-29"><del>DIRMINA-29</del></a>.<br/>With the JMX
we could monitor and manage the pool state for user-defined strategies. 
==============================

On issue key DIRMINA-176 the strategy pattern might have been discussed on the following comment: 
==============================
Retaining smaller buffers can also cause a problem depending on an application's memory
usage characterstics.  What about providing both strategy at the same time? 
==============================

On issue key DIRMINA-176 the command pattern might have been discussed on the following comment: 
==============================
Yes, but, by the pool point of view, what is regarded as a smaller buffer and a bigger
buffer? Supposing to have an application that uses 30 byte buffers and occasionally some
2kb buffers (this is the case of one of the ones I'm working on now), the pool would have
serious problems to understand which ones are "smaller" and "bigger", since all of them
are of the smallest or biggest size available.In this case not to cache smallest and
biggest buffer is a problem, and to limit the maximum size would certainly not be an
improvement.But many low-level byte protocols use short fixed lenght packets for "command"
messages and use long variable lenght packets for "transport" messages, so my case is a
common case.I think what you're suggesting is very good for protocols which use many
different-sized buffers, and should therefore be implemented, but we should also let users
chose whether to use it or not.In the overload control, we should also think about
interrupting  the work when the memory limit of the pool is exceeded, in order to permit
the application to flush and release the buffers that haven't been written yet. 
==============================

On issue key DIRMINA-176 the factory pattern might have been discussed on the following comment: 
==============================
This jakarta api seems to be the right solution, we can do a GenericObjectPool for each
buffer size, at the same way we mantain multiple stacks now.<br/>This api provides the
timeout we thought, it provides also the method that block if the objects are not
available (in case we are over the maximum size of the pool, and we cannot allocate other
buffers).<br/>We have to define better some things, but it looks great to me.One thing is
the following: in this jakarta pool the new objects are provided by a factory that
allocate all the objects equals. So for each partition we will be obliged to allocate only
one kind of buffer, the higher size buffer of the partition, right? I'm not so good with
english, so I hope I have well explained my doubt. 
==============================

On issue key DIRMINA-209 the singleton pattern might have been discussed, namely here: 
==============================
SocketIoProcessor singleton causes performance wall under load 
==============================

On issue key DIRMINA-587 the proxy pattern might have been discussed, namely here: 
==============================
The proxy sample does not work - results in a NullPointerException 
==============================

On issue key DIRMINA-185 the decorator pattern might have been discussed on the following comment: 
==============================
I would like to see the IoFilterLCM go away.IoFilter's that want the current behavior can
implement ref'counting themselves (via a decorator or abstract superclass). 
==============================

On issue key DIRMINA-185 the decorator pattern might have been discussed on the following comment: 
==============================
I agree with Peter.  So, here's my idea:<ul>	<li>Remove IoFilter.init() and
IoFilter.destroy();</li>	<li>Create a new utility decorator class. say,
'IoFilterWithLifeCycle' (Please suggest better names), which</li>	<li>provides a protected
void init() and destroy().</li>	<li>implements other lifecycle methods in IoFilter so it
calls init() and destroy() properly.</li></ul>WDYT? 
==============================

On issue key DIRMINA-454 the mediate pattern might have been discussed on the following comment: 
==============================
Thank you very much for the patch and the inspiration.  The bug has been fixed.  I made
sure OOM is not thrown anymore and decoder continues to decode even after too long text
line.  Please confirm if the bug has been fixed and close this issue.One difference from
no-dos.patch is that OOM is not thrown immediately.  It keeps discarding incoming data
when client sends too long line, and throws an OOM error when EOL (line delimiter) is
encountered.  It was necessary behavior to make the decoder continue to work even after
encountering broken data.  ProtocolCodecFilter also has been improved to continue decoding
after an exception is thrown.  Please refer to the svn commit log for the detailed
information.  All these changes shouldn't affect existing applications. 
==============================

On issue key DIRMINA-184 the Chain pattern might have been discussed on the following comment: 
==============================
Peter, I have a few questions about your commit:1)<br/>At line 187 of
LeaderFollowerThreadPool:    //TODO this should be in the filter, inits on pre-add if we
have not been init'ed<br/>    public void onPreAdd( IoFilterChain parent, String name,
IoFilter.NextFilter nextFilter )<br/>        throws Exception<br/>    {<br/>        if(
leader == null )        {            init();        }    }Do we need this method?  I guess
this method is not invoked by anyone.2) If LeaderFollowerThreadPool and
ThreadPoolThreadPoolFilter provides exactly the same functionality with ThreadPoolFilter,
why don't we replace it?  ThreadPoolThreadPoolFilter could become a ThreadPoolFilter which
uses LeaderFollowerThreadPool by default, and the pool implementation could be changed if
a user specifies his or her favorite pool implementation.3) Can't we simply expose
ProcessEventRunnable to users and make ThreadPool.submit accept it instead of Object? 
==============================

On issue key DIRMINA-454 the mediate pattern might have been discussed on the following comment: 
==============================
Thank you very much for the patch and the inspiration.  The bug has been fixed.  I made
sure OOM is not thrown anymore and decoder continues to decode even after too long text
line.  Please confirm if the bug has been fixed and close this issue.One difference from
no-dos.patch is that OOM is not thrown immediately.  It keeps discarding incoming data
when client sends too long line, and throws an OOM error when EOL (line delimiter) is
encountered.  It was necessary behavior to make the decoder continue to work even after
encountering broken data.  ProtocolCodecFilter also has been improved to continue decoding
after an exception is thrown.  Please refer to the svn commit log for the detailed
information.  All these changes shouldn't affect existing applications. 
==============================

On issue key DIRMINA-162 the builder pattern might have been discussed on the following comment: 
==============================
I think you're right on the issue with sessions being opened / closed. Main thing is that
only the higher level protocol (on top of UDP) can really determine the meaning of
a<br/>'session' in its very own context. It might be possible to design some kind of
protocol filter which implements generic session tracking on top of simple message
delivery by:<ul class="alternate" type="square">	<li>tracking received message from the
remote peer and fire off a sessionOpened() event BEFORE passing the message onto the next
filter in the chain</li>	<li>implement a timeout-based mechanism that tracks the data
messages passing through and closes the session if the timeout passes by (including firing
the event)<br/>But it does not seem feasible to implement this as a generic behauviour of
the datagram acceptor (as there are protocol which do not have the concept of a session at
all)</li></ul>But I do think that it is a bug in the implementation of the datagram
acceptor if it does not assembly the filter chains when the individual session get create.
I understand that it is currently needed ot create a session per received message but it
should then assemble the filter chain per session as one should expect from the
documentation. It would then be <br/>necessary to document this as an user might need to
take special precautions in this chain builder implementation. 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
I think you're right on the issue with sessions being opened / closed. Main thing is that
only the higher level protocol (on top of UDP) can really determine the meaning of
a<br/>'session' in its very own context. It might be possible to design some kind of
protocol filter which implements generic session tracking on top of simple message
delivery by:<ul class="alternate" type="square">	<li>tracking received message from the
remote peer and fire off a sessionOpened() event BEFORE passing the message onto the next
filter in the chain</li>	<li>implement a timeout-based mechanism that tracks the data
messages passing through and closes the session if the timeout passes by (including firing
the event)<br/>But it does not seem feasible to implement this as a generic behauviour of
the datagram acceptor (as there are protocol which do not have the concept of a session at
all)</li></ul>But I do think that it is a bug in the implementation of the datagram
acceptor if it does not assembly the filter chains when the individual session get create.
I understand that it is currently needed ot create a session per received message but it
should then assemble the filter chain per session as one should expect from the
documentation. It would then be <br/>necessary to document this as an user might need to
take special precautions in this chain builder implementation. 
==============================

On issue key DIRMINA-162 the strategy pattern might have been discussed on the following comment: 
==============================
This is a great idea.  We could provide a generic session tracking strategy interface so
users can choose their favorite session management method.  For instance:/** A kind of
cache? */<br/>public interface ConnectionlessSessionTracker {<br/>    /**<ul>	<li>@return
null if no session is found<br/>     */<br/>    IoSession getSession( SocketAddress
localAddress, SocketAddress remoteAddress );<br/>}</li></ul>WDYT? 
==============================

On issue key DIRMINA-162 the facade pattern might have been discussed on the following comment: 
==============================
I already approached this but I found out that it will not work without a acceptor facade
which encapsulates the "real" datagram acceptor and does the session tarcking on behalf
of<br/>the client. This thing is in fact second-next on my to-do list for my current
project. <br/>Once this facade works, it can easily implement the proposed tracker
interface. If it works, I will supply my implementation as a diff to mina-0.9.0 
==============================

On issue key DIRMINA-162 the strategy pattern might have been discussed on the following comment: 
==============================
Here's my first stab at fixing this. Could somebody please review it? I haven't touched
the MINA code before just tonight <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>The attached diff is against svn revision
440993, the current trunk at this time.Basically, you can implement the methods	void
sessionCreated(IoSession session);<br/>	IoSession getSession(SocketAddress localAddress,
SocketAddress remoteAddress);in a ConnectionlessSessionTracker, and assign that to a
DatagramSessionConfig. From then on, the tracker will perform session management for the
transport.The only current problem is that the session cannot be retrieved until the
remote socket address is known. In DatagramChannel, this happen upon read, so the session
cannot be queried for its read buffer size. I think it should still be the same, but once
again, please review it.Here is also a testing version of a ConnectionlessSessionTracker
(don't use, it doesn't expire or do anything advanced enough):import
java.net.InetSocketAddress;<br/>import java.net.SocketAddress;<br/>import
java.util.HashMap;<br/>import java.util.Map;import
org.apache.mina.common.ConnectionlessSessionTracker;<br/>import
org.apache.mina.common.IoSession;public class TestSessionTracker implements
ConnectionlessSessionTracker<br/>{<br/>	private Map&lt;String, IoSession&gt; sessionMap =
new HashMap&lt;String, IoSession&gt;();	public IoSession getSession(SocketAddress
localAddress, SocketAddress remoteAddress)	{		InetSocketAddress localIsa =
(InetSocketAddress) localAddress;		InetSocketAddress remoteIsa = (InetSocketAddress)
remoteAddress;		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		return
sessionMap.get(key);	}	public void sessionCreated(IoSession
session)<br/>	{<br/>		InetSocketAddress localIsa = (InetSocketAddress)
session.getLocalAddress();<br/>		InetSocketAddress remoteIsa = (InetSocketAddress)
session.getRemoteAddress();		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		if
(!sessionMap.containsKey(key))		{			sessionMap.put(key, session);		}	}<br/>}I imagine that
by integrating iofilters that know of the session tracker, etc you could implement just
about any session management strategy.Let me know what you think! 
==============================

On issue key DIRMINA-162 the Builder pattern might have been discussed on the following comment: 
==============================
Here's my first stab at fixing this. Could somebody please review it? I haven't touched
the MINA code before just tonight <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>The attached diff is against svn revision
440993, the current trunk at this time.Basically, you can implement the methods	void
sessionCreated(IoSession session);<br/>	IoSession getSession(SocketAddress localAddress,
SocketAddress remoteAddress);in a ConnectionlessSessionTracker, and assign that to a
DatagramSessionConfig. From then on, the tracker will perform session management for the
transport.The only current problem is that the session cannot be retrieved until the
remote socket address is known. In DatagramChannel, this happen upon read, so the session
cannot be queried for its read buffer size. I think it should still be the same, but once
again, please review it.Here is also a testing version of a ConnectionlessSessionTracker
(don't use, it doesn't expire or do anything advanced enough):import
java.net.InetSocketAddress;<br/>import java.net.SocketAddress;<br/>import
java.util.HashMap;<br/>import java.util.Map;import
org.apache.mina.common.ConnectionlessSessionTracker;<br/>import
org.apache.mina.common.IoSession;public class TestSessionTracker implements
ConnectionlessSessionTracker<br/>{<br/>	private Map&lt;String, IoSession&gt; sessionMap =
new HashMap&lt;String, IoSession&gt;();	public IoSession getSession(SocketAddress
localAddress, SocketAddress remoteAddress)	{		InetSocketAddress localIsa =
(InetSocketAddress) localAddress;		InetSocketAddress remoteIsa = (InetSocketAddress)
remoteAddress;		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		return
sessionMap.get(key);	}	public void sessionCreated(IoSession
session)<br/>	{<br/>		InetSocketAddress localIsa = (InetSocketAddress)
session.getLocalAddress();<br/>		InetSocketAddress remoteIsa = (InetSocketAddress)
session.getRemoteAddress();		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		if
(!sessionMap.containsKey(key))		{			sessionMap.put(key, session);		}	}<br/>}I imagine that
by integrating iofilters that know of the session tracker, etc you could implement just
about any session management strategy.Let me know what you think! 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
Attached is the next version with IoSessionRecycler per Trustin's and my comments. I still
am not sure about the read buffer size issue (marked by a TODO in the code). Also, after
some thought I don't think this is applicable to transports with connections (seems like
too much abstraction, and doesn't fit well with the MINA session paradigm).I also added a
default implementation, ExpiringSessionRecycler, which uses an ExpiringMap to recycle
sessions. It also calls sessionClosed on the session's filterchain when a session
expires.I hope this helps! I definitely want to contribute something nice that will speed
MINA along to 1.0 <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>Let me know what you think! 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
Minor change to build filter chain only when a session isn't recycled (save some clocks
<img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
And, in an astounding extra $0.02, I also wanted to remind you to update the IoHandler
javadoc since it indicates that sessionOpened/etc will not be called for UDP. I'd also
like to put out there that sessionCreated could be called on the session's filter chain
when it is first created (before sessionOpened), this would make all MINA events
applicable to the UDP transport. I know it doesn't really mean anything different, but it
might be the least surprise to the user.And on that note, I'm going to go do something
else for a while so I don't think of anything else to spam the mailing list with updates
about <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
No problem, happy to lend a hand <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> MINA makes my work easier, so it's more
than a fair trade.I can get to patching the remaining stuff (IoHandler, defaulting to
ExpiringSessionRecycler) within the next couple of days or so. I agree that
ExpiringSessionRecycler should be the default now that I think about all the events flying
around the filter chain with NOOP, and starting the expiration after the first put is a
good compromise. Nice to have util-concurrent for that, since a double check lock is
actually thread-safe with ReentrantReadWriteLock.Do you want me to add an IdentityHashMap
for session lookup? It would mean extra synchronization, and it would affect only the
'remove(IoSession)' method AFAIK. Are the costs to generate the key high enough to justify
that? 
==============================

On issue key DIRMINA-162 the  state  pattern might have been discussed on the following comment: 
==============================
Yargh. In this one (v7), I do the lock upgrade correctly in the startExpiringIfNotStarted
method of ExpiringMap. Sorry 'bout that. Somebody may want to refactor that state locking
code to some common class, cause it would minimize the chances to create bugs like that
<img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-432 the Composite pattern might have been discussed on the following comment: 
==============================
I'd prefer MessageBroadcaster.  And users will want to know which peer failed to receive
the broadcast message, so we need to return something different
like....<ul>	<li>Map&lt;IoSession, WriteFuture&gt; or</li>	<li>CompositeIoFuture (new
interface) that can combine any IoFutures (e.g. ConnectFuture + WriteFuture).</li></ul> 
==============================

On issue key DIRMINA-27 the  state  pattern might have been discussed on the following comment: 
==============================
Yes as a matter of fact the latest Mina OSGi work is still on the apacheDS. You will find
three projects in sandbox/jconlon/osgi-mina.   These projects are for the Mina 1.1.  The
first of these projects is mina-integration-osgi this is a wrapping bundle for mina. The
second mina-osgi-example is a OSGi version of the Chat example.  The third
mina-osgi-example-integration-test is a Spring-OSGi based testing framework for the second
project.I have not moved them to my Mina sandbox or said much about them because many of
the third party dependencies Enrique and I built for OSGi enabling ADS are in the process
of moving to the OSGi felix commons area.  Additionally the Spring-OSGi efforts are in a
state of flux so the testing framework is not very stable nor is it available from stable
maven repos.However the main osgi bundling of mina 1.1 (mina-integration-osgi) should
build for you as it does me right now. The other two projects are a bit more bold in their
use of third party snapshots and thus are more shakey as they require sets of pre-built
dependencies that you won't likely have.  Time will fructify these dependencies and we
should have something provided by third parties soon.Would you like me to create a OSGi
wrapper project for the latest trunk? 
==============================

On issue key DIRMINA-415 the Proxy pattern might have been discussed, namely here: 
==============================
Proxy support 
==============================

On issue key DIRMINA-415 the Proxy pattern might have been discussed on the following comment: 
==============================
Niklas wrote:Now, one thing we should consider is whether we want to
support<br/>specifying proxyHost, proxyPort via system properties, just like
Socket<br/>does. In that case I don't think it will be as simple as wrapping
like<br/>suggested above. Maybe we could support this by having some kind of<br/>factory
which looks at the system properties?Lóránt Pintér wrote:However, I'd vote for supporting
proxyHost and such, because there are a<br/>lot of legacy systems out there moving to
MINA. When they finally<br/>migrate to MINA, their users don't really want to know about
the change,<br/>and don't expect changes in the configuration of the system.I think all of
these systems will then create something like<br/>LegacyProxyConnector inherited from
ProxyingConnector, and set the proxy<br/>parameters from proxyHost etc. As I think a lot
of people would<br/>implement this redundantly, MINA could have it out of the box as well. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Niklas wrote:Now, one thing we should consider is whether we want to
support<br/>specifying proxyHost, proxyPort via system properties, just like
Socket<br/>does. In that case I don't think it will be as simple as wrapping
like<br/>suggested above. Maybe we could support this by having some kind of<br/>factory
which looks at the system properties?Lóránt Pintér wrote:However, I'd vote for supporting
proxyHost and such, because there are a<br/>lot of legacy systems out there moving to
MINA. When they finally<br/>migrate to MINA, their users don't really want to know about
the change,<br/>and don't expect changes in the configuration of the system.I think all of
these systems will then create something like<br/>LegacyProxyConnector inherited from
ProxyingConnector, and set the proxy<br/>parameters from proxyHost etc. As I think a lot
of people would<br/>implement this redundantly, MINA could have it out of the box as well. 
==============================

On issue key DIRMINA-415 the factory pattern might have been discussed on the following comment: 
==============================
Niklas wrote:Now, one thing we should consider is whether we want to
support<br/>specifying proxyHost, proxyPort via system properties, just like
Socket<br/>does. In that case I don't think it will be as simple as wrapping
like<br/>suggested above. Maybe we could support this by having some kind of<br/>factory
which looks at the system properties?Lóránt Pintér wrote:However, I'd vote for supporting
proxyHost and such, because there are a<br/>lot of legacy systems out there moving to
MINA. When they finally<br/>migrate to MINA, their users don't really want to know about
the change,<br/>and don't expect changes in the configuration of the system.I think all of
these systems will then create something like<br/>LegacyProxyConnector inherited from
ProxyingConnector, and set the proxy<br/>parameters from proxyHost etc. As I think a lot
of people would<br/>implement this redundantly, MINA could have it out of the box as well. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
First cut of proxy connector. Supports unauthenticated proxies and proxies with Basic
authentication.Still quite messy - needs some refactoring to work with IoC containers
properly.Tested with MINA 1.1. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Based on James work i hacked around and achieved working NTLM &amp; socks 4 &amp; 4a proxy
support<br/>But it still needs a lot of work : code cleaning, API reworking, socks 5 &amp;
digest support<br/>i'll keep sending infos on  progress made 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Due to personal events i've made less progress than expected.<br/>But Socks5 support is
now added and digest auth is currently in progress.<br/>Code still needs lot of workThe
problem is that it is hard to test the code as i have no dedicated network to test it. For
example, i've been unable to find a free proxy supporting Socks5 with GSSAPI
auth.<br/>Generally speaking i've been forced to use many different proxies because each
of them has a unique combination of auth methods.<br/>So i may need help on this, if some
of you could test the proxy program within their network it would help debbuging.Regarding
a previous comment on IOC containers, i've no idea on how to make code IoC friendly : i'll
accept any clue on this ;pAnother important point is that the code contains some basic
objects (HttpHeader, HttpResponse etc...) that i think should be refactored to use
AsyncWeb (not sure this is the official MINA http project ?) code<br/>WDYT ?That's all for
the moment<br/>Any comments or help is appreciated. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Hi community,This is a great day (althought i spent 3 hours in the strike this morning
<img class="emoticon" src="https://issues.apache.org/jira/images/icons/emoticons/sad.png"
height="16" width="16" align="absmiddle" alt="" border="0"/> ...) <br/>as i'm proud to
announce after 4 months of work that <br/>i'm releasing a proxy support connector for MINA
2.0-M1.This release features :HTTP proxy : <ul class="alternate"
type="square">	<li>Support for NTLM authentication</li>	<li>Support for Digest
authentication</li>	<li>Transparent support for reconnection to a http proxy that does not
support connection keep alive</li>	<li>Support for HTTP/1.1 requests</li>	<li>Support for
multi valued headers</li>	<li>Configuration of prefered authentication
mechanism</li>	<li>Smart proxy authentication system that dynamically and automatically
selects the mechanism to use</li></ul>SOCKS :<ul class="alternate"
type="square">	<li>Support for SOCKS4 and SOCKS4a</li>	<li>Support for SOCKS5 with support
for GSSAPI authentication via Kerberos V</li></ul>Moreover i added some test classes and
junit testcases to test internals and <br/>cover most of the revelant functionnalities.I
hope this work will be usefull for the community as i put great efforts on it<br/>I'm
really excited by looking forward for your questions, comments, etc...Regards,<ul
class="alternate" type="square">	<li>Edouard De Oliveira -<br/><a
href="http://tedorg.free.fr/en/projects.php" class="external-link"
rel="nofollow">http://tedorg.free.fr/en/projects.php</a></li></ul> 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Source code updated to comply with MINA 2.0.0-M2 version.<br/>Some minor refactorings were
madeAdded a telnet test client : tested it by communicating with a SMTP server through a
http &amp; socks proxy. 
==============================

On issue key DIRMINA-415 the Proxy pattern might have been discussed, namely here: 
==============================
Proxy support 
==============================

On issue key DIRMINA-415 the Proxy pattern might have been discussed on the following comment: 
==============================
Niklas wrote:Now, one thing we should consider is whether we want to
support<br/>specifying proxyHost, proxyPort via system properties, just like
Socket<br/>does. In that case I don't think it will be as simple as wrapping
like<br/>suggested above. Maybe we could support this by having some kind of<br/>factory
which looks at the system properties?Lóránt Pintér wrote:However, I'd vote for supporting
proxyHost and such, because there are a<br/>lot of legacy systems out there moving to
MINA. When they finally<br/>migrate to MINA, their users don't really want to know about
the change,<br/>and don't expect changes in the configuration of the system.I think all of
these systems will then create something like<br/>LegacyProxyConnector inherited from
ProxyingConnector, and set the proxy<br/>parameters from proxyHost etc. As I think a lot
of people would<br/>implement this redundantly, MINA could have it out of the box as well. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Niklas wrote:Now, one thing we should consider is whether we want to
support<br/>specifying proxyHost, proxyPort via system properties, just like
Socket<br/>does. In that case I don't think it will be as simple as wrapping
like<br/>suggested above. Maybe we could support this by having some kind of<br/>factory
which looks at the system properties?Lóránt Pintér wrote:However, I'd vote for supporting
proxyHost and such, because there are a<br/>lot of legacy systems out there moving to
MINA. When they finally<br/>migrate to MINA, their users don't really want to know about
the change,<br/>and don't expect changes in the configuration of the system.I think all of
these systems will then create something like<br/>LegacyProxyConnector inherited from
ProxyingConnector, and set the proxy<br/>parameters from proxyHost etc. As I think a lot
of people would<br/>implement this redundantly, MINA could have it out of the box as well. 
==============================

On issue key DIRMINA-415 the factory pattern might have been discussed on the following comment: 
==============================
Niklas wrote:Now, one thing we should consider is whether we want to
support<br/>specifying proxyHost, proxyPort via system properties, just like
Socket<br/>does. In that case I don't think it will be as simple as wrapping
like<br/>suggested above. Maybe we could support this by having some kind of<br/>factory
which looks at the system properties?Lóránt Pintér wrote:However, I'd vote for supporting
proxyHost and such, because there are a<br/>lot of legacy systems out there moving to
MINA. When they finally<br/>migrate to MINA, their users don't really want to know about
the change,<br/>and don't expect changes in the configuration of the system.I think all of
these systems will then create something like<br/>LegacyProxyConnector inherited from
ProxyingConnector, and set the proxy<br/>parameters from proxyHost etc. As I think a lot
of people would<br/>implement this redundantly, MINA could have it out of the box as well. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
First cut of proxy connector. Supports unauthenticated proxies and proxies with Basic
authentication.Still quite messy - needs some refactoring to work with IoC containers
properly.Tested with MINA 1.1. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Based on James work i hacked around and achieved working NTLM &amp; socks 4 &amp; 4a proxy
support<br/>But it still needs a lot of work : code cleaning, API reworking, socks 5 &amp;
digest support<br/>i'll keep sending infos on  progress made 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Due to personal events i've made less progress than expected.<br/>But Socks5 support is
now added and digest auth is currently in progress.<br/>Code still needs lot of workThe
problem is that it is hard to test the code as i have no dedicated network to test it. For
example, i've been unable to find a free proxy supporting Socks5 with GSSAPI
auth.<br/>Generally speaking i've been forced to use many different proxies because each
of them has a unique combination of auth methods.<br/>So i may need help on this, if some
of you could test the proxy program within their network it would help debbuging.Regarding
a previous comment on IOC containers, i've no idea on how to make code IoC friendly : i'll
accept any clue on this ;pAnother important point is that the code contains some basic
objects (HttpHeader, HttpResponse etc...) that i think should be refactored to use
AsyncWeb (not sure this is the official MINA http project ?) code<br/>WDYT ?That's all for
the moment<br/>Any comments or help is appreciated. 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Hi community,This is a great day (althought i spent 3 hours in the strike this morning
<img class="emoticon" src="https://issues.apache.org/jira/images/icons/emoticons/sad.png"
height="16" width="16" align="absmiddle" alt="" border="0"/> ...) <br/>as i'm proud to
announce after 4 months of work that <br/>i'm releasing a proxy support connector for MINA
2.0-M1.This release features :HTTP proxy : <ul class="alternate"
type="square">	<li>Support for NTLM authentication</li>	<li>Support for Digest
authentication</li>	<li>Transparent support for reconnection to a http proxy that does not
support connection keep alive</li>	<li>Support for HTTP/1.1 requests</li>	<li>Support for
multi valued headers</li>	<li>Configuration of prefered authentication
mechanism</li>	<li>Smart proxy authentication system that dynamically and automatically
selects the mechanism to use</li></ul>SOCKS :<ul class="alternate"
type="square">	<li>Support for SOCKS4 and SOCKS4a</li>	<li>Support for SOCKS5 with support
for GSSAPI authentication via Kerberos V</li></ul>Moreover i added some test classes and
junit testcases to test internals and <br/>cover most of the revelant functionnalities.I
hope this work will be usefull for the community as i put great efforts on it<br/>I'm
really excited by looking forward for your questions, comments, etc...Regards,<ul
class="alternate" type="square">	<li>Edouard De Oliveira -<br/><a
href="http://tedorg.free.fr/en/projects.php" class="external-link"
rel="nofollow">http://tedorg.free.fr/en/projects.php</a></li></ul> 
==============================

On issue key DIRMINA-415 the proxy pattern might have been discussed on the following comment: 
==============================
Source code updated to comply with MINA 2.0.0-M2 version.<br/>Some minor refactorings were
madeAdded a telnet test client : tested it by communicating with a SMTP server through a
http &amp; socks proxy. 
==============================

On issue key DIRMINA-495 the singleton pattern might have been discussed on the following comment: 
==============================
This is a better version.  It accepts Map&lt;?, ?&gt; rather than Map&lt;Object,Object&gt;
so the user can do Collections.singletonMap() without having to cast or qualify it. 
==============================

On issue key DIRMINA-495 the Proxy pattern might have been discussed on the following comment: 
==============================
I ran into a similar situation some time ago though I wanted to do more with the session
than add attributes. First I thought I could just use an IoFutureListener and access the
new session there. I soon realized that this wouldn't work since I needed my
IoFutureListener to be called before sessionCreate() on my IoHandler. There's no way to
guarantee that that happens in this order with MINA 1.x.I ended up with something
likeconnector.connect(address, new IoHandlerProxy(realIoHandler) {<br/>    public void
sessionCreated(IoSession session) {        // Do whatever it was I needed to do with the
session here        super.sessionCreated(session);    }}IoHandlerProxy is a simple custom
class which let's me intercept calls to the real IoHandler. I think you get the point.My
point here is that there may be other things than adding attributes one might want to do
before sessionCreated() is called. If connect() would take a ConnectCallback as an
argument the user could do whatever she wants before the IoHandler is called, not just add
attributes.ConnectCallback would be very similar to IoFutureListener so maybe we could use
that and connect() would automatically set the IoFutureListener on the ConnectFuture. In
that way it is guaranteed that the listener is called before the IoHandler is called.With
this it would be simple to add attributes to the session:connector.connect(add, new
IoFutureListener&lt;ConnectFuture&gt;() {<br/>    void operationComplete(ConnectFuture
future) {<br/>        if (future.isConnected()) {           
future.getSession().addAttribute(...);        }   }<br/>});We could still also add a
connect(addr, Map) method to IoConnector but it would be implemented like the above.WDYT? 
==============================

On issue key DIRMINA-495 the mediate pattern might have been discussed on the following comment: 
==============================
That seems reasonable - with a general callback you could cleanly add attributes.  BUT
we'd have to ensure that the callback is called <del>immediately</del> after the session
is created.  The regular ConnectFuture callback doesn't happen until the connect completes
- which is too late <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>So maybe a new "SessionFuture" type is
called for?Also the callback method should be allowed to throw exceptions.You could then
do this (which would meet the requirements of this issue):connector.connect(addr, new
IoFutureListener&lt;SessionFuture&gt;() {<br/>    void operationComplete(SessionFuture
future) {        future.getSession.setAttribute(MY_KEY, myVal);    }} 
==============================

On issue key DIRMINA-495 the chain pattern might have been discussed on the following comment: 
==============================
Works for me.  As long as it's definitely called before the sessionCreated() filter
chain/handler method <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-405 the mediate pattern might have been discussed, namely here: 
==============================
IoSession.suspendRead() doesn't suspend read operation immediately when
ProtocolCodecFilter is used. 
==============================

On issue key DIRMINA-546 the Adapter pattern might have been discussed on the following comment: 
==============================
The following test method:    @Test<br/>    public void mina() throws Exception {<br/>    
   SocketAcceptor acceptor = new NioSocketAcceptor();<br/>        acceptor.setHandler(new
IoHandlerAdapter());<br/>        acceptor.setDefaultLocalAddress(new
InetSocketAddress(8080));<br/>        acceptor.bind();        long start =
System.currentTimeMillis();<br/>        for (int i = 0; i &lt; 10000; i ++) {           
new Socket("127.0.0.1", 8080).close();        }        long end =
System.currentTimeMillis();<br/>        System.out.println(end - start);<br/>    }prints
out the following result:Before optimization - 38412<br/>After optimization 11212 
==============================

On issue key DIRMINA-439 the Factory pattern might have been discussed, namely here: 
==============================
DemuxingProtocolEncoder and DemuxingProtocolDecoder by refactoring
DemuxingProtocolCodecFactory 
==============================

On issue key DIRMINA-463 the Factory pattern might have been discussed on the following comment: 
==============================
1) Just checked in a fix for this. There are now MINA specific versions of
StateMachineFactory.<br/>2) Fixed!I'm not sure I like how 1) turned out. There are lots of
code duplication there. Maybe if we changed StateMachineFactory so that it isn't all
static like now and to obtain one you would always have to specifiy the annotations to be
used like so:StateMachineFactory.getInstance(IoHandlerTransition.class).create(...)We need
a way to couple IoHandlerTransition and IoHandlerTransitions together. I think we can use
a special annotation for that:@TransitionsCombiner(IoHandlerTransitions.class)<br/>public
interface @IoHandlerTransition {<br/>...<br/>}That way you won't have to specifiy both
IoHandlerTransition and IoHandlerTransitions in the call to getInstance(...).WDYT? 
==============================

On issue key DIRMINA-463 the Factory pattern might have been discussed on the following comment: 
==============================
&gt; We need a way to couple IoHandlerTransition and IoHandlerTransitions together. I
think we can use a special annotation for that:<br/>&gt;<br/>&gt;
@TransitionsCombiner(IoHandlerTransitions.class)<br/>&gt; public interface
@IoHandlerTransition {&gt; ...&gt; } Does this mean we apply the same technique to
IoFilterTransition(s) and Transition(s)?  Then it sounds great to me.  Probably we could
allow user to specify either annotation
class:StateMachineFactory.getInstance(IoHandlerTransition.class).create(...) =
StateMachineFactory.getInstance(IoHandlerTransitions.class).create(...)Does it make a
sense? 
==============================

On issue key DIRMINA-162 the builder pattern might have been discussed on the following comment: 
==============================
I think you're right on the issue with sessions being opened / closed. Main thing is that
only the higher level protocol (on top of UDP) can really determine the meaning of
a<br/>'session' in its very own context. It might be possible to design some kind of
protocol filter which implements generic session tracking on top of simple message
delivery by:<ul class="alternate" type="square">	<li>tracking received message from the
remote peer and fire off a sessionOpened() event BEFORE passing the message onto the next
filter in the chain</li>	<li>implement a timeout-based mechanism that tracks the data
messages passing through and closes the session if the timeout passes by (including firing
the event)<br/>But it does not seem feasible to implement this as a generic behauviour of
the datagram acceptor (as there are protocol which do not have the concept of a session at
all)</li></ul>But I do think that it is a bug in the implementation of the datagram
acceptor if it does not assembly the filter chains when the individual session get create.
I understand that it is currently needed ot create a session per received message but it
should then assemble the filter chain per session as one should expect from the
documentation. It would then be <br/>necessary to document this as an user might need to
take special precautions in this chain builder implementation. 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
I think you're right on the issue with sessions being opened / closed. Main thing is that
only the higher level protocol (on top of UDP) can really determine the meaning of
a<br/>'session' in its very own context. It might be possible to design some kind of
protocol filter which implements generic session tracking on top of simple message
delivery by:<ul class="alternate" type="square">	<li>tracking received message from the
remote peer and fire off a sessionOpened() event BEFORE passing the message onto the next
filter in the chain</li>	<li>implement a timeout-based mechanism that tracks the data
messages passing through and closes the session if the timeout passes by (including firing
the event)<br/>But it does not seem feasible to implement this as a generic behauviour of
the datagram acceptor (as there are protocol which do not have the concept of a session at
all)</li></ul>But I do think that it is a bug in the implementation of the datagram
acceptor if it does not assembly the filter chains when the individual session get create.
I understand that it is currently needed ot create a session per received message but it
should then assemble the filter chain per session as one should expect from the
documentation. It would then be <br/>necessary to document this as an user might need to
take special precautions in this chain builder implementation. 
==============================

On issue key DIRMINA-162 the strategy pattern might have been discussed on the following comment: 
==============================
This is a great idea.  We could provide a generic session tracking strategy interface so
users can choose their favorite session management method.  For instance:/** A kind of
cache? */<br/>public interface ConnectionlessSessionTracker {<br/>    /**<ul>	<li>@return
null if no session is found<br/>     */<br/>    IoSession getSession( SocketAddress
localAddress, SocketAddress remoteAddress );<br/>}</li></ul>WDYT? 
==============================

On issue key DIRMINA-162 the facade pattern might have been discussed on the following comment: 
==============================
I already approached this but I found out that it will not work without a acceptor facade
which encapsulates the "real" datagram acceptor and does the session tarcking on behalf
of<br/>the client. This thing is in fact second-next on my to-do list for my current
project. <br/>Once this facade works, it can easily implement the proposed tracker
interface. If it works, I will supply my implementation as a diff to mina-0.9.0 
==============================

On issue key DIRMINA-162 the strategy pattern might have been discussed on the following comment: 
==============================
Here's my first stab at fixing this. Could somebody please review it? I haven't touched
the MINA code before just tonight <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>The attached diff is against svn revision
440993, the current trunk at this time.Basically, you can implement the methods	void
sessionCreated(IoSession session);<br/>	IoSession getSession(SocketAddress localAddress,
SocketAddress remoteAddress);in a ConnectionlessSessionTracker, and assign that to a
DatagramSessionConfig. From then on, the tracker will perform session management for the
transport.The only current problem is that the session cannot be retrieved until the
remote socket address is known. In DatagramChannel, this happen upon read, so the session
cannot be queried for its read buffer size. I think it should still be the same, but once
again, please review it.Here is also a testing version of a ConnectionlessSessionTracker
(don't use, it doesn't expire or do anything advanced enough):import
java.net.InetSocketAddress;<br/>import java.net.SocketAddress;<br/>import
java.util.HashMap;<br/>import java.util.Map;import
org.apache.mina.common.ConnectionlessSessionTracker;<br/>import
org.apache.mina.common.IoSession;public class TestSessionTracker implements
ConnectionlessSessionTracker<br/>{<br/>	private Map&lt;String, IoSession&gt; sessionMap =
new HashMap&lt;String, IoSession&gt;();	public IoSession getSession(SocketAddress
localAddress, SocketAddress remoteAddress)	{		InetSocketAddress localIsa =
(InetSocketAddress) localAddress;		InetSocketAddress remoteIsa = (InetSocketAddress)
remoteAddress;		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		return
sessionMap.get(key);	}	public void sessionCreated(IoSession
session)<br/>	{<br/>		InetSocketAddress localIsa = (InetSocketAddress)
session.getLocalAddress();<br/>		InetSocketAddress remoteIsa = (InetSocketAddress)
session.getRemoteAddress();		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		if
(!sessionMap.containsKey(key))		{			sessionMap.put(key, session);		}	}<br/>}I imagine that
by integrating iofilters that know of the session tracker, etc you could implement just
about any session management strategy.Let me know what you think! 
==============================

On issue key DIRMINA-162 the Builder pattern might have been discussed on the following comment: 
==============================
Here's my first stab at fixing this. Could somebody please review it? I haven't touched
the MINA code before just tonight <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>The attached diff is against svn revision
440993, the current trunk at this time.Basically, you can implement the methods	void
sessionCreated(IoSession session);<br/>	IoSession getSession(SocketAddress localAddress,
SocketAddress remoteAddress);in a ConnectionlessSessionTracker, and assign that to a
DatagramSessionConfig. From then on, the tracker will perform session management for the
transport.The only current problem is that the session cannot be retrieved until the
remote socket address is known. In DatagramChannel, this happen upon read, so the session
cannot be queried for its read buffer size. I think it should still be the same, but once
again, please review it.Here is also a testing version of a ConnectionlessSessionTracker
(don't use, it doesn't expire or do anything advanced enough):import
java.net.InetSocketAddress;<br/>import java.net.SocketAddress;<br/>import
java.util.HashMap;<br/>import java.util.Map;import
org.apache.mina.common.ConnectionlessSessionTracker;<br/>import
org.apache.mina.common.IoSession;public class TestSessionTracker implements
ConnectionlessSessionTracker<br/>{<br/>	private Map&lt;String, IoSession&gt; sessionMap =
new HashMap&lt;String, IoSession&gt;();	public IoSession getSession(SocketAddress
localAddress, SocketAddress remoteAddress)	{		InetSocketAddress localIsa =
(InetSocketAddress) localAddress;		InetSocketAddress remoteIsa = (InetSocketAddress)
remoteAddress;		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		return
sessionMap.get(key);	}	public void sessionCreated(IoSession
session)<br/>	{<br/>		InetSocketAddress localIsa = (InetSocketAddress)
session.getLocalAddress();<br/>		InetSocketAddress remoteIsa = (InetSocketAddress)
session.getRemoteAddress();		String key = new
StringBuilder(localIsa.toString()).append(remoteIsa.toString()).toString();		if
(!sessionMap.containsKey(key))		{			sessionMap.put(key, session);		}	}<br/>}I imagine that
by integrating iofilters that know of the session tracker, etc you could implement just
about any session management strategy.Let me know what you think! 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
Attached is the next version with IoSessionRecycler per Trustin's and my comments. I still
am not sure about the read buffer size issue (marked by a TODO in the code). Also, after
some thought I don't think this is applicable to transports with connections (seems like
too much abstraction, and doesn't fit well with the MINA session paradigm).I also added a
default implementation, ExpiringSessionRecycler, which uses an ExpiringMap to recycle
sessions. It also calls sessionClosed on the session's filterchain when a session
expires.I hope this helps! I definitely want to contribute something nice that will speed
MINA along to 1.0 <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>Let me know what you think! 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
Minor change to build filter chain only when a session isn't recycled (save some clocks
<img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
And, in an astounding extra $0.02, I also wanted to remind you to update the IoHandler
javadoc since it indicates that sessionOpened/etc will not be called for UDP. I'd also
like to put out there that sessionCreated could be called on the session's filter chain
when it is first created (before sessionOpened), this would make all MINA events
applicable to the UDP transport. I know it doesn't really mean anything different, but it
might be the least surprise to the user.And on that note, I'm going to go do something
else for a while so I don't think of anything else to spam the mailing list with updates
about <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-162 the chain pattern might have been discussed on the following comment: 
==============================
No problem, happy to lend a hand <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> MINA makes my work easier, so it's more
than a fair trade.I can get to patching the remaining stuff (IoHandler, defaulting to
ExpiringSessionRecycler) within the next couple of days or so. I agree that
ExpiringSessionRecycler should be the default now that I think about all the events flying
around the filter chain with NOOP, and starting the expiration after the first put is a
good compromise. Nice to have util-concurrent for that, since a double check lock is
actually thread-safe with ReentrantReadWriteLock.Do you want me to add an IdentityHashMap
for session lookup? It would mean extra synchronization, and it would affect only the
'remove(IoSession)' method AFAIK. Are the costs to generate the key high enough to justify
that? 
==============================

On issue key DIRMINA-162 the  state  pattern might have been discussed on the following comment: 
==============================
Yargh. In this one (v7), I do the lock upgrade correctly in the startExpiringIfNotStarted
method of ExpiringMap. Sorry 'bout that. Somebody may want to refactor that state locking
code to some common class, cause it would minimize the chances to create bugs like that
<img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-176 the  state  pattern might have been discussed on the following comment: 
==============================
I'd like time out for ByteBuffers too, it is all we need.To implement application
specified strategies of pooling there will be the JMX support <a
href="https://issues.apache.org/jira/browse/DIRMINA-29" title="JMX integration"
class="issue-link" data-issue-key="DIRMINA-29"><del>DIRMINA-29</del></a>.<br/>With the JMX
we could monitor and manage the pool state for user-defined strategies. 
==============================

On issue key DIRMINA-176 the strategy pattern might have been discussed on the following comment: 
==============================
Retaining smaller buffers can also cause a problem depending on an application's memory
usage characterstics.  What about providing both strategy at the same time? 
==============================

On issue key DIRMINA-176 the command pattern might have been discussed on the following comment: 
==============================
Yes, but, by the pool point of view, what is regarded as a smaller buffer and a bigger
buffer? Supposing to have an application that uses 30 byte buffers and occasionally some
2kb buffers (this is the case of one of the ones I'm working on now), the pool would have
serious problems to understand which ones are "smaller" and "bigger", since all of them
are of the smallest or biggest size available.In this case not to cache smallest and
biggest buffer is a problem, and to limit the maximum size would certainly not be an
improvement.But many low-level byte protocols use short fixed lenght packets for "command"
messages and use long variable lenght packets for "transport" messages, so my case is a
common case.I think what you're suggesting is very good for protocols which use many
different-sized buffers, and should therefore be implemented, but we should also let users
chose whether to use it or not.In the overload control, we should also think about
interrupting  the work when the memory limit of the pool is exceeded, in order to permit
the application to flush and release the buffers that haven't been written yet. 
==============================

On issue key DIRMINA-176 the factory pattern might have been discussed on the following comment: 
==============================
This jakarta api seems to be the right solution, we can do a GenericObjectPool for each
buffer size, at the same way we mantain multiple stacks now.<br/>This api provides the
timeout we thought, it provides also the method that block if the objects are not
available (in case we are over the maximum size of the pool, and we cannot allocate other
buffers).<br/>We have to define better some things, but it looks great to me.One thing is
the following: in this jakarta pool the new objects are provided by a factory that
allocate all the objects equals. So for each partition we will be obliged to allocate only
one kind of buffer, the higher size buffer of the partition, right? I'm not so good with
english, so I hope I have well explained my doubt. 
==============================

On issue key DIRMINA-187 the Factory pattern might have been discussed on the following comment: 
==============================
This solution looks a little bit complicated IMHO.  What do you think about this:interface
IoHandlerFactory<br/>{<br/>    IoHandler getHandler( IoSession session );<br/>}interface
IoAcceptor<br/>{<br/>    void bind( SocketAddress address, IoHandler handler ); // one
handler handles multiple sessions<br/>    void bind( SocketAddress address,
IoHandlerFactory handlerFactory ); // multiple handler handler multiple sessions<br/>   
void bind( SocketAddress address, Class&lt;IoHandler&gt; handlerClass ); // multiple
handler multiple sessions, handlerClass is instantiated whenever a new session is
created.<br/>}&lt;usage 1&gt;class MyHandlerFactory implements IoHandlerFactory<br/>{<br/>
   IoHandler getHandler( IoSession session )    {        return new MyHandler();  //
MyHandler implements IoHandler    }}acceptor.bind( ..., new MyHandlerFactory() );&lt;usage
2&gt;<br/>acceptor.bind(..., MyHandler.class);This will seamlessly integrate per-session
handlers retaining backward compatibility. 
==============================

On issue key DIRMINA-187 the Factory pattern might have been discussed on the following comment: 
==============================
The third option that takes a class should be an IoHandlerFactory that the project
supplies, not a separate method. 
==============================

On issue key DIRMINA-187 the Adapter pattern might have been discussed on the following comment: 
==============================
I'm a bit confused about the following code inside SingleSessionIoHandlerAdapter class:   
public void sessionClosed() throws Exception     {        SessionUtil.initialize(
getSession() );    }Shouldn't this code be placed inside the sessionCreated() method? 
==============================

On issue key DIRMINA-755 the mediate pattern might have been discussed on the following comment: 
==============================
Ok, I'm clearly able to reproduce the lock, and I think I can explain what's going on.In
your client, you close the session waiting for all the messages to be processed before the
closure. So far, so good.You get back a CloseFuture, and you associate a listener to it,
which get called immediately after the last message has been processed. In this listener,
you have this method :            public void operationComplete(IoFuture future) {        
       System.out.println("managed session count=" + connector.getManagedSessionCount()); 
              System.out.println("Disposing connector ...");               
connector.dispose();                System.out.println("Disposing connector ...
*finished*");            }The problem here is that this listener will be called in a
thread, and then the dispose() method will be called, using the very same thread. As the
dispose() will create internally a DisposalFuture, which waits until the internal 'ready'
flag is set to true by another thread, it will wait forever just because no thread will be
here to flip the flag to true.You can fix this by simply moving the dispose() out of the
listener :<br/>...<br/>        // Get the close future for this session<br/>       
CloseFuture closeFuture = cf.getSession().getCloseFuture();       
closeFuture.addListener((IoFutureListener&lt;?&gt;) new IoFutureListener&lt;IoFuture&gt;()
{            @Override<br/>            public void operationComplete(IoFuture future) {   
            System.out.println("managed session count=" +
connector.getManagedSessionCount());            }        });        // wait for session
close and then dispose the connector<br/>        System.out.println( "Closing the
session..." );<br/>        closeFuture.getSession().close(false);       
System.out.println( "Waiting for the session to be closed..." );<br/>       
closeFuture.awaitUninterruptibly();<br/>        System.out.println( "Session closed !!!"
);        System.out.println("Disposing connector ...");<br/>       
connector.dispose();<br/>        System.out.println("Disposing connector ...
<b>finished</b>");<br/>}FYI, I have also called the close() method after having grabbed
the CloseFuture and affected the listener to it.Just tell me if this fix your problem. 
==============================

On issue key DIRMINA-755 the iterate pattern might have been discussed on the following comment: 
==============================
Ok, it took me a hell of a time to understand what's going on.Basically, in 2.0-M6, the
dispose() called in the listener works because we wait until a timeout is reached. We use
a DEAD_LOCK_CHECK_INTERVAL delay (5 seconds) and we iterate until either the 'ready' flag
is swapped to true (it never happens) or until we have reached a timemout, which is set to
MAX_LONG in this very case.In M6, the code looks like : <br/>    long endTime =
System.currentTimeMillis() + timeoutMillis;<br/>    ...<br/>    if (endTime &lt;
System.currentTimeMillis()) {        return ready;    }When timeoutMillis == MAX_LONG,
it's easy to realize that we exit just because endTime is always &lt; 0 !I fixed this bug
in <a href="http://svn.apache.org/viewvc?view=revision&amp;revision=713708"
class="external-link"
rel="nofollow">http://svn.apache.org/viewvc?view=revision&amp;revision=713708</a> (14
months ago ...) and then in <a
href="http://svn.apache.org/viewvc?view=revision&amp;revision=781711"
class="external-link"
rel="nofollow">http://svn.apache.org/viewvc?view=revision&amp;revision=781711</a> (7
months ago) by adding these lines :+        if (endTime &lt; 0) {+            endTime =
Long.MAX_VALUE;+        }So now, the wait() never exists from the loop, thus the
hang...Now, we have to find a way to get out of this loop the normal way... 
==============================

On issue key DIRMINA-495 the singleton pattern might have been discussed on the following comment: 
==============================
This is a better version.  It accepts Map&lt;?, ?&gt; rather than Map&lt;Object,Object&gt;
so the user can do Collections.singletonMap() without having to cast or qualify it. 
==============================

On issue key DIRMINA-495 the Proxy pattern might have been discussed on the following comment: 
==============================
I ran into a similar situation some time ago though I wanted to do more with the session
than add attributes. First I thought I could just use an IoFutureListener and access the
new session there. I soon realized that this wouldn't work since I needed my
IoFutureListener to be called before sessionCreate() on my IoHandler. There's no way to
guarantee that that happens in this order with MINA 1.x.I ended up with something
likeconnector.connect(address, new IoHandlerProxy(realIoHandler) {<br/>    public void
sessionCreated(IoSession session) {        // Do whatever it was I needed to do with the
session here        super.sessionCreated(session);    }}IoHandlerProxy is a simple custom
class which let's me intercept calls to the real IoHandler. I think you get the point.My
point here is that there may be other things than adding attributes one might want to do
before sessionCreated() is called. If connect() would take a ConnectCallback as an
argument the user could do whatever she wants before the IoHandler is called, not just add
attributes.ConnectCallback would be very similar to IoFutureListener so maybe we could use
that and connect() would automatically set the IoFutureListener on the ConnectFuture. In
that way it is guaranteed that the listener is called before the IoHandler is called.With
this it would be simple to add attributes to the session:connector.connect(add, new
IoFutureListener&lt;ConnectFuture&gt;() {<br/>    void operationComplete(ConnectFuture
future) {<br/>        if (future.isConnected()) {           
future.getSession().addAttribute(...);        }   }<br/>});We could still also add a
connect(addr, Map) method to IoConnector but it would be implemented like the above.WDYT? 
==============================

On issue key DIRMINA-495 the mediate pattern might have been discussed on the following comment: 
==============================
That seems reasonable - with a general callback you could cleanly add attributes.  BUT
we'd have to ensure that the callback is called <del>immediately</del> after the session
is created.  The regular ConnectFuture callback doesn't happen until the connect completes
- which is too late <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>So maybe a new "SessionFuture" type is
called for?Also the callback method should be allowed to throw exceptions.You could then
do this (which would meet the requirements of this issue):connector.connect(addr, new
IoFutureListener&lt;SessionFuture&gt;() {<br/>    void operationComplete(SessionFuture
future) {        future.getSession.setAttribute(MY_KEY, myVal);    }} 
==============================

On issue key DIRMINA-495 the chain pattern might have been discussed on the following comment: 
==============================
Works for me.  As long as it's definitely called before the sessionCreated() filter
chain/handler method <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-616 the command pattern might have been discussed on the following comment: 
==============================
It does not work... The 2.2-beta63-SNAPSHOT does not exist anywhere ... (skipped some rude
sentences about maven ...)<span class="error">&#91;INFO&#93;</span> A required plugin was
not found: Plugin could not be found - check that the goal name is correct: Unable to
download the artifact from any repositoryTry downloading the file manually from the
project website.Then, install it using the command: <br/>    mvn install:install-file
-DgroupId=org.apache.maven.plugins -DartifactId=maven-assembly-plugin
-Dversion=2.2-beta-3-SNAPSHOT -Dpackaging=maven-plugin -Dfile=/path/to/fileAlternatively,
if you host your own repository you can deploy the file there: <br/>    mvn
deploy:deploy-file -DgroupId=org.apache.maven.plugins -DartifactId=maven-assembly-plugin
-Dversion=2.2-beta-3-SNAPSHOT -Dpackaging=maven-plugin -Dfile=/path/to/file -Durl=<span
class="error">&#91;url&#93;</span> -DrepositoryId=<span class="error">&#91;id&#93;</span> 
org.apache.maven.plugins:maven-assembly-plugin:maven-plugin:2.2-beta-3-SNAPSHOTfrom the
specified remote repositories:<br/>  central (<a href="http://repo1.maven.org/maven2"
class="external-link" rel="nofollow">http://repo1.maven.org/maven2</a>) 
org.apache.maven.plugins:maven-assembly-plugin:maven-plugin:2.2-beta-3-SNAPSHOTfrom the
specified remote repositories:<br/>  central (<a href="http://repo1.maven.org/maven2"
class="external-link" rel="nofollow">http://repo1.maven.org/maven2</a>) 
==============================

On issue key DIRMINA-456 the Adapter pattern might have been discussed on the following comment: 
==============================
Good call Heath .  You were spot on with everything running in the same thread.  (Cool
name BTW. <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> )Consider the following example:	public
static void main(String[] args) throws IOException {<br/>		NioSocketAcceptor acceptor =
new
NioSocketAcceptor(Executors.newCachedThreadPool());<br/>		acceptor.getFilterChain().addLast("executor",
new ExecutorFilter(Executors.newCachedThreadPool()));<br/>		acceptor.setHandler(new
IoHandlerAdapter() {<br/>			@Override<br/>			public void messageReceived(IoSession
session, Object message) throws Exception {				session.write(IoBuffer.wrap("Have a nice
day\n".getBytes()));				Thread.sleep(2000);				session.write(IoBuffer.wrap("MINA makes me
happy\n".getBytes()));				Thread.sleep(2000);				session.write(IoBuffer.wrap("I like cold
beverages\n".getBytes()));			}		});<br/>		acceptor.setLocalAddress(new
InetSocketAddress(1995));<br/>		acceptor.bind();<br/>	}The above code works just fine.  If
you comment out the executor filter, all the writes are done at once after waiting 4000ms.
 This make sense because the messageReceived is being executed in the I/O thread.However,
if you comment out the executor filter and then append .awaitUninterruptibly(), the server
stalls indefinitely.So the question is, do we put something in the await methods that
checks to see if the await is being called in the I/O thread the await is dependent on and
throw a dead-lock exception?  Is there away that we can execute the desired action from
the await methods instead of blocking in this case? 
==============================

On issue key DIRMINA-456 the Chain pattern might have been discussed on the following comment: 
==============================
Good call Heath .  You were spot on with everything running in the same thread.  (Cool
name BTW. <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> )Consider the following example:	public
static void main(String[] args) throws IOException {<br/>		NioSocketAcceptor acceptor =
new
NioSocketAcceptor(Executors.newCachedThreadPool());<br/>		acceptor.getFilterChain().addLast("executor",
new ExecutorFilter(Executors.newCachedThreadPool()));<br/>		acceptor.setHandler(new
IoHandlerAdapter() {<br/>			@Override<br/>			public void messageReceived(IoSession
session, Object message) throws Exception {				session.write(IoBuffer.wrap("Have a nice
day\n".getBytes()));				Thread.sleep(2000);				session.write(IoBuffer.wrap("MINA makes me
happy\n".getBytes()));				Thread.sleep(2000);				session.write(IoBuffer.wrap("I like cold
beverages\n".getBytes()));			}		});<br/>		acceptor.setLocalAddress(new
InetSocketAddress(1995));<br/>		acceptor.bind();<br/>	}The above code works just fine.  If
you comment out the executor filter, all the writes are done at once after waiting 4000ms.
 This make sense because the messageReceived is being executed in the I/O thread.However,
if you comment out the executor filter and then append .awaitUninterruptibly(), the server
stalls indefinitely.So the question is, do we put something in the await methods that
checks to see if the await is being called in the I/O thread the await is dependent on and
throw a dead-lock exception?  Is there away that we can execute the desired action from
the await methods instead of blocking in this case? 
==============================

On issue key DIRMINA-231 the adapt pattern might have been discussed on the following comment: 
==============================
Attaching ConnectingTest which shows problem using VmPipes as well (adapted from <a
href="http://issues.apache.org/jira/secure/attachment/20356/ConnectionTest.java"
class="external-link"
rel="nofollow">http://issues.apache.org/jira/secure/attachment/20356/ConnectionTest.java</a>). 
==============================

On issue key DIRMINA-231 the chain pattern might have been discussed on the following comment: 
==============================
Warning - running attached ConnectionTest may bring your machine to its knees!The
PooledThreadModel which is used by the default configuration creates a new
ThreadPoolFilter which is what is creating these wayward threads. I don't think the
destroy method of this filter ever gets called. If the PooledThreadModel used a
ReferenceCountingIoFilter to wrap the ThreadPoolFilter before adding it to the chain then
would destroy be called? 
==============================

On issue key DIRMINA-231 the  state  pattern might have been discussed on the following comment: 
==============================
To shut them down you will have to call destory() on the
ThreadPoolFilter:session.getFilterChain().get(PooledThreadModel.class.getName()).destroy();or
you create your own ThreadModel which wraps the ThreadPoolFilter in a
ReferenceCountingIoFilter instance.If you weren't using a ThreadPoolFilter with MINA 0.8
and you want the same behaviour with MINA 0.9 you must specify the ThreadModel.MANUAL
thread model as you suggest in <a href="http://www.quickfixj.org/jira/browse/QFJ-34"
class="external-link" rel="nofollow">http://www.quickfixj.org/jira/browse/QFJ-34</a>.If
you use the default config each connection will get its own thread pool. The threads in
the pool (these are named AnonymousIoService-x-y by default) will by default be terminated
after 1 minute of inactivity. If the threads do hang around for more than 1 minute that
would be a bug. In QFJ-34 you state that the Anonymous... threads never die off so there
may very well be a bug here.Is there anyway you could refactor your code to use a single
shared connector? Or use a shared ThreadPoolFilter (use MANUAL and add your own
ThreadPoolFilter to each connectors filter chain)? I think this is more "in tune" with how
MINA is supposed to be used. 
==============================

On issue key DIRMINA-231 the chain pattern might have been discussed on the following comment: 
==============================
To shut them down you will have to call destory() on the
ThreadPoolFilter:session.getFilterChain().get(PooledThreadModel.class.getName()).destroy();or
you create your own ThreadModel which wraps the ThreadPoolFilter in a
ReferenceCountingIoFilter instance.If you weren't using a ThreadPoolFilter with MINA 0.8
and you want the same behaviour with MINA 0.9 you must specify the ThreadModel.MANUAL
thread model as you suggest in <a href="http://www.quickfixj.org/jira/browse/QFJ-34"
class="external-link" rel="nofollow">http://www.quickfixj.org/jira/browse/QFJ-34</a>.If
you use the default config each connection will get its own thread pool. The threads in
the pool (these are named AnonymousIoService-x-y by default) will by default be terminated
after 1 minute of inactivity. If the threads do hang around for more than 1 minute that
would be a bug. In QFJ-34 you state that the Anonymous... threads never die off so there
may very well be a bug here.Is there anyway you could refactor your code to use a single
shared connector? Or use a shared ThreadPoolFilter (use MANUAL and add your own
ThreadPoolFilter to each connectors filter chain)? I think this is more "in tune" with how
MINA is supposed to be used. 
==============================

On issue key DIRMINA-231 the Chain pattern might have been discussed on the following comment: 
==============================
To shut them down you will have to call destory() on the
ThreadPoolFilter:session.getFilterChain().get(PooledThreadModel.class.getName()).destroy();or
you create your own ThreadModel which wraps the ThreadPoolFilter in a
ReferenceCountingIoFilter instance.If you weren't using a ThreadPoolFilter with MINA 0.8
and you want the same behaviour with MINA 0.9 you must specify the ThreadModel.MANUAL
thread model as you suggest in <a href="http://www.quickfixj.org/jira/browse/QFJ-34"
class="external-link" rel="nofollow">http://www.quickfixj.org/jira/browse/QFJ-34</a>.If
you use the default config each connection will get its own thread pool. The threads in
the pool (these are named AnonymousIoService-x-y by default) will by default be terminated
after 1 minute of inactivity. If the threads do hang around for more than 1 minute that
would be a bug. In QFJ-34 you state that the Anonymous... threads never die off so there
may very well be a bug here.Is there anyway you could refactor your code to use a single
shared connector? Or use a shared ThreadPoolFilter (use MANUAL and add your own
ThreadPoolFilter to each connectors filter chain)? I think this is more "in tune" with how
MINA is supposed to be used. 
==============================

On issue key DIRMINA-380 the chain pattern might have been discussed, namely here: 
==============================
Invocation chaining for IoFuture 
==============================

On issue key DIRMINA-269 the proxy pattern might have been discussed on the following comment: 
==============================
This kind of functionality maybe also needed in a proxy server where the connection to the
proxied server should be closed if the proxy client is closing the connection. 
==============================

On issue key DIRMINA-608 the strategy pattern might have been discussed on the following comment: 
==============================
Attached is a first proposal, please take a look. I'd like to see if there's any initial
feedback now, and I'll work up a more extensive patch the coming weeks before M3 is
released.Open issues:<ul class="alternate" type="square">	<li>should maybe leave the
methodes on the IoService interface for the next milestone, marked deprecated, and don't
remove them until 2.0 final.</li></ul><ul class="alternate" type="square">	<li>interface
naming is open to debate (e.g. the current naming scheme doesn't really allow the same
interfaces to be used for IoSession statistics).</li></ul><ul class="alternate"
type="square">	<li>location of the lastReadTime() / lastWriteTime() / lastIoTime() methods
is open to debate.</li></ul><ul class="alternate" type="square">	<li>to keep the impact of
this first patch low, I just made AbstractIoService implement the statistics interfaces,
rather than factoring them into inner classes. (separation of concerns, high cohesion,
etc.) Factoring them into separate classes gives the ability to deploy those instances
into an MBeanServer, which I think is a big reason to make that change. Not all
application servers use the standard MBeanServer (at least historically; Java 5 may have
changed that) and JMX+OSGi isn't always straightforward, so the actual MBean deployment
should be handled by a pluggable strategy implementation.</li></ul><ul class="alternate"
type="square">	<li>I haven't touched the IoSession statistics yet, but the basic idea is
the same.</li></ul><ul class="alternate" type="square">	<li>anything
else?</li></ul>Thanks,Barend 
==============================

On issue key DIRMINA-375 the Chain pattern might have been discussed on the following comment: 
==============================
First of all, thank you very much Brad for excellent idea and contribution!  Literally
cool! <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/biggrin.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>I think Brad's patch can be easily
integrated into IoSession; IoSession could have a read() method that returns
ReadFuture:<ul>	<li>Object m = session.read().await(10000).getMessage(); // Returns null
unless received within 10 sec.</li>	<li>Object m =
session.read(10000).await().getMessage(); // Throws exception unless received within 10
sec.</li></ul>This could be implemented by adding a queue of ReadFutures to IoSession and
modifying DefaultIoFilterChain to poll the ReadFuture and give notification for each
messageReceived event.  By utilizing existing facilities that IoSession and MINA provides,
the amount of change could become much smaller.Possible list of thrown exceptions would
be:<ul>	<li>EOFException - if the session is closed.</li>	<li>SocketTimeoutException - on
timeout</li></ul>One problem is that these exceptions are not a RuntimeIoException.  We
could create DisconnectionException and ReadTimeoutException that extend
RuntimeIoException though.WDYT everyone? 
==============================

On issue key DIRMINA-375 the  state  pattern might have been discussed on the following comment: 
==============================
+1I really like the idea of having an IoSession.read() method that returns a ReadFuture so
that you can block and/or register a IoFutureListener that handles the next message
received.  This would greatly simplify so much of the state management we currently have
to do in our IoHandler's.Let me know where I can help with integrating this into trunk. 
==============================

On issue key DIRMINA-473 the Chain pattern might have been discussed on the following comment: 
==============================
Hi Trustin,I'm unfortunately still getting the
exception.-RogerException:<br/>java.lang.IllegalStateException: sessionBufferSize:
-696<br/>       at
org.apache.mina.filter.traffic.ReadThrottleFilter.exit(ReadThrottleFilter.java:493)<br/>  
    at
org.apache.mina.filter.traffic.ReadThrottleFilter.messageReceived(ReadThrottleFilter.java:347)<br/>
      at
org.apache.mina.common.DefaultIoFilterChain.callNextMessageReceived(DefaultIoFilterChain.java:399)<br/>
      at
org.apache.mina.common.DefaultIoFilterChain.access$1200(DefaultIoFilterChain.java:38)<br/>
      at
org.apache.mina.common.DefaultIoFilterChain$EntryImpl$1.messageReceived(DefaultIoFilterChain.java:791)<br/>
      at org.apache.mina.common.IoFilterEvent.fire(IoFilterEvent.java:54)<br/>       at
org.apache.mina.common.IoEvent.run(IoEvent.java:62)<br/>       at
java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:885)<br/>  
    at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)<br/>      
at java.lang.Thread.run(Thread.java:619) 
==============================

On issue key DIRMINA-495 the singleton pattern might have been discussed on the following comment: 
==============================
This is a better version.  It accepts Map&lt;?, ?&gt; rather than Map&lt;Object,Object&gt;
so the user can do Collections.singletonMap() without having to cast or qualify it. 
==============================

On issue key DIRMINA-495 the Proxy pattern might have been discussed on the following comment: 
==============================
I ran into a similar situation some time ago though I wanted to do more with the session
than add attributes. First I thought I could just use an IoFutureListener and access the
new session there. I soon realized that this wouldn't work since I needed my
IoFutureListener to be called before sessionCreate() on my IoHandler. There's no way to
guarantee that that happens in this order with MINA 1.x.I ended up with something
likeconnector.connect(address, new IoHandlerProxy(realIoHandler) {<br/>    public void
sessionCreated(IoSession session) {        // Do whatever it was I needed to do with the
session here        super.sessionCreated(session);    }}IoHandlerProxy is a simple custom
class which let's me intercept calls to the real IoHandler. I think you get the point.My
point here is that there may be other things than adding attributes one might want to do
before sessionCreated() is called. If connect() would take a ConnectCallback as an
argument the user could do whatever she wants before the IoHandler is called, not just add
attributes.ConnectCallback would be very similar to IoFutureListener so maybe we could use
that and connect() would automatically set the IoFutureListener on the ConnectFuture. In
that way it is guaranteed that the listener is called before the IoHandler is called.With
this it would be simple to add attributes to the session:connector.connect(add, new
IoFutureListener&lt;ConnectFuture&gt;() {<br/>    void operationComplete(ConnectFuture
future) {<br/>        if (future.isConnected()) {           
future.getSession().addAttribute(...);        }   }<br/>});We could still also add a
connect(addr, Map) method to IoConnector but it would be implemented like the above.WDYT? 
==============================

On issue key DIRMINA-495 the mediate pattern might have been discussed on the following comment: 
==============================
That seems reasonable - with a general callback you could cleanly add attributes.  BUT
we'd have to ensure that the callback is called <del>immediately</del> after the session
is created.  The regular ConnectFuture callback doesn't happen until the connect completes
- which is too late <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>So maybe a new "SessionFuture" type is
called for?Also the callback method should be allowed to throw exceptions.You could then
do this (which would meet the requirements of this issue):connector.connect(addr, new
IoFutureListener&lt;SessionFuture&gt;() {<br/>    void operationComplete(SessionFuture
future) {        future.getSession.setAttribute(MY_KEY, myVal);    }} 
==============================

On issue key DIRMINA-495 the chain pattern might have been discussed on the following comment: 
==============================
Works for me.  As long as it's definitely called before the sessionCreated() filter
chain/handler method <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> 
==============================

On issue key DIRMINA-623 the proxy pattern might have been discussed, namely here: 
==============================
Failure of test org.apache.mina.proxy.NTLMTest.testType1Message on windows Vista 
==============================

On issue key DIRMINA-405 the mediate pattern might have been discussed, namely here: 
==============================
IoSession.suspendRead() doesn't suspend read operation immediately when
ProtocolCodecFilter is used. 
==============================

On issue key DIRMINA-473 the Chain pattern might have been discussed on the following comment: 
==============================
Hi Trustin,I'm unfortunately still getting the
exception.-RogerException:<br/>java.lang.IllegalStateException: sessionBufferSize:
-696<br/>       at
org.apache.mina.filter.traffic.ReadThrottleFilter.exit(ReadThrottleFilter.java:493)<br/>  
    at
org.apache.mina.filter.traffic.ReadThrottleFilter.messageReceived(ReadThrottleFilter.java:347)<br/>
      at
org.apache.mina.common.DefaultIoFilterChain.callNextMessageReceived(DefaultIoFilterChain.java:399)<br/>
      at
org.apache.mina.common.DefaultIoFilterChain.access$1200(DefaultIoFilterChain.java:38)<br/>
      at
org.apache.mina.common.DefaultIoFilterChain$EntryImpl$1.messageReceived(DefaultIoFilterChain.java:791)<br/>
      at org.apache.mina.common.IoFilterEvent.fire(IoFilterEvent.java:54)<br/>       at
org.apache.mina.common.IoEvent.run(IoEvent.java:62)<br/>       at
java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:885)<br/>  
    at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)<br/>      
at java.lang.Thread.run(Thread.java:619) 
==============================

On issue key DIRMINA-608 the strategy pattern might have been discussed on the following comment: 
==============================
Attached is a first proposal, please take a look. I'd like to see if there's any initial
feedback now, and I'll work up a more extensive patch the coming weeks before M3 is
released.Open issues:<ul class="alternate" type="square">	<li>should maybe leave the
methodes on the IoService interface for the next milestone, marked deprecated, and don't
remove them until 2.0 final.</li></ul><ul class="alternate" type="square">	<li>interface
naming is open to debate (e.g. the current naming scheme doesn't really allow the same
interfaces to be used for IoSession statistics).</li></ul><ul class="alternate"
type="square">	<li>location of the lastReadTime() / lastWriteTime() / lastIoTime() methods
is open to debate.</li></ul><ul class="alternate" type="square">	<li>to keep the impact of
this first patch low, I just made AbstractIoService implement the statistics interfaces,
rather than factoring them into inner classes. (separation of concerns, high cohesion,
etc.) Factoring them into separate classes gives the ability to deploy those instances
into an MBeanServer, which I think is a big reason to make that change. Not all
application servers use the standard MBeanServer (at least historically; Java 5 may have
changed that) and JMX+OSGi isn't always straightforward, so the actual MBean deployment
should be handled by a pluggable strategy implementation.</li></ul><ul class="alternate"
type="square">	<li>I haven't touched the IoSession statistics yet, but the basic idea is
the same.</li></ul><ul class="alternate" type="square">	<li>anything
else?</li></ul>Thanks,Barend 
==============================

On issue key DIRMINA-16 the singleton pattern might have been discussed on the following comment: 
==============================
Now you can create your own TransportType singletons.  Please check out and refer to
JavaDoc. <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>I'm still looking for better way to
separate TransportType constants to each packages, but it looks more clean for
TransportType to have all default constants.  WDYT? 
==============================

On issue key DIRMINA-244 the Factory pattern might have been discussed, namely here: 
==============================
Example HTTP server using ProtocolCodeFactory 
==============================

On issue key DIRMINA-176 the  state  pattern might have been discussed on the following comment: 
==============================
I'd like time out for ByteBuffers too, it is all we need.To implement application
specified strategies of pooling there will be the JMX support <a
href="https://issues.apache.org/jira/browse/DIRMINA-29" title="JMX integration"
class="issue-link" data-issue-key="DIRMINA-29"><del>DIRMINA-29</del></a>.<br/>With the JMX
we could monitor and manage the pool state for user-defined strategies. 
==============================

On issue key DIRMINA-176 the strategy pattern might have been discussed on the following comment: 
==============================
Retaining smaller buffers can also cause a problem depending on an application's memory
usage characterstics.  What about providing both strategy at the same time? 
==============================

On issue key DIRMINA-176 the command pattern might have been discussed on the following comment: 
==============================
Yes, but, by the pool point of view, what is regarded as a smaller buffer and a bigger
buffer? Supposing to have an application that uses 30 byte buffers and occasionally some
2kb buffers (this is the case of one of the ones I'm working on now), the pool would have
serious problems to understand which ones are "smaller" and "bigger", since all of them
are of the smallest or biggest size available.In this case not to cache smallest and
biggest buffer is a problem, and to limit the maximum size would certainly not be an
improvement.But many low-level byte protocols use short fixed lenght packets for "command"
messages and use long variable lenght packets for "transport" messages, so my case is a
common case.I think what you're suggesting is very good for protocols which use many
different-sized buffers, and should therefore be implemented, but we should also let users
chose whether to use it or not.In the overload control, we should also think about
interrupting  the work when the memory limit of the pool is exceeded, in order to permit
the application to flush and release the buffers that haven't been written yet. 
==============================

On issue key DIRMINA-176 the factory pattern might have been discussed on the following comment: 
==============================
This jakarta api seems to be the right solution, we can do a GenericObjectPool for each
buffer size, at the same way we mantain multiple stacks now.<br/>This api provides the
timeout we thought, it provides also the method that block if the objects are not
available (in case we are over the maximum size of the pool, and we cannot allocate other
buffers).<br/>We have to define better some things, but it looks great to me.One thing is
the following: in this jakarta pool the new objects are provided by a factory that
allocate all the objects equals. So for each partition we will be obliged to allocate only
one kind of buffer, the higher size buffer of the partition, right? I'm not so good with
english, so I hope I have well explained my doubt. 
==============================

