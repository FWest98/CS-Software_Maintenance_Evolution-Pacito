
-----------------

-----------------
Comments: 

New Comment: 
Okay, thank you.  I would like to have all the necessary information in one place.  Please
attach the patch, the logs, and enough instructions that I can follow to setup and
reproduce the issue.I also need the following:  OS version, JVM version, JVM Options used
for the test, Processor Model(s) of your Target(s) computer; Versions of Mina which are
failing and Git locationsBasically everything you can think of that could be different
from your environment than mine. 


New Comment: 
Java HotSpot(TM) 64-Bit Server VM (25.131-b11 mixed mode)<br/>Ubuntu Linux, Kernel
4.4.0-112-generic<br/>Intel(R) Core(TM) i5-2410M CPU @ 2.30GHz<br/>Tested against mina-2.0
from <a href="https://github.com/apache/mina/tree/2.0" class="external-link"
rel="nofollow">https://github.com/apache/mina/tree/2.0</a> so should be 2.0.17-SNAPSHOTI
have run the AbstractIoServiceTest from within Eclipse then. <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/smile.png" height="16"
width="16" align="absmiddle" alt="" border="0"/> Just attached the log file
mina-test-log.txt (please note that I have run this just now so it does not conform to the
attached stack trace). 


New Comment: 
What is the information for that TravisCI server which deadlocks more often (like you
posted above)?What is the expected amount of time to see a deadlock on your Core i5-5410M? 


New Comment: 
I think you can leave the Travis CI server out of the equation now that I can reproduce it
with the patched test.<br/>The test locks up almost instantly as you can see in the
attached log file. These tests were done locally on my machine. Travis CI is not involved
anymore. 


New Comment: 
What is the JDK version?  What Ubuntu version?What CPU governor are you using on Ubuntu on
your i5-2410M?  You can install 'indicator-cpufreq' (<a
href="https://apps.ubuntu.com/cat/applications/quantal/indicator-cpufreq/)"
class="external-link"
rel="nofollow">https://apps.ubuntu.com/cat/applications/quantal/indicator-cpufreq/)</a> which
allows you to change your CPU frequency governor. If available, set it to your CPU max
(non-turbo) frequency and run the test again; otherwise set to "Performance" and run the
test again.  Because you are using a mobile chipset, I would like to make sure that the
frequency scaler on your platform isn't a contributing factor allowing deadlocks to happen
more often.My goal is to get my environment to deadlock quickly and often; just like
yours.I'm going to set this up for tomorrow.  If I can't get the results I want on my
desktop, I'll setup a 2 core VM to try it from. 


New Comment: 
The exact version is actually Xubuntu 16.04. JDK version is 1.8.0_162-b12.I'll have to
check the cpu governor stuff next week as I don't have the necessary rights to change
this. But as it seems I am on powersave. :-/<div class="code panel" style="border-width:
1px;"><div class="codeContent panelContent"><pre class="code-java">cat
/sys/devices/system/cpu/cpu*/cpufreq/scaling_governorpowersavepowersavepowersavepowersave</pre></div></div> 


On issue key DIRMINA-1076 the Iterator pattern might have been discussed on the following comment: 
==============================
Here is the patch to fix your issue; it also passes maven:test.  It passes the tests  but
is not the final patch because I have some concerns about it long term.<div class="code
panel" style="border-width: 1px;"><div class="codeContent panelContent"><pre
class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..503df41 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-661,7 +661,9 @@                      <span class="code-comment">// And manage removed
sessions</span>                     nSessions -= removeSessions();-+                  
 +                    <span class="code-keyword">assert</span> nSessions &gt; -1 : <span
class="code-quote">"<span class="code-object">Number</span> of Sessions has gone
negative"</span>;+                     <span class="code-comment">// Last, not least, send
Idle events to the idle sessions</span>                    
notifyIdleSessions(currentTime); @@ -695,9 +697,8 @@                         <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{                             IoSession session = i.next(); -                           
scheduleRemove((S) session);-                             <span
class="code-keyword">if</span> (session.isActive()) {+                              
 scheduleRemove((S) session);                                 hasKeys = <span
class="code-keyword">true</span>;                             }                        
}</pre></div></div> Emmanual,  while this patch fixes the problem Christoph is seeing.  I
am concerned that relying on this change could cause a problem where the
SelectionKey.isValid() i.e. `session.isActive()` is false but the Session was not
previously removed correctly.  The AbstractIoProcessor is relying on the validity of the
SelectionKey and the Set&lt;SelectionKey&gt; to internally manage active sessions which is
a really bad move because the SelectionKeys can become invalid totally independent of the
AbstractIoProcessor which could leave pending writing data and other things hanging
forever.  Fundamentally, the problem is that, in the 2.0 master the Sessions are being
removed TWICE from AbstractIoProcessor leaving the Session Counter in the Negative.  One
way to fix the problem safely is to store all the Sessions for the IoProcessor as a List
and use that as the master list of 'active' Sessions but I don't know if there is some
lazy Session stealing between IoProcessors in Mina which could conflict with that idea.  
==============================

New Comment: 
Here is the patch to fix your issue; it also passes maven:test.  It passes the tests  but
is not the final patch because I have some concerns about it long term.<div class="code
panel" style="border-width: 1px;"><div class="codeContent panelContent"><pre
class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..503df41 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-661,7 +661,9 @@                      <span class="code-comment">// And manage removed
sessions</span>                     nSessions -= removeSessions();-+                  
 +                    <span class="code-keyword">assert</span> nSessions &gt; -1 : <span
class="code-quote">"<span class="code-object">Number</span> of Sessions has gone
negative"</span>;+                     <span class="code-comment">// Last, not least, send
Idle events to the idle sessions</span>                    
notifyIdleSessions(currentTime); @@ -695,9 +697,8 @@                         <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{                             IoSession session = i.next(); -                           
scheduleRemove((S) session);-                             <span
class="code-keyword">if</span> (session.isActive()) {+                              
 scheduleRemove((S) session);                                 hasKeys = <span
class="code-keyword">true</span>;                             }                        
}</pre></div></div> Emmanual,  while this patch fixes the problem Christoph is seeing.  I
am concerned that relying on this change could cause a problem where the
SelectionKey.isValid() i.e. `session.isActive()` is false but the Session was not
previously removed correctly.  The AbstractIoProcessor is relying on the validity of the
SelectionKey and the Set&lt;SelectionKey&gt; to internally manage active sessions which is
a really bad move because the SelectionKeys can become invalid totally independent of the
AbstractIoProcessor which could leave pending writing data and other things hanging
forever.  Fundamentally, the problem is that, in the 2.0 master the Sessions are being
removed TWICE from AbstractIoProcessor leaving the Session Counter in the Negative.  One
way to fix the problem safely is to store all the Sessions for the IoProcessor as a List
and use that as the master list of 'active' Sessions but I don't know if there is some
lazy Session stealing between IoProcessors in Mina which could conflict with that idea.  


On issue key DIRMINA-1076 the Adapter pattern might have been discussed on the following comment: 
==============================
<b>Notes:</b>I've thought about it and have come up with the following patch which
resolves my question about the previous patch.  I was attempting to find a solution which
made the smallest number of changes to resolve the problem.  As it turns out, moving the
<tt>isDisposing()</tt> check above <tt>removeSessions()</tt> resolves the double-removal
issue due to blind removal scheduling based on the Selectors <tt>keys()</tt>. I believe
the method in the following patch to be safe due to the nature of the disposing state;
since disposal is immediate and we don't care about letting Sessions soft-close there is
no need to wakeup the Selector.<b>What was
happening:</b><ul>	<li><tt>process(Session)</tt> would cause self remove via
<tt>scheduleRemoval</tt></li>	<li><tt>removeSessions</tt> removes all sessions scheduled
via <tt>scheduleRemoval</tt></li>	<li><tt>isDisposing()</tt> block would add ALL sessions
from <tt>selector.keys()</tt> to <tt>scheduleRemoval</tt> causing the previously self
removed session to be scheduled, again, using <tt>scheduleRemoval</tt>.
(<tt>selector.keys()</tt> does not update until the next time <tt>select()</tt> is
called.)  The next time <tt>removeSessions</tt> is called, the session counter goes
negative.  The self-destruct routine checks for (<tt>session count == 0)</tt> which never
is satisfied because the session count is negative number.</li></ul>This patch works by
moving the <tt>isDisposing()</tt> block before <tt>removeSessions</tt> utilizing the
<tt>contains(Session)</tt> check of <tt>removeSessions</tt> to prevent a single
<tt>Session</tt> from being added to the list twice.<em>Patch to prevent double-removal of
a single session which causes the counter to go negative preventing the processor from
disposing.</em><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..2715b98 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-659,9 +659,20 @@                     <span class="code-object">long</span> currentTime =
<span class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime); +                    <span class="code-comment">// Disconnect all
sessions immediately <span class="code-keyword">if</span> disposal has
been</span>+                    <span class="code-comment">// requested so that we exit
<span class="code-keyword">this</span> loop eventually.</span>+                    <span
class="code-keyword">if</span> (isDisposing()) {+                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{+                            IoSession session = i.next();+                           
scheduleRemove((S) session);+                        }+                   
}+                                         <span class="code-comment">// And manage
removed sessions</span>                     nSessions -=
removeSessions();-+                    +                    <span
class="code-keyword">assert</span> nSessions &gt; -1 : <span class="code-quote">"Internal
Session Count is Negative"</span>;+                                         <span
class="code-comment">// Last, not least, send Idle events to the idle
sessions</span>                     notifyIdleSessions(currentTime); @@ -685,26 +696,6
@@                         }                          <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }--                    <span
class="code-comment">// Disconnect all sessions immediately <span
class="code-keyword">if</span> disposal has been</span>-                    <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>-                    <span class="code-keyword">if</span>
(isDisposing()) {-                        <span class="code-object">boolean</span> hasKeys
= <span class="code-keyword">false</span>;--                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{-                            IoSession session = i.next();--                           
scheduleRemove((S) session);--                            <span
class="code-keyword">if</span> (session.isActive()) {-                               
hasKeys = <span class="code-keyword">true</span>;-                           
}-                        }--                        <span class="code-keyword">if</span>
(hasKeys) {-                            wakeup();-                       
}                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span></pre></div></div> I had to change
Christoph's <tt>AbstractIoServiceTest</tt> patch because it calls
<tt>connector.dispose(true)</tt> which the documentation and comments above say is
something that should not be done within an <tt>IoFutureListener</tt>.  The reason I had
to change from <tt>true</tt> to <tt>false</tt> was because <tt>dispose(true)</tt> blocks
on itself and preventing the <tt>IoProcessor</tt> thread from ever stopping.  In the
described test, this causes the application to create threads until the OS complains about
it preventing more threads from being created.<em>Patch to make the test run in a
loop</em><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java
b/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.javaindex
2d70f8e..325c4e4 100644---
a/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java+++
b/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java@@ -30,6
+30,7 @@ <span class="code-keyword">import</span>
org.apache.mina.filter.logging.LoggingFilter; <span class="code-keyword">import</span>
org.apache.mina.transport.socket.nio.NioSocketAcceptor; <span
class="code-keyword">import</span>
org.apache.mina.transport.socket.nio.NioSocketConnector;+<span
class="code-keyword">import</span> org.apache.mina.util.AvailablePortFinder; <span
class="code-keyword">import</span> org.junit.Test; <span
class="code-keyword">import</span> org.slf4j.Logger; <span
class="code-keyword">import</span> org.slf4j.LoggerFactory;@@ -48,16 +49,15 @@  */ <span
class="code-keyword">public</span> <span class="code-keyword">class
</span>AbstractIoServiceTest { -    <span class="code-keyword">private</span> <span
class="code-keyword">static</span> <span class="code-keyword">final</span> <span
class="code-object">int</span> PORT = 9123;-     @Test     <span
class="code-keyword">public</span> void testDispose() <span
class="code-keyword">throws</span> IOException, InterruptedException { +        <span
class="code-keyword">while</span> ( <span class="code-keyword">true</span>) {        
List&lt;<span class="code-object">String</span>&gt; threadsBefore =
getThreadNames();          <span class="code-keyword">final</span> IoAcceptor acceptor =
<span class="code-keyword">new</span> NioSocketAcceptor(); -       
acceptor.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());+     <span class="code-comment">//  
acceptor.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());</span>        
acceptor.getFilterChain().addLast(<span class="code-quote">"codec"</span>,                
<span class="code-keyword">new</span> ProtocolCodecFilter(<span
class="code-keyword">new</span> TextLineCodecFactory(Charset.forName(<span
class="code-quote">"UTF-8"</span>)))); @@ -65,7 +65,8 @@         
acceptor.getSessionConfig().setReadBufferSize(2048);        
acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);-       
acceptor.bind(<span class="code-keyword">new</span> InetSocketAddress(PORT));+       
<span class="code-object">int</span> nextAvailable =
AvailablePortFinder.getNextAvailable();+        acceptor.bind(<span
class="code-keyword">new</span> InetSocketAddress(nextAvailable));         <span
class="code-object">System</span>.out.println(<span class="code-quote">"Server running
..."</span>);          <span class="code-keyword">final</span> NioSocketConnector
connector = <span class="code-keyword">new</span> NioSocketConnector();@@ -74,12 +75,12
@@         connector.setConnectTimeoutMillis(30 * 1000L);         
connector.setHandler(<span class="code-keyword">new</span> ClientHandler());-       
connector.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());+      <span class="code-comment">// 
connector.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());</span>        
connector.getFilterChain().addLast(<span
class="code-quote">"codec"</span>,                 <span class="code-keyword">new</span>
ProtocolCodecFilter(<span class="code-keyword">new</span>
TextLineCodecFactory(Charset.forName(<span class="code-quote">"UTF-8"</span>))));         
<span class="code-comment">// Start communication.</span>-        ConnectFuture cf =
connector.connect(<span class="code-keyword">new</span> InetSocketAddress(<span
class="code-quote">"localhost"</span>, 9123));+        ConnectFuture cf =
connector.connect(<span class="code-keyword">new</span> InetSocketAddress(<span
class="code-quote">"localhost"</span>, nextAvailable));        
cf.awaitUninterruptibly();          IoSession session = cf.getSession();@@ -103,7 +104,9
@@             <span class="code-keyword">public</span> void operationComplete(IoFuture
<span class="code-keyword">future</span>) {                 <span
class="code-object">System</span>.out.println(<span class="code-quote">"managed session
count="</span> + connector.getManagedSessionCount());                 <span
class="code-object">System</span>.out.println(<span class="code-quote">"Disposing
connector ..."</span>);-                connector.dispose(<span
class="code-keyword">true</span>);+                <span class="code-comment">// the doc
states that the following should not be called with parameter TRUE from an
IoFutureListener?!</span>+                <span class="code-comment">// on the other hand,
using FALSE does not work either</span>+                connector.dispose(<span
class="code-keyword">false</span>);                     <span
class="code-object">System</span>.out.println(<span class="code-quote">"Disposing
connector ... *finished*"</span>);              }@@ -114,11 +117,11 @@         
List&lt;<span class="code-object">String</span>&gt; threadsAfter =
getThreadNames(); -        <span class="code-object">System</span>.out.println(<span
class="code-quote">"threadsBefore = "</span> + threadsBefore);-        <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsAfter  =
"</span> + threadsAfter);+       <span class="code-comment">// <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsBefore =
"</span> + threadsBefore);</span>+       <span class="code-comment">// <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsAfter  =
"</span> + threadsAfter);</span>          <span class="code-comment">//
Assert.assertEquals(threadsBefore, threadsAfter);</span>-+    }     }      <span
class="code-keyword">public</span> <span class="code-keyword">static</span> <span
class="code-keyword">class </span>ClientHandler <span class="code-keyword">extends</span>
IoHandlerAdapter {</pre></div></div>   
==============================

On issue key DIRMINA-1076 the Factory pattern might have been discussed on the following comment: 
==============================
<b>Notes:</b>I've thought about it and have come up with the following patch which
resolves my question about the previous patch.  I was attempting to find a solution which
made the smallest number of changes to resolve the problem.  As it turns out, moving the
<tt>isDisposing()</tt> check above <tt>removeSessions()</tt> resolves the double-removal
issue due to blind removal scheduling based on the Selectors <tt>keys()</tt>. I believe
the method in the following patch to be safe due to the nature of the disposing state;
since disposal is immediate and we don't care about letting Sessions soft-close there is
no need to wakeup the Selector.<b>What was
happening:</b><ul>	<li><tt>process(Session)</tt> would cause self remove via
<tt>scheduleRemoval</tt></li>	<li><tt>removeSessions</tt> removes all sessions scheduled
via <tt>scheduleRemoval</tt></li>	<li><tt>isDisposing()</tt> block would add ALL sessions
from <tt>selector.keys()</tt> to <tt>scheduleRemoval</tt> causing the previously self
removed session to be scheduled, again, using <tt>scheduleRemoval</tt>.
(<tt>selector.keys()</tt> does not update until the next time <tt>select()</tt> is
called.)  The next time <tt>removeSessions</tt> is called, the session counter goes
negative.  The self-destruct routine checks for (<tt>session count == 0)</tt> which never
is satisfied because the session count is negative number.</li></ul>This patch works by
moving the <tt>isDisposing()</tt> block before <tt>removeSessions</tt> utilizing the
<tt>contains(Session)</tt> check of <tt>removeSessions</tt> to prevent a single
<tt>Session</tt> from being added to the list twice.<em>Patch to prevent double-removal of
a single session which causes the counter to go negative preventing the processor from
disposing.</em><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..2715b98 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-659,9 +659,20 @@                     <span class="code-object">long</span> currentTime =
<span class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime); +                    <span class="code-comment">// Disconnect all
sessions immediately <span class="code-keyword">if</span> disposal has
been</span>+                    <span class="code-comment">// requested so that we exit
<span class="code-keyword">this</span> loop eventually.</span>+                    <span
class="code-keyword">if</span> (isDisposing()) {+                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{+                            IoSession session = i.next();+                           
scheduleRemove((S) session);+                        }+                   
}+                                         <span class="code-comment">// And manage
removed sessions</span>                     nSessions -=
removeSessions();-+                    +                    <span
class="code-keyword">assert</span> nSessions &gt; -1 : <span class="code-quote">"Internal
Session Count is Negative"</span>;+                                         <span
class="code-comment">// Last, not least, send Idle events to the idle
sessions</span>                     notifyIdleSessions(currentTime); @@ -685,26 +696,6
@@                         }                          <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }--                    <span
class="code-comment">// Disconnect all sessions immediately <span
class="code-keyword">if</span> disposal has been</span>-                    <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>-                    <span class="code-keyword">if</span>
(isDisposing()) {-                        <span class="code-object">boolean</span> hasKeys
= <span class="code-keyword">false</span>;--                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{-                            IoSession session = i.next();--                           
scheduleRemove((S) session);--                            <span
class="code-keyword">if</span> (session.isActive()) {-                               
hasKeys = <span class="code-keyword">true</span>;-                           
}-                        }--                        <span class="code-keyword">if</span>
(hasKeys) {-                            wakeup();-                       
}                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span></pre></div></div> I had to change
Christoph's <tt>AbstractIoServiceTest</tt> patch because it calls
<tt>connector.dispose(true)</tt> which the documentation and comments above say is
something that should not be done within an <tt>IoFutureListener</tt>.  The reason I had
to change from <tt>true</tt> to <tt>false</tt> was because <tt>dispose(true)</tt> blocks
on itself and preventing the <tt>IoProcessor</tt> thread from ever stopping.  In the
described test, this causes the application to create threads until the OS complains about
it preventing more threads from being created.<em>Patch to make the test run in a
loop</em><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java
b/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.javaindex
2d70f8e..325c4e4 100644---
a/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java+++
b/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java@@ -30,6
+30,7 @@ <span class="code-keyword">import</span>
org.apache.mina.filter.logging.LoggingFilter; <span class="code-keyword">import</span>
org.apache.mina.transport.socket.nio.NioSocketAcceptor; <span
class="code-keyword">import</span>
org.apache.mina.transport.socket.nio.NioSocketConnector;+<span
class="code-keyword">import</span> org.apache.mina.util.AvailablePortFinder; <span
class="code-keyword">import</span> org.junit.Test; <span
class="code-keyword">import</span> org.slf4j.Logger; <span
class="code-keyword">import</span> org.slf4j.LoggerFactory;@@ -48,16 +49,15 @@  */ <span
class="code-keyword">public</span> <span class="code-keyword">class
</span>AbstractIoServiceTest { -    <span class="code-keyword">private</span> <span
class="code-keyword">static</span> <span class="code-keyword">final</span> <span
class="code-object">int</span> PORT = 9123;-     @Test     <span
class="code-keyword">public</span> void testDispose() <span
class="code-keyword">throws</span> IOException, InterruptedException { +        <span
class="code-keyword">while</span> ( <span class="code-keyword">true</span>) {        
List&lt;<span class="code-object">String</span>&gt; threadsBefore =
getThreadNames();          <span class="code-keyword">final</span> IoAcceptor acceptor =
<span class="code-keyword">new</span> NioSocketAcceptor(); -       
acceptor.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());+     <span class="code-comment">//  
acceptor.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());</span>        
acceptor.getFilterChain().addLast(<span class="code-quote">"codec"</span>,                
<span class="code-keyword">new</span> ProtocolCodecFilter(<span
class="code-keyword">new</span> TextLineCodecFactory(Charset.forName(<span
class="code-quote">"UTF-8"</span>)))); @@ -65,7 +65,8 @@         
acceptor.getSessionConfig().setReadBufferSize(2048);        
acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);-       
acceptor.bind(<span class="code-keyword">new</span> InetSocketAddress(PORT));+       
<span class="code-object">int</span> nextAvailable =
AvailablePortFinder.getNextAvailable();+        acceptor.bind(<span
class="code-keyword">new</span> InetSocketAddress(nextAvailable));         <span
class="code-object">System</span>.out.println(<span class="code-quote">"Server running
..."</span>);          <span class="code-keyword">final</span> NioSocketConnector
connector = <span class="code-keyword">new</span> NioSocketConnector();@@ -74,12 +75,12
@@         connector.setConnectTimeoutMillis(30 * 1000L);         
connector.setHandler(<span class="code-keyword">new</span> ClientHandler());-       
connector.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());+      <span class="code-comment">// 
connector.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());</span>        
connector.getFilterChain().addLast(<span
class="code-quote">"codec"</span>,                 <span class="code-keyword">new</span>
ProtocolCodecFilter(<span class="code-keyword">new</span>
TextLineCodecFactory(Charset.forName(<span class="code-quote">"UTF-8"</span>))));         
<span class="code-comment">// Start communication.</span>-        ConnectFuture cf =
connector.connect(<span class="code-keyword">new</span> InetSocketAddress(<span
class="code-quote">"localhost"</span>, 9123));+        ConnectFuture cf =
connector.connect(<span class="code-keyword">new</span> InetSocketAddress(<span
class="code-quote">"localhost"</span>, nextAvailable));        
cf.awaitUninterruptibly();          IoSession session = cf.getSession();@@ -103,7 +104,9
@@             <span class="code-keyword">public</span> void operationComplete(IoFuture
<span class="code-keyword">future</span>) {                 <span
class="code-object">System</span>.out.println(<span class="code-quote">"managed session
count="</span> + connector.getManagedSessionCount());                 <span
class="code-object">System</span>.out.println(<span class="code-quote">"Disposing
connector ..."</span>);-                connector.dispose(<span
class="code-keyword">true</span>);+                <span class="code-comment">// the doc
states that the following should not be called with parameter TRUE from an
IoFutureListener?!</span>+                <span class="code-comment">// on the other hand,
using FALSE does not work either</span>+                connector.dispose(<span
class="code-keyword">false</span>);                     <span
class="code-object">System</span>.out.println(<span class="code-quote">"Disposing
connector ... *finished*"</span>);              }@@ -114,11 +117,11 @@         
List&lt;<span class="code-object">String</span>&gt; threadsAfter =
getThreadNames(); -        <span class="code-object">System</span>.out.println(<span
class="code-quote">"threadsBefore = "</span> + threadsBefore);-        <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsAfter  =
"</span> + threadsAfter);+       <span class="code-comment">// <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsBefore =
"</span> + threadsBefore);</span>+       <span class="code-comment">// <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsAfter  =
"</span> + threadsAfter);</span>          <span class="code-comment">//
Assert.assertEquals(threadsBefore, threadsAfter);</span>-+    }     }      <span
class="code-keyword">public</span> <span class="code-keyword">static</span> <span
class="code-keyword">class </span>ClientHandler <span class="code-keyword">extends</span>
IoHandlerAdapter {</pre></div></div>   
==============================

On issue key DIRMINA-1076 the mediate pattern might have been discussed on the following comment: 
==============================
<b>Notes:</b>I've thought about it and have come up with the following patch which
resolves my question about the previous patch.  I was attempting to find a solution which
made the smallest number of changes to resolve the problem.  As it turns out, moving the
<tt>isDisposing()</tt> check above <tt>removeSessions()</tt> resolves the double-removal
issue due to blind removal scheduling based on the Selectors <tt>keys()</tt>. I believe
the method in the following patch to be safe due to the nature of the disposing state;
since disposal is immediate and we don't care about letting Sessions soft-close there is
no need to wakeup the Selector.<b>What was
happening:</b><ul>	<li><tt>process(Session)</tt> would cause self remove via
<tt>scheduleRemoval</tt></li>	<li><tt>removeSessions</tt> removes all sessions scheduled
via <tt>scheduleRemoval</tt></li>	<li><tt>isDisposing()</tt> block would add ALL sessions
from <tt>selector.keys()</tt> to <tt>scheduleRemoval</tt> causing the previously self
removed session to be scheduled, again, using <tt>scheduleRemoval</tt>.
(<tt>selector.keys()</tt> does not update until the next time <tt>select()</tt> is
called.)  The next time <tt>removeSessions</tt> is called, the session counter goes
negative.  The self-destruct routine checks for (<tt>session count == 0)</tt> which never
is satisfied because the session count is negative number.</li></ul>This patch works by
moving the <tt>isDisposing()</tt> block before <tt>removeSessions</tt> utilizing the
<tt>contains(Session)</tt> check of <tt>removeSessions</tt> to prevent a single
<tt>Session</tt> from being added to the list twice.<em>Patch to prevent double-removal of
a single session which causes the counter to go negative preventing the processor from
disposing.</em><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..2715b98 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-659,9 +659,20 @@                     <span class="code-object">long</span> currentTime =
<span class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime); +                    <span class="code-comment">// Disconnect all
sessions immediately <span class="code-keyword">if</span> disposal has
been</span>+                    <span class="code-comment">// requested so that we exit
<span class="code-keyword">this</span> loop eventually.</span>+                    <span
class="code-keyword">if</span> (isDisposing()) {+                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{+                            IoSession session = i.next();+                           
scheduleRemove((S) session);+                        }+                   
}+                                         <span class="code-comment">// And manage
removed sessions</span>                     nSessions -=
removeSessions();-+                    +                    <span
class="code-keyword">assert</span> nSessions &gt; -1 : <span class="code-quote">"Internal
Session Count is Negative"</span>;+                                         <span
class="code-comment">// Last, not least, send Idle events to the idle
sessions</span>                     notifyIdleSessions(currentTime); @@ -685,26 +696,6
@@                         }                          <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }--                    <span
class="code-comment">// Disconnect all sessions immediately <span
class="code-keyword">if</span> disposal has been</span>-                    <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>-                    <span class="code-keyword">if</span>
(isDisposing()) {-                        <span class="code-object">boolean</span> hasKeys
= <span class="code-keyword">false</span>;--                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{-                            IoSession session = i.next();--                           
scheduleRemove((S) session);--                            <span
class="code-keyword">if</span> (session.isActive()) {-                               
hasKeys = <span class="code-keyword">true</span>;-                           
}-                        }--                        <span class="code-keyword">if</span>
(hasKeys) {-                            wakeup();-                       
}                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span></pre></div></div> I had to change
Christoph's <tt>AbstractIoServiceTest</tt> patch because it calls
<tt>connector.dispose(true)</tt> which the documentation and comments above say is
something that should not be done within an <tt>IoFutureListener</tt>.  The reason I had
to change from <tt>true</tt> to <tt>false</tt> was because <tt>dispose(true)</tt> blocks
on itself and preventing the <tt>IoProcessor</tt> thread from ever stopping.  In the
described test, this causes the application to create threads until the OS complains about
it preventing more threads from being created.<em>Patch to make the test run in a
loop</em><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java
b/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.javaindex
2d70f8e..325c4e4 100644---
a/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java+++
b/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java@@ -30,6
+30,7 @@ <span class="code-keyword">import</span>
org.apache.mina.filter.logging.LoggingFilter; <span class="code-keyword">import</span>
org.apache.mina.transport.socket.nio.NioSocketAcceptor; <span
class="code-keyword">import</span>
org.apache.mina.transport.socket.nio.NioSocketConnector;+<span
class="code-keyword">import</span> org.apache.mina.util.AvailablePortFinder; <span
class="code-keyword">import</span> org.junit.Test; <span
class="code-keyword">import</span> org.slf4j.Logger; <span
class="code-keyword">import</span> org.slf4j.LoggerFactory;@@ -48,16 +49,15 @@  */ <span
class="code-keyword">public</span> <span class="code-keyword">class
</span>AbstractIoServiceTest { -    <span class="code-keyword">private</span> <span
class="code-keyword">static</span> <span class="code-keyword">final</span> <span
class="code-object">int</span> PORT = 9123;-     @Test     <span
class="code-keyword">public</span> void testDispose() <span
class="code-keyword">throws</span> IOException, InterruptedException { +        <span
class="code-keyword">while</span> ( <span class="code-keyword">true</span>) {        
List&lt;<span class="code-object">String</span>&gt; threadsBefore =
getThreadNames();          <span class="code-keyword">final</span> IoAcceptor acceptor =
<span class="code-keyword">new</span> NioSocketAcceptor(); -       
acceptor.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());+     <span class="code-comment">//  
acceptor.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());</span>        
acceptor.getFilterChain().addLast(<span class="code-quote">"codec"</span>,                
<span class="code-keyword">new</span> ProtocolCodecFilter(<span
class="code-keyword">new</span> TextLineCodecFactory(Charset.forName(<span
class="code-quote">"UTF-8"</span>)))); @@ -65,7 +65,8 @@         
acceptor.getSessionConfig().setReadBufferSize(2048);        
acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);-       
acceptor.bind(<span class="code-keyword">new</span> InetSocketAddress(PORT));+       
<span class="code-object">int</span> nextAvailable =
AvailablePortFinder.getNextAvailable();+        acceptor.bind(<span
class="code-keyword">new</span> InetSocketAddress(nextAvailable));         <span
class="code-object">System</span>.out.println(<span class="code-quote">"Server running
..."</span>);          <span class="code-keyword">final</span> NioSocketConnector
connector = <span class="code-keyword">new</span> NioSocketConnector();@@ -74,12 +75,12
@@         connector.setConnectTimeoutMillis(30 * 1000L);         
connector.setHandler(<span class="code-keyword">new</span> ClientHandler());-       
connector.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());+      <span class="code-comment">// 
connector.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());</span>        
connector.getFilterChain().addLast(<span
class="code-quote">"codec"</span>,                 <span class="code-keyword">new</span>
ProtocolCodecFilter(<span class="code-keyword">new</span>
TextLineCodecFactory(Charset.forName(<span class="code-quote">"UTF-8"</span>))));         
<span class="code-comment">// Start communication.</span>-        ConnectFuture cf =
connector.connect(<span class="code-keyword">new</span> InetSocketAddress(<span
class="code-quote">"localhost"</span>, 9123));+        ConnectFuture cf =
connector.connect(<span class="code-keyword">new</span> InetSocketAddress(<span
class="code-quote">"localhost"</span>, nextAvailable));        
cf.awaitUninterruptibly();          IoSession session = cf.getSession();@@ -103,7 +104,9
@@             <span class="code-keyword">public</span> void operationComplete(IoFuture
<span class="code-keyword">future</span>) {                 <span
class="code-object">System</span>.out.println(<span class="code-quote">"managed session
count="</span> + connector.getManagedSessionCount());                 <span
class="code-object">System</span>.out.println(<span class="code-quote">"Disposing
connector ..."</span>);-                connector.dispose(<span
class="code-keyword">true</span>);+                <span class="code-comment">// the doc
states that the following should not be called with parameter TRUE from an
IoFutureListener?!</span>+                <span class="code-comment">// on the other hand,
using FALSE does not work either</span>+                connector.dispose(<span
class="code-keyword">false</span>);                     <span
class="code-object">System</span>.out.println(<span class="code-quote">"Disposing
connector ... *finished*"</span>);              }@@ -114,11 +117,11 @@         
List&lt;<span class="code-object">String</span>&gt; threadsAfter =
getThreadNames(); -        <span class="code-object">System</span>.out.println(<span
class="code-quote">"threadsBefore = "</span> + threadsBefore);-        <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsAfter  =
"</span> + threadsAfter);+       <span class="code-comment">// <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsBefore =
"</span> + threadsBefore);</span>+       <span class="code-comment">// <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsAfter  =
"</span> + threadsAfter);</span>          <span class="code-comment">//
Assert.assertEquals(threadsBefore, threadsAfter);</span>-+    }     }      <span
class="code-keyword">public</span> <span class="code-keyword">static</span> <span
class="code-keyword">class </span>ClientHandler <span class="code-keyword">extends</span>
IoHandlerAdapter {</pre></div></div>   
==============================

On issue key DIRMINA-1076 the Iterator pattern might have been discussed on the following comment: 
==============================
<b>Notes:</b>I've thought about it and have come up with the following patch which
resolves my question about the previous patch.  I was attempting to find a solution which
made the smallest number of changes to resolve the problem.  As it turns out, moving the
<tt>isDisposing()</tt> check above <tt>removeSessions()</tt> resolves the double-removal
issue due to blind removal scheduling based on the Selectors <tt>keys()</tt>. I believe
the method in the following patch to be safe due to the nature of the disposing state;
since disposal is immediate and we don't care about letting Sessions soft-close there is
no need to wakeup the Selector.<b>What was
happening:</b><ul>	<li><tt>process(Session)</tt> would cause self remove via
<tt>scheduleRemoval</tt></li>	<li><tt>removeSessions</tt> removes all sessions scheduled
via <tt>scheduleRemoval</tt></li>	<li><tt>isDisposing()</tt> block would add ALL sessions
from <tt>selector.keys()</tt> to <tt>scheduleRemoval</tt> causing the previously self
removed session to be scheduled, again, using <tt>scheduleRemoval</tt>.
(<tt>selector.keys()</tt> does not update until the next time <tt>select()</tt> is
called.)  The next time <tt>removeSessions</tt> is called, the session counter goes
negative.  The self-destruct routine checks for (<tt>session count == 0)</tt> which never
is satisfied because the session count is negative number.</li></ul>This patch works by
moving the <tt>isDisposing()</tt> block before <tt>removeSessions</tt> utilizing the
<tt>contains(Session)</tt> check of <tt>removeSessions</tt> to prevent a single
<tt>Session</tt> from being added to the list twice.<em>Patch to prevent double-removal of
a single session which causes the counter to go negative preventing the processor from
disposing.</em><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..2715b98 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-659,9 +659,20 @@                     <span class="code-object">long</span> currentTime =
<span class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime); +                    <span class="code-comment">// Disconnect all
sessions immediately <span class="code-keyword">if</span> disposal has
been</span>+                    <span class="code-comment">// requested so that we exit
<span class="code-keyword">this</span> loop eventually.</span>+                    <span
class="code-keyword">if</span> (isDisposing()) {+                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{+                            IoSession session = i.next();+                           
scheduleRemove((S) session);+                        }+                   
}+                                         <span class="code-comment">// And manage
removed sessions</span>                     nSessions -=
removeSessions();-+                    +                    <span
class="code-keyword">assert</span> nSessions &gt; -1 : <span class="code-quote">"Internal
Session Count is Negative"</span>;+                                         <span
class="code-comment">// Last, not least, send Idle events to the idle
sessions</span>                     notifyIdleSessions(currentTime); @@ -685,26 +696,6
@@                         }                          <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }--                    <span
class="code-comment">// Disconnect all sessions immediately <span
class="code-keyword">if</span> disposal has been</span>-                    <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>-                    <span class="code-keyword">if</span>
(isDisposing()) {-                        <span class="code-object">boolean</span> hasKeys
= <span class="code-keyword">false</span>;--                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{-                            IoSession session = i.next();--                           
scheduleRemove((S) session);--                            <span
class="code-keyword">if</span> (session.isActive()) {-                               
hasKeys = <span class="code-keyword">true</span>;-                           
}-                        }--                        <span class="code-keyword">if</span>
(hasKeys) {-                            wakeup();-                       
}                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span></pre></div></div> I had to change
Christoph's <tt>AbstractIoServiceTest</tt> patch because it calls
<tt>connector.dispose(true)</tt> which the documentation and comments above say is
something that should not be done within an <tt>IoFutureListener</tt>.  The reason I had
to change from <tt>true</tt> to <tt>false</tt> was because <tt>dispose(true)</tt> blocks
on itself and preventing the <tt>IoProcessor</tt> thread from ever stopping.  In the
described test, this causes the application to create threads until the OS complains about
it preventing more threads from being created.<em>Patch to make the test run in a
loop</em><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java
b/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.javaindex
2d70f8e..325c4e4 100644---
a/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java+++
b/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java@@ -30,6
+30,7 @@ <span class="code-keyword">import</span>
org.apache.mina.filter.logging.LoggingFilter; <span class="code-keyword">import</span>
org.apache.mina.transport.socket.nio.NioSocketAcceptor; <span
class="code-keyword">import</span>
org.apache.mina.transport.socket.nio.NioSocketConnector;+<span
class="code-keyword">import</span> org.apache.mina.util.AvailablePortFinder; <span
class="code-keyword">import</span> org.junit.Test; <span
class="code-keyword">import</span> org.slf4j.Logger; <span
class="code-keyword">import</span> org.slf4j.LoggerFactory;@@ -48,16 +49,15 @@  */ <span
class="code-keyword">public</span> <span class="code-keyword">class
</span>AbstractIoServiceTest { -    <span class="code-keyword">private</span> <span
class="code-keyword">static</span> <span class="code-keyword">final</span> <span
class="code-object">int</span> PORT = 9123;-     @Test     <span
class="code-keyword">public</span> void testDispose() <span
class="code-keyword">throws</span> IOException, InterruptedException { +        <span
class="code-keyword">while</span> ( <span class="code-keyword">true</span>) {        
List&lt;<span class="code-object">String</span>&gt; threadsBefore =
getThreadNames();          <span class="code-keyword">final</span> IoAcceptor acceptor =
<span class="code-keyword">new</span> NioSocketAcceptor(); -       
acceptor.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());+     <span class="code-comment">//  
acceptor.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());</span>        
acceptor.getFilterChain().addLast(<span class="code-quote">"codec"</span>,                
<span class="code-keyword">new</span> ProtocolCodecFilter(<span
class="code-keyword">new</span> TextLineCodecFactory(Charset.forName(<span
class="code-quote">"UTF-8"</span>)))); @@ -65,7 +65,8 @@         
acceptor.getSessionConfig().setReadBufferSize(2048);        
acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);-       
acceptor.bind(<span class="code-keyword">new</span> InetSocketAddress(PORT));+       
<span class="code-object">int</span> nextAvailable =
AvailablePortFinder.getNextAvailable();+        acceptor.bind(<span
class="code-keyword">new</span> InetSocketAddress(nextAvailable));         <span
class="code-object">System</span>.out.println(<span class="code-quote">"Server running
..."</span>);          <span class="code-keyword">final</span> NioSocketConnector
connector = <span class="code-keyword">new</span> NioSocketConnector();@@ -74,12 +75,12
@@         connector.setConnectTimeoutMillis(30 * 1000L);         
connector.setHandler(<span class="code-keyword">new</span> ClientHandler());-       
connector.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());+      <span class="code-comment">// 
connector.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());</span>        
connector.getFilterChain().addLast(<span
class="code-quote">"codec"</span>,                 <span class="code-keyword">new</span>
ProtocolCodecFilter(<span class="code-keyword">new</span>
TextLineCodecFactory(Charset.forName(<span class="code-quote">"UTF-8"</span>))));         
<span class="code-comment">// Start communication.</span>-        ConnectFuture cf =
connector.connect(<span class="code-keyword">new</span> InetSocketAddress(<span
class="code-quote">"localhost"</span>, 9123));+        ConnectFuture cf =
connector.connect(<span class="code-keyword">new</span> InetSocketAddress(<span
class="code-quote">"localhost"</span>, nextAvailable));        
cf.awaitUninterruptibly();          IoSession session = cf.getSession();@@ -103,7 +104,9
@@             <span class="code-keyword">public</span> void operationComplete(IoFuture
<span class="code-keyword">future</span>) {                 <span
class="code-object">System</span>.out.println(<span class="code-quote">"managed session
count="</span> + connector.getManagedSessionCount());                 <span
class="code-object">System</span>.out.println(<span class="code-quote">"Disposing
connector ..."</span>);-                connector.dispose(<span
class="code-keyword">true</span>);+                <span class="code-comment">// the doc
states that the following should not be called with parameter TRUE from an
IoFutureListener?!</span>+                <span class="code-comment">// on the other hand,
using FALSE does not work either</span>+                connector.dispose(<span
class="code-keyword">false</span>);                     <span
class="code-object">System</span>.out.println(<span class="code-quote">"Disposing
connector ... *finished*"</span>);              }@@ -114,11 +117,11 @@         
List&lt;<span class="code-object">String</span>&gt; threadsAfter =
getThreadNames(); -        <span class="code-object">System</span>.out.println(<span
class="code-quote">"threadsBefore = "</span> + threadsBefore);-        <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsAfter  =
"</span> + threadsAfter);+       <span class="code-comment">// <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsBefore =
"</span> + threadsBefore);</span>+       <span class="code-comment">// <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsAfter  =
"</span> + threadsAfter);</span>          <span class="code-comment">//
Assert.assertEquals(threadsBefore, threadsAfter);</span>-+    }     }      <span
class="code-keyword">public</span> <span class="code-keyword">static</span> <span
class="code-keyword">class </span>ClientHandler <span class="code-keyword">extends</span>
IoHandlerAdapter {</pre></div></div>   
==============================

On issue key DIRMINA-1076 the Chain pattern might have been discussed on the following comment: 
==============================
<b>Notes:</b>I've thought about it and have come up with the following patch which
resolves my question about the previous patch.  I was attempting to find a solution which
made the smallest number of changes to resolve the problem.  As it turns out, moving the
<tt>isDisposing()</tt> check above <tt>removeSessions()</tt> resolves the double-removal
issue due to blind removal scheduling based on the Selectors <tt>keys()</tt>. I believe
the method in the following patch to be safe due to the nature of the disposing state;
since disposal is immediate and we don't care about letting Sessions soft-close there is
no need to wakeup the Selector.<b>What was
happening:</b><ul>	<li><tt>process(Session)</tt> would cause self remove via
<tt>scheduleRemoval</tt></li>	<li><tt>removeSessions</tt> removes all sessions scheduled
via <tt>scheduleRemoval</tt></li>	<li><tt>isDisposing()</tt> block would add ALL sessions
from <tt>selector.keys()</tt> to <tt>scheduleRemoval</tt> causing the previously self
removed session to be scheduled, again, using <tt>scheduleRemoval</tt>.
(<tt>selector.keys()</tt> does not update until the next time <tt>select()</tt> is
called.)  The next time <tt>removeSessions</tt> is called, the session counter goes
negative.  The self-destruct routine checks for (<tt>session count == 0)</tt> which never
is satisfied because the session count is negative number.</li></ul>This patch works by
moving the <tt>isDisposing()</tt> block before <tt>removeSessions</tt> utilizing the
<tt>contains(Session)</tt> check of <tt>removeSessions</tt> to prevent a single
<tt>Session</tt> from being added to the list twice.<em>Patch to prevent double-removal of
a single session which causes the counter to go negative preventing the processor from
disposing.</em><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..2715b98 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-659,9 +659,20 @@                     <span class="code-object">long</span> currentTime =
<span class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime); +                    <span class="code-comment">// Disconnect all
sessions immediately <span class="code-keyword">if</span> disposal has
been</span>+                    <span class="code-comment">// requested so that we exit
<span class="code-keyword">this</span> loop eventually.</span>+                    <span
class="code-keyword">if</span> (isDisposing()) {+                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{+                            IoSession session = i.next();+                           
scheduleRemove((S) session);+                        }+                   
}+                                         <span class="code-comment">// And manage
removed sessions</span>                     nSessions -=
removeSessions();-+                    +                    <span
class="code-keyword">assert</span> nSessions &gt; -1 : <span class="code-quote">"Internal
Session Count is Negative"</span>;+                                         <span
class="code-comment">// Last, not least, send Idle events to the idle
sessions</span>                     notifyIdleSessions(currentTime); @@ -685,26 +696,6
@@                         }                          <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }--                    <span
class="code-comment">// Disconnect all sessions immediately <span
class="code-keyword">if</span> disposal has been</span>-                    <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>-                    <span class="code-keyword">if</span>
(isDisposing()) {-                        <span class="code-object">boolean</span> hasKeys
= <span class="code-keyword">false</span>;--                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{-                            IoSession session = i.next();--                           
scheduleRemove((S) session);--                            <span
class="code-keyword">if</span> (session.isActive()) {-                               
hasKeys = <span class="code-keyword">true</span>;-                           
}-                        }--                        <span class="code-keyword">if</span>
(hasKeys) {-                            wakeup();-                       
}                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span></pre></div></div> I had to change
Christoph's <tt>AbstractIoServiceTest</tt> patch because it calls
<tt>connector.dispose(true)</tt> which the documentation and comments above say is
something that should not be done within an <tt>IoFutureListener</tt>.  The reason I had
to change from <tt>true</tt> to <tt>false</tt> was because <tt>dispose(true)</tt> blocks
on itself and preventing the <tt>IoProcessor</tt> thread from ever stopping.  In the
described test, this causes the application to create threads until the OS complains about
it preventing more threads from being created.<em>Patch to make the test run in a
loop</em><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java
b/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.javaindex
2d70f8e..325c4e4 100644---
a/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java+++
b/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java@@ -30,6
+30,7 @@ <span class="code-keyword">import</span>
org.apache.mina.filter.logging.LoggingFilter; <span class="code-keyword">import</span>
org.apache.mina.transport.socket.nio.NioSocketAcceptor; <span
class="code-keyword">import</span>
org.apache.mina.transport.socket.nio.NioSocketConnector;+<span
class="code-keyword">import</span> org.apache.mina.util.AvailablePortFinder; <span
class="code-keyword">import</span> org.junit.Test; <span
class="code-keyword">import</span> org.slf4j.Logger; <span
class="code-keyword">import</span> org.slf4j.LoggerFactory;@@ -48,16 +49,15 @@  */ <span
class="code-keyword">public</span> <span class="code-keyword">class
</span>AbstractIoServiceTest { -    <span class="code-keyword">private</span> <span
class="code-keyword">static</span> <span class="code-keyword">final</span> <span
class="code-object">int</span> PORT = 9123;-     @Test     <span
class="code-keyword">public</span> void testDispose() <span
class="code-keyword">throws</span> IOException, InterruptedException { +        <span
class="code-keyword">while</span> ( <span class="code-keyword">true</span>) {        
List&lt;<span class="code-object">String</span>&gt; threadsBefore =
getThreadNames();          <span class="code-keyword">final</span> IoAcceptor acceptor =
<span class="code-keyword">new</span> NioSocketAcceptor(); -       
acceptor.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());+     <span class="code-comment">//  
acceptor.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());</span>        
acceptor.getFilterChain().addLast(<span class="code-quote">"codec"</span>,                
<span class="code-keyword">new</span> ProtocolCodecFilter(<span
class="code-keyword">new</span> TextLineCodecFactory(Charset.forName(<span
class="code-quote">"UTF-8"</span>)))); @@ -65,7 +65,8 @@         
acceptor.getSessionConfig().setReadBufferSize(2048);        
acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);-       
acceptor.bind(<span class="code-keyword">new</span> InetSocketAddress(PORT));+       
<span class="code-object">int</span> nextAvailable =
AvailablePortFinder.getNextAvailable();+        acceptor.bind(<span
class="code-keyword">new</span> InetSocketAddress(nextAvailable));         <span
class="code-object">System</span>.out.println(<span class="code-quote">"Server running
..."</span>);          <span class="code-keyword">final</span> NioSocketConnector
connector = <span class="code-keyword">new</span> NioSocketConnector();@@ -74,12 +75,12
@@         connector.setConnectTimeoutMillis(30 * 1000L);         
connector.setHandler(<span class="code-keyword">new</span> ClientHandler());-       
connector.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());+      <span class="code-comment">// 
connector.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());</span>        
connector.getFilterChain().addLast(<span
class="code-quote">"codec"</span>,                 <span class="code-keyword">new</span>
ProtocolCodecFilter(<span class="code-keyword">new</span>
TextLineCodecFactory(Charset.forName(<span class="code-quote">"UTF-8"</span>))));         
<span class="code-comment">// Start communication.</span>-        ConnectFuture cf =
connector.connect(<span class="code-keyword">new</span> InetSocketAddress(<span
class="code-quote">"localhost"</span>, 9123));+        ConnectFuture cf =
connector.connect(<span class="code-keyword">new</span> InetSocketAddress(<span
class="code-quote">"localhost"</span>, nextAvailable));        
cf.awaitUninterruptibly();          IoSession session = cf.getSession();@@ -103,7 +104,9
@@             <span class="code-keyword">public</span> void operationComplete(IoFuture
<span class="code-keyword">future</span>) {                 <span
class="code-object">System</span>.out.println(<span class="code-quote">"managed session
count="</span> + connector.getManagedSessionCount());                 <span
class="code-object">System</span>.out.println(<span class="code-quote">"Disposing
connector ..."</span>);-                connector.dispose(<span
class="code-keyword">true</span>);+                <span class="code-comment">// the doc
states that the following should not be called with parameter TRUE from an
IoFutureListener?!</span>+                <span class="code-comment">// on the other hand,
using FALSE does not work either</span>+                connector.dispose(<span
class="code-keyword">false</span>);                     <span
class="code-object">System</span>.out.println(<span class="code-quote">"Disposing
connector ... *finished*"</span>);              }@@ -114,11 +117,11 @@         
List&lt;<span class="code-object">String</span>&gt; threadsAfter =
getThreadNames(); -        <span class="code-object">System</span>.out.println(<span
class="code-quote">"threadsBefore = "</span> + threadsBefore);-        <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsAfter  =
"</span> + threadsAfter);+       <span class="code-comment">// <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsBefore =
"</span> + threadsBefore);</span>+       <span class="code-comment">// <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsAfter  =
"</span> + threadsAfter);</span>          <span class="code-comment">//
Assert.assertEquals(threadsBefore, threadsAfter);</span>-+    }     }      <span
class="code-keyword">public</span> <span class="code-keyword">static</span> <span
class="code-keyword">class </span>ClientHandler <span class="code-keyword">extends</span>
IoHandlerAdapter {</pre></div></div>   
==============================

New Comment: 
<b>Notes:</b>I've thought about it and have come up with the following patch which
resolves my question about the previous patch.  I was attempting to find a solution which
made the smallest number of changes to resolve the problem.  As it turns out, moving the
<tt>isDisposing()</tt> check above <tt>removeSessions()</tt> resolves the double-removal
issue due to blind removal scheduling based on the Selectors <tt>keys()</tt>. I believe
the method in the following patch to be safe due to the nature of the disposing state;
since disposal is immediate and we don't care about letting Sessions soft-close there is
no need to wakeup the Selector.<b>What was
happening:</b><ul>	<li><tt>process(Session)</tt> would cause self remove via
<tt>scheduleRemoval</tt></li>	<li><tt>removeSessions</tt> removes all sessions scheduled
via <tt>scheduleRemoval</tt></li>	<li><tt>isDisposing()</tt> block would add ALL sessions
from <tt>selector.keys()</tt> to <tt>scheduleRemoval</tt> causing the previously self
removed session to be scheduled, again, using <tt>scheduleRemoval</tt>.
(<tt>selector.keys()</tt> does not update until the next time <tt>select()</tt> is
called.)  The next time <tt>removeSessions</tt> is called, the session counter goes
negative.  The self-destruct routine checks for (<tt>session count == 0)</tt> which never
is satisfied because the session count is negative number.</li></ul>This patch works by
moving the <tt>isDisposing()</tt> block before <tt>removeSessions</tt> utilizing the
<tt>contains(Session)</tt> check of <tt>removeSessions</tt> to prevent a single
<tt>Session</tt> from being added to the list twice.<em>Patch to prevent double-removal of
a single session which causes the counter to go negative preventing the processor from
disposing.</em><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..2715b98 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-659,9 +659,20 @@                     <span class="code-object">long</span> currentTime =
<span class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime); +                    <span class="code-comment">// Disconnect all
sessions immediately <span class="code-keyword">if</span> disposal has
been</span>+                    <span class="code-comment">// requested so that we exit
<span class="code-keyword">this</span> loop eventually.</span>+                    <span
class="code-keyword">if</span> (isDisposing()) {+                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{+                            IoSession session = i.next();+                           
scheduleRemove((S) session);+                        }+                   
}+                                         <span class="code-comment">// And manage
removed sessions</span>                     nSessions -=
removeSessions();-+                    +                    <span
class="code-keyword">assert</span> nSessions &gt; -1 : <span class="code-quote">"Internal
Session Count is Negative"</span>;+                                         <span
class="code-comment">// Last, not least, send Idle events to the idle
sessions</span>                     notifyIdleSessions(currentTime); @@ -685,26 +696,6
@@                         }                          <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }--                    <span
class="code-comment">// Disconnect all sessions immediately <span
class="code-keyword">if</span> disposal has been</span>-                    <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>-                    <span class="code-keyword">if</span>
(isDisposing()) {-                        <span class="code-object">boolean</span> hasKeys
= <span class="code-keyword">false</span>;--                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{-                            IoSession session = i.next();--                           
scheduleRemove((S) session);--                            <span
class="code-keyword">if</span> (session.isActive()) {-                               
hasKeys = <span class="code-keyword">true</span>;-                           
}-                        }--                        <span class="code-keyword">if</span>
(hasKeys) {-                            wakeup();-                       
}                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span></pre></div></div> I had to change
Christoph's <tt>AbstractIoServiceTest</tt> patch because it calls
<tt>connector.dispose(true)</tt> which the documentation and comments above say is
something that should not be done within an <tt>IoFutureListener</tt>.  The reason I had
to change from <tt>true</tt> to <tt>false</tt> was because <tt>dispose(true)</tt> blocks
on itself and preventing the <tt>IoProcessor</tt> thread from ever stopping.  In the
described test, this causes the application to create threads until the OS complains about
it preventing more threads from being created.<em>Patch to make the test run in a
loop</em><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java
b/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.javaindex
2d70f8e..325c4e4 100644---
a/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java+++
b/mina-core/src/test/java/org/apache/mina/core/service/AbstractIoServiceTest.java@@ -30,6
+30,7 @@ <span class="code-keyword">import</span>
org.apache.mina.filter.logging.LoggingFilter; <span class="code-keyword">import</span>
org.apache.mina.transport.socket.nio.NioSocketAcceptor; <span
class="code-keyword">import</span>
org.apache.mina.transport.socket.nio.NioSocketConnector;+<span
class="code-keyword">import</span> org.apache.mina.util.AvailablePortFinder; <span
class="code-keyword">import</span> org.junit.Test; <span
class="code-keyword">import</span> org.slf4j.Logger; <span
class="code-keyword">import</span> org.slf4j.LoggerFactory;@@ -48,16 +49,15 @@  */ <span
class="code-keyword">public</span> <span class="code-keyword">class
</span>AbstractIoServiceTest { -    <span class="code-keyword">private</span> <span
class="code-keyword">static</span> <span class="code-keyword">final</span> <span
class="code-object">int</span> PORT = 9123;-     @Test     <span
class="code-keyword">public</span> void testDispose() <span
class="code-keyword">throws</span> IOException, InterruptedException { +        <span
class="code-keyword">while</span> ( <span class="code-keyword">true</span>) {        
List&lt;<span class="code-object">String</span>&gt; threadsBefore =
getThreadNames();          <span class="code-keyword">final</span> IoAcceptor acceptor =
<span class="code-keyword">new</span> NioSocketAcceptor(); -       
acceptor.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());+     <span class="code-comment">//  
acceptor.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());</span>        
acceptor.getFilterChain().addLast(<span class="code-quote">"codec"</span>,                
<span class="code-keyword">new</span> ProtocolCodecFilter(<span
class="code-keyword">new</span> TextLineCodecFactory(Charset.forName(<span
class="code-quote">"UTF-8"</span>)))); @@ -65,7 +65,8 @@         
acceptor.getSessionConfig().setReadBufferSize(2048);        
acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);-       
acceptor.bind(<span class="code-keyword">new</span> InetSocketAddress(PORT));+       
<span class="code-object">int</span> nextAvailable =
AvailablePortFinder.getNextAvailable();+        acceptor.bind(<span
class="code-keyword">new</span> InetSocketAddress(nextAvailable));         <span
class="code-object">System</span>.out.println(<span class="code-quote">"Server running
..."</span>);          <span class="code-keyword">final</span> NioSocketConnector
connector = <span class="code-keyword">new</span> NioSocketConnector();@@ -74,12 +75,12
@@         connector.setConnectTimeoutMillis(30 * 1000L);         
connector.setHandler(<span class="code-keyword">new</span> ClientHandler());-       
connector.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());+      <span class="code-comment">// 
connector.getFilterChain().addLast(<span class="code-quote">"logger"</span>, <span
class="code-keyword">new</span> LoggingFilter());</span>        
connector.getFilterChain().addLast(<span
class="code-quote">"codec"</span>,                 <span class="code-keyword">new</span>
ProtocolCodecFilter(<span class="code-keyword">new</span>
TextLineCodecFactory(Charset.forName(<span class="code-quote">"UTF-8"</span>))));         
<span class="code-comment">// Start communication.</span>-        ConnectFuture cf =
connector.connect(<span class="code-keyword">new</span> InetSocketAddress(<span
class="code-quote">"localhost"</span>, 9123));+        ConnectFuture cf =
connector.connect(<span class="code-keyword">new</span> InetSocketAddress(<span
class="code-quote">"localhost"</span>, nextAvailable));        
cf.awaitUninterruptibly();          IoSession session = cf.getSession();@@ -103,7 +104,9
@@             <span class="code-keyword">public</span> void operationComplete(IoFuture
<span class="code-keyword">future</span>) {                 <span
class="code-object">System</span>.out.println(<span class="code-quote">"managed session
count="</span> + connector.getManagedSessionCount());                 <span
class="code-object">System</span>.out.println(<span class="code-quote">"Disposing
connector ..."</span>);-                connector.dispose(<span
class="code-keyword">true</span>);+                <span class="code-comment">// the doc
states that the following should not be called with parameter TRUE from an
IoFutureListener?!</span>+                <span class="code-comment">// on the other hand,
using FALSE does not work either</span>+                connector.dispose(<span
class="code-keyword">false</span>);                     <span
class="code-object">System</span>.out.println(<span class="code-quote">"Disposing
connector ... *finished*"</span>);              }@@ -114,11 +117,11 @@         
List&lt;<span class="code-object">String</span>&gt; threadsAfter =
getThreadNames(); -        <span class="code-object">System</span>.out.println(<span
class="code-quote">"threadsBefore = "</span> + threadsBefore);-        <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsAfter  =
"</span> + threadsAfter);+       <span class="code-comment">// <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsBefore =
"</span> + threadsBefore);</span>+       <span class="code-comment">// <span
class="code-object">System</span>.out.println(<span class="code-quote">"threadsAfter  =
"</span> + threadsAfter);</span>          <span class="code-comment">//
Assert.assertEquals(threadsBefore, threadsAfter);</span>-+    }     }      <span
class="code-keyword">public</span> <span class="code-keyword">static</span> <span
class="code-keyword">class </span>ClientHandler <span class="code-keyword">extends</span>
IoHandlerAdapter {</pre></div></div>   


New Comment: 
Hi Jonathan,many thanks for the quick turnaround. Much appreciated!I have tested your
changes and it is looking very good so far. I have only a few more questions:<br/>In the
<tt>AbstractIoServiceTest</tt> calling <tt>dispose(true)</tt> not from IoFutureListener
works as expected (i.e. all threads are cleaned up). Calling <tt>dispose(true)</tt> from
an IoFutureListener leads to more and more threads being created (as you noticed). The
question is if there is some way to prevent programmatically that <tt>dispose(true)</tt>
is called from an IoFutureListener? The way it is now might lead to subtle problems
(although in very unlikely scenarios). And from my own experience people tend to not read
the JavaDocs. <img class="emoticon"
src="https://issues.apache.org/jira/images/icons/emoticons/wink.png" height="16"
width="16" align="absmiddle" alt="" border="0"/>Is this problem (that you fixed) more
likely to happen when a session gets closed unexpectedly? Because in our (QuickFIX/J) test
suite the problem often seemed to manifest itself right after there was a
<tt>WriteToClosedSessionException</tt>.Is this issue going to be fixed in MINA 2.0.17? Is
there any ETA for MINA 2.0.17?<br/>(There also is <a
href="https://issues.apache.org/jira/browse/DIRMINA-1057" title="AbstractIoSession
getScheduledWriteMessages always -negative?" class="issue-link"
data-issue-key="DIRMINA-1057"><del>DIRMINA-1057</del></a> which fixes another problem in
QuickFIX/J)Many thanks again for your help on this.Cheers,<br/>Chris. 


New Comment: 
The proposed patch makes a lot of sense. There is no reason for managing removed sessions
when the service is being disposed anyway. 


New Comment: 
Christoph,There could be a way to detect the potential deadlock when calling
<tt>dispose(true)</tt> but it would be a violation of the <tt>dispose(true)</tt> contract
to change the behavior to avoid the deadlock.  I think there is some other deadlock
detection that Mina detects and throws an exception.  I'll have to look into that one.
 The only thing I would feel comfortable doing would be throwing an exception indicating
the requested action will cause deadlock. 


On issue key DIRMINA-1076 the  state  pattern might have been discussed on the following comment: 
==============================
<b>Why Patch 2.0 doesn't fully work</b>Seems like <tt>Patch 2.0</tt> had a problem where
<tt>scheduleRemove(Session)</tt> would be called concurrently and have it added to the
<tt>removingSessions</tt> queue twice despite the check for <tt>contains(Session)</tt>
because both threads could check for contains(Session) and return a false-negative which
caused the <tt>Session</tt> to be added twice.  <tt>Queue</tt> lacks atomic operations
like <tt>putIfAbsent</tt> which makes it harder to solve the problem. <b>Option 1</b>One
option would be to <tt>synchronize</tt> the entire code-block; however, I felt that it
wasn't the safest option available because <tt>scheduleRemove(Session)</tt> could still be
called by an external actor after the <tt>Processor</tt> has executed
<tt>removeSessions()</tt> but before the <tt>for(...)</tt> loop cycles causing the
<tt>Session</tt> to be removed twice again even if <tt>selector.keys()</tt> was used as a
reference point.  The sequential operations would not be concurrent relative to each other
unless <tt>synchronize</tt> blocks were added all over the place.<b>Option 2</b>The safest
option to avoid this is to create a new <tt>queue</tt> which contains the active sessions
only.  The new queue serves as an atomic reference of whether a <tt>Session</tt> was
already removed or not.<b>Option 2, Liability</b>The new <tt>Queue</tt> could become a
memory leak if <tt>Sessions</tt> are added or removed in some way without calling
<tt>addNow(Session)</tt> or <tt>removeNow(Session)</tt>.<b>Patch 3.0 (Option 2) - Passes
Unit Tests</b><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..27e7d76 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-23,6 +23,7 @@ <span class="code-keyword">import</span>
java.net.PortUnreachableException; <span class="code-keyword">import</span>
java.nio.channels.ClosedSelectorException; <span class="code-keyword">import</span>
java.util.ArrayList;+<span class="code-keyword">import</span> java.util.Collections; <span
class="code-keyword">import</span> java.util.Iterator; <span
class="code-keyword">import</span> java.util.List; <span
class="code-keyword">import</span> java.util.Queue;@@ -86,6 +87,9 @@      <span
class="code-comment">/** A Session queue containing the newly created sessions
*/</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; newSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();+    +    <span
class="code-comment">/** A queue used to store all active sessions */</span>+    <span
class="code-keyword">private</span> <span class="code-keyword">final</span> Queue&lt;S&gt;
activeSessions = <span class="code-keyword">new</span>
ConcurrentLinkedQueue&lt;&gt;();      <span class="code-comment">/** A queue used to store
the sessions to be removed */</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; removingSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();@@ -239,7 +243,9 @@     
*      * @<span class="code-keyword">return</span> {@link Iterator} of {@link
IoSession}      */-    <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> Iterator&lt;S&gt; allSessions();+    <span
class="code-keyword">protected</span> Iterator&lt;S&gt; allSessions() {+        <span
class="code-keyword">return</span>
Collections.unmodifiableCollection(activeSessions).iterator();+    }      /**      * Get
an {@link Iterator} <span class="code-keyword">for</span> the list of {@link IoSession}
found selected@@ -411,7 +417,7 @@     }      <span class="code-keyword">private</span>
void scheduleRemove(S session) {-        <span class="code-keyword">if</span>
(!removingSessions.contains(session)) {+        <span class="code-keyword">if</span>
(!removingSessions.contains(session) &amp;&amp; activeSessions.contains(session))
{             removingSessions.add(session);         }     }@@ -659,9 +665,20
@@                     <span class="code-object">long</span> currentTime = <span
class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime); +                    <span class="code-comment">// Disconnect all
sessions immediately <span class="code-keyword">if</span> disposal has
been</span>+                    <span class="code-comment">// requested so that we exit
<span class="code-keyword">this</span> loop eventually.</span>+                    <span
class="code-keyword">if</span> (isDisposing()) {+                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{+                            IoSession session = i.next();+                           
scheduleRemove((S) session);+                        }+                   
}+                                         <span class="code-comment">// And manage
removed sessions</span>                     nSessions -=
removeSessions();-+                    +                    <span
class="code-keyword">assert</span> nSessions &gt; -1 : <span class="code-quote">"Internal
Session Count is Negative"</span>;+                                         <span
class="code-comment">// Last, not least, send Idle events to the idle
sessions</span>                     notifyIdleSessions(currentTime); @@ -685,26 +702,6
@@                         }                          <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }--                    <span
class="code-comment">// Disconnect all sessions immediately <span
class="code-keyword">if</span> disposal has been</span>-                    <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>-                    <span class="code-keyword">if</span>
(isDisposing()) {-                        <span class="code-object">boolean</span> hasKeys
= <span class="code-keyword">false</span>;--                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{-                            IoSession session = i.next();--                           
scheduleRemove((S) session);--                            <span
class="code-keyword">if</span> (session.isActive()) {-                               
hasKeys = <span class="code-keyword">true</span>;-                           
}-                        }--                        <span class="code-keyword">if</span>
(hasKeys) {-                            wakeup();-                       
}                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span>@@ -819,30 +816,41 @@         <span
class="code-keyword">private</span> <span class="code-object">boolean</span> addNow(S
session) {             <span class="code-object">boolean</span> registered = <span
class="code-keyword">false</span>; -            <span class="code-keyword">try</span>
{-                init(session);-                registered = <span
class="code-keyword">true</span>;+        <span class="code-keyword">try</span> {+      
 <span class="code-keyword">if</span> (activeSessions.contains(session)) {+           
<span class="code-keyword">return</span> <span class="code-keyword">true</span>;+      
 } -                <span class="code-comment">// Build the filter chain of <span
class="code-keyword">this</span> session.</span>-                IoFilterChainBuilder
chainBuilder = session.getService().getFilterChainBuilder();-               
chainBuilder.buildFilterChain(session.getFilterChain());+        <span
class="code-keyword">if</span> (activeSessions.add(session)) {+           
init(session);+            registered = <span
class="code-keyword">true</span>; -                <span class="code-comment">//
DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here</span>-                <span
class="code-comment">// in
AbstractIoFilterChain.fireSessionOpened().</span>-                <span
class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>-                IoServiceListenerSupport listeners = ((AbstractIoService)
session.getService()).getListeners();-               
listeners.fireSessionCreated(session);-            } <span
class="code-keyword">catch</span> (Exception e) {-               
ExceptionMonitor.getInstance().exceptionCaught(e);+            <span
class="code-comment">// Build the filter chain of <span class="code-keyword">this</span>
session.</span>+            IoFilterChainBuilder chainBuilder = session.getService()+  
             .getFilterChainBuilder();+           
chainBuilder.buildFilterChain(session.getFilterChain()); -                <span
class="code-keyword">try</span> {-                    destroy(session);-                }
<span class="code-keyword">catch</span> (Exception e1) {-                   
ExceptionMonitor.getInstance().exceptionCaught(e1);-                } <span
class="code-keyword">finally</span> {-                    registered = <span
class="code-keyword">false</span>;-                }-            }+            <span
class="code-comment">// DefaultIoFilterChain.CONNECT_FUTURE is cleared inside</span>+  
         <span class="code-comment">// here</span>+            <span
class="code-comment">// in AbstractIoFilterChain.fireSessionOpened().</span>+           
<span class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>+            IoServiceListenerSupport listeners = ((AbstractIoService)
session+                .getService()).getListeners();+           
listeners.fireSessionCreated(session);+        }+        } <span
class="code-keyword">catch</span> (Exception e) {+      
 ExceptionMonitor.getInstance().exceptionCaught(e);++        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+            <span
class="code-keyword">try</span> {+            destroy(session);+            } <span
class="code-keyword">catch</span> (Exception e1) {+          
 ExceptionMonitor.getInstance().exceptionCaught(e1);+            } <span
class="code-keyword">finally</span> {+            registered = <span
class="code-keyword">false</span>;+            }+        }+        }              <span
class="code-keyword">return</span> registered;         }@@ -850,40 +858,36 @@        
<span class="code-keyword">private</span> <span class="code-object">int</span>
removeSessions() {             <span class="code-object">int</span> removedSessions =
0; -            <span class="code-keyword">for</span> (S session =
removingSessions.poll(); session != <span class="code-keyword">null</span>; session =
removingSessions.poll()) {-                SessionState state = getState(session);+       
<span class="code-keyword">for</span> (S session = removingSessions.poll(); session !=
<span class="code-keyword">null</span>; session = removingSessions .poll()) {+      
 SessionState state = getState(session); -                <span class="code-comment">//
Now deal with the removal accordingly to the session's state</span>-                <span
class="code-keyword">switch</span> (state) {-                <span
class="code-keyword">case</span> OPENED:-                    <span class="code-comment">//
Try to remove <span class="code-keyword">this</span> session</span>-                   
<span class="code-keyword">if</span> (removeNow(session)) {-                       
removedSessions++;-                    }+        <span class="code-comment">// Now deal
with the removal accordingly to the session's</span>+        <span class="code-comment">//
state</span>+        <span class="code-keyword">switch</span> (state) {+        <span
class="code-keyword">case</span> OPENED:+        <span class="code-keyword">case</span>
CLOSING:+            <span class="code-comment">// Try to remove <span
class="code-keyword">this</span> session</span>+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">break</span>;+            <span
class="code-keyword">break</span>; -                <span class="code-keyword">case</span>
CLOSING:-                    <span class="code-comment">// Skip <span
class="code-keyword">if</span> channel is already closed</span>-                    <span
class="code-comment">// In any <span class="code-keyword">case</span>, remove the session
from the queue</span>-                    removedSessions++;-                    <span
class="code-keyword">break</span>;+        <span class="code-keyword">case</span>
OPENING:+            <span class="code-comment">// Remove session from the newSessions
queue and</span>+            <span class="code-comment">// remove it</span>+           
newSessions.remove(session); -                <span class="code-keyword">case</span>
OPENING:-                    <span class="code-comment">// Remove session from the
newSessions queue and</span>-                    <span class="code-comment">// remove
it</span>-                    newSessions.remove(session);+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">if</span> (removeNow(session))
{-                        removedSessions++;-                    }+            <span
class="code-keyword">break</span>; -                    <span
class="code-keyword">break</span>;--                <span
class="code-keyword">default</span>:-                    <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span
class="code-object">String</span>.valueOf(state));-                }-            }+      
 <span class="code-keyword">default</span>:+            <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span class="code-object">String</span>.valueOf(state));+      
 }+        }              <span class="code-keyword">return</span>
removedSessions;         }@@ -1145,27 +1149,32 @@         }          <span
class="code-keyword">private</span> <span class="code-object">boolean</span> removeNow(S
session) {-            clearWriteRequestQueue(session);+        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+      
 clearWriteRequestQueue(session); -            <span class="code-keyword">try</span>
{-                destroy(session);-                <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;-            }
<span class="code-keyword">catch</span> (Exception e) {-                IoFilterChain
filterChain = session.getFilterChain();-               
filterChain.fireExceptionCaught(e);-            } <span
class="code-keyword">finally</span> {-                <span
class="code-keyword">try</span> {-                   
clearWriteRequestQueue(session);-                    ((AbstractIoService)
session.getService()).getListeners().fireSessionDestroyed(session);-                }
<span class="code-keyword">catch</span> (Exception e) {-                    <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span> point.</span>-                    <span
class="code-comment">// We <span class="code-keyword">do</span> not want any exception
thrown from <span class="code-keyword">this</span> <span
class="code-quote">"cleanup"</span> code</span>-                    <span
class="code-comment">// to change</span>-                    <span class="code-comment">//
the <span class="code-keyword">return</span> value by bubbling
up.</span>-                    IoFilterChain filterChain =
session.getFilterChain();-                   
filterChain.fireExceptionCaught(e);-                }-            }+        <span
class="code-keyword">try</span> {+            destroy(session);+            <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;+        } <span
class="code-keyword">catch</span> (Exception e) {+            IoFilterChain filterChain =
session.getFilterChain();+            filterChain.fireExceptionCaught(e);+        } <span
class="code-keyword">finally</span> {+            <span class="code-keyword">try</span>
{+            clearWriteRequestQueue(session);+            ((AbstractIoService)
session.getService())+                .getListeners().fireSessionDestroyed(session);+  
         } <span class="code-keyword">catch</span> (Exception e) {+            <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span></span>+            <span class="code-comment">//
point.</span>+            <span class="code-comment">// We <span
class="code-keyword">do</span> not want any exception thrown from <span
class="code-keyword">this</span></span>+            <span class="code-comment">// <span
class="code-quote">"cleanup"</span> code</span>+            <span class="code-comment">//
to change</span>+            <span class="code-comment">// the <span
class="code-keyword">return</span> value by bubbling up.</span>+            IoFilterChain
filterChain = session.getFilterChain();+            filterChain.fireExceptionCaught(e);+  
         }+        }+        }              <span class="code-keyword">return</span> <span
class="code-keyword">false</span>;         }diff --git
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.javaindex
3b0fa40..fc60124 100644---
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java@@ -149,15
+149,20 @@         }     } +<span class="code-comment">//    @Override</span>+<span
class="code-comment">//    <span class="code-keyword">protected</span>
Iterator&lt;NioSession&gt; allSessions() {</span>+<span class="code-comment">//       
selectorLock.readLock().lock();</span>+<span class="code-comment">//        </span>+<span
class="code-comment">//        <span class="code-keyword">try</span> {</span>+<span
class="code-comment">//            <span class="code-keyword">return</span> <span
class="code-keyword">new</span> IoSessionIterator(selector.keys());</span>+<span
class="code-comment">//        } <span class="code-keyword">finally</span> {</span>+<span
class="code-comment">//            selectorLock.readLock().unlock();</span>+<span
class="code-comment">//        }</span>+<span class="code-comment">//    }</span>+        
@Override     <span class="code-keyword">protected</span> Iterator&lt;NioSession&gt;
allSessions() {-        selectorLock.readLock().lock();-        -        <span
class="code-keyword">try</span> {-            <span class="code-keyword">return</span>
<span class="code-keyword">new</span> IoSessionIterator(selector.keys());-        } <span
class="code-keyword">finally</span> {-           
selectorLock.readLock().unlock();-        }+        <span
class="code-keyword">return</span> <span
class="code-keyword">super</span>.allSessions();     }      @SuppressWarnings(<span
class="code-quote">"synthetic-access"</span>)@@ -182,14 +187,13 @@     @Override     <span
class="code-keyword">protected</span> void destroy(NioSession session) <span
class="code-keyword">throws</span> Exception {         ByteChannel ch =
session.getChannel();-                 SelectionKey key =
session.getSelectionKey();                  <span class="code-keyword">if</span> (key !=
<span class="code-keyword">null</span>) {             key.cancel();         }       
 -        <span class="code-keyword">if</span> ( ch.isOpen() ) {+        <span
class="code-keyword">if</span> (ch.isOpen() ) {             ch.close();         }    
}</pre></div></div> 
==============================

On issue key DIRMINA-1076 the mediate pattern might have been discussed on the following comment: 
==============================
<b>Why Patch 2.0 doesn't fully work</b>Seems like <tt>Patch 2.0</tt> had a problem where
<tt>scheduleRemove(Session)</tt> would be called concurrently and have it added to the
<tt>removingSessions</tt> queue twice despite the check for <tt>contains(Session)</tt>
because both threads could check for contains(Session) and return a false-negative which
caused the <tt>Session</tt> to be added twice.  <tt>Queue</tt> lacks atomic operations
like <tt>putIfAbsent</tt> which makes it harder to solve the problem. <b>Option 1</b>One
option would be to <tt>synchronize</tt> the entire code-block; however, I felt that it
wasn't the safest option available because <tt>scheduleRemove(Session)</tt> could still be
called by an external actor after the <tt>Processor</tt> has executed
<tt>removeSessions()</tt> but before the <tt>for(...)</tt> loop cycles causing the
<tt>Session</tt> to be removed twice again even if <tt>selector.keys()</tt> was used as a
reference point.  The sequential operations would not be concurrent relative to each other
unless <tt>synchronize</tt> blocks were added all over the place.<b>Option 2</b>The safest
option to avoid this is to create a new <tt>queue</tt> which contains the active sessions
only.  The new queue serves as an atomic reference of whether a <tt>Session</tt> was
already removed or not.<b>Option 2, Liability</b>The new <tt>Queue</tt> could become a
memory leak if <tt>Sessions</tt> are added or removed in some way without calling
<tt>addNow(Session)</tt> or <tt>removeNow(Session)</tt>.<b>Patch 3.0 (Option 2) - Passes
Unit Tests</b><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..27e7d76 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-23,6 +23,7 @@ <span class="code-keyword">import</span>
java.net.PortUnreachableException; <span class="code-keyword">import</span>
java.nio.channels.ClosedSelectorException; <span class="code-keyword">import</span>
java.util.ArrayList;+<span class="code-keyword">import</span> java.util.Collections; <span
class="code-keyword">import</span> java.util.Iterator; <span
class="code-keyword">import</span> java.util.List; <span
class="code-keyword">import</span> java.util.Queue;@@ -86,6 +87,9 @@      <span
class="code-comment">/** A Session queue containing the newly created sessions
*/</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; newSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();+    +    <span
class="code-comment">/** A queue used to store all active sessions */</span>+    <span
class="code-keyword">private</span> <span class="code-keyword">final</span> Queue&lt;S&gt;
activeSessions = <span class="code-keyword">new</span>
ConcurrentLinkedQueue&lt;&gt;();      <span class="code-comment">/** A queue used to store
the sessions to be removed */</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; removingSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();@@ -239,7 +243,9 @@     
*      * @<span class="code-keyword">return</span> {@link Iterator} of {@link
IoSession}      */-    <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> Iterator&lt;S&gt; allSessions();+    <span
class="code-keyword">protected</span> Iterator&lt;S&gt; allSessions() {+        <span
class="code-keyword">return</span>
Collections.unmodifiableCollection(activeSessions).iterator();+    }      /**      * Get
an {@link Iterator} <span class="code-keyword">for</span> the list of {@link IoSession}
found selected@@ -411,7 +417,7 @@     }      <span class="code-keyword">private</span>
void scheduleRemove(S session) {-        <span class="code-keyword">if</span>
(!removingSessions.contains(session)) {+        <span class="code-keyword">if</span>
(!removingSessions.contains(session) &amp;&amp; activeSessions.contains(session))
{             removingSessions.add(session);         }     }@@ -659,9 +665,20
@@                     <span class="code-object">long</span> currentTime = <span
class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime); +                    <span class="code-comment">// Disconnect all
sessions immediately <span class="code-keyword">if</span> disposal has
been</span>+                    <span class="code-comment">// requested so that we exit
<span class="code-keyword">this</span> loop eventually.</span>+                    <span
class="code-keyword">if</span> (isDisposing()) {+                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{+                            IoSession session = i.next();+                           
scheduleRemove((S) session);+                        }+                   
}+                                         <span class="code-comment">// And manage
removed sessions</span>                     nSessions -=
removeSessions();-+                    +                    <span
class="code-keyword">assert</span> nSessions &gt; -1 : <span class="code-quote">"Internal
Session Count is Negative"</span>;+                                         <span
class="code-comment">// Last, not least, send Idle events to the idle
sessions</span>                     notifyIdleSessions(currentTime); @@ -685,26 +702,6
@@                         }                          <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }--                    <span
class="code-comment">// Disconnect all sessions immediately <span
class="code-keyword">if</span> disposal has been</span>-                    <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>-                    <span class="code-keyword">if</span>
(isDisposing()) {-                        <span class="code-object">boolean</span> hasKeys
= <span class="code-keyword">false</span>;--                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{-                            IoSession session = i.next();--                           
scheduleRemove((S) session);--                            <span
class="code-keyword">if</span> (session.isActive()) {-                               
hasKeys = <span class="code-keyword">true</span>;-                           
}-                        }--                        <span class="code-keyword">if</span>
(hasKeys) {-                            wakeup();-                       
}                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span>@@ -819,30 +816,41 @@         <span
class="code-keyword">private</span> <span class="code-object">boolean</span> addNow(S
session) {             <span class="code-object">boolean</span> registered = <span
class="code-keyword">false</span>; -            <span class="code-keyword">try</span>
{-                init(session);-                registered = <span
class="code-keyword">true</span>;+        <span class="code-keyword">try</span> {+      
 <span class="code-keyword">if</span> (activeSessions.contains(session)) {+           
<span class="code-keyword">return</span> <span class="code-keyword">true</span>;+      
 } -                <span class="code-comment">// Build the filter chain of <span
class="code-keyword">this</span> session.</span>-                IoFilterChainBuilder
chainBuilder = session.getService().getFilterChainBuilder();-               
chainBuilder.buildFilterChain(session.getFilterChain());+        <span
class="code-keyword">if</span> (activeSessions.add(session)) {+           
init(session);+            registered = <span
class="code-keyword">true</span>; -                <span class="code-comment">//
DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here</span>-                <span
class="code-comment">// in
AbstractIoFilterChain.fireSessionOpened().</span>-                <span
class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>-                IoServiceListenerSupport listeners = ((AbstractIoService)
session.getService()).getListeners();-               
listeners.fireSessionCreated(session);-            } <span
class="code-keyword">catch</span> (Exception e) {-               
ExceptionMonitor.getInstance().exceptionCaught(e);+            <span
class="code-comment">// Build the filter chain of <span class="code-keyword">this</span>
session.</span>+            IoFilterChainBuilder chainBuilder = session.getService()+  
             .getFilterChainBuilder();+           
chainBuilder.buildFilterChain(session.getFilterChain()); -                <span
class="code-keyword">try</span> {-                    destroy(session);-                }
<span class="code-keyword">catch</span> (Exception e1) {-                   
ExceptionMonitor.getInstance().exceptionCaught(e1);-                } <span
class="code-keyword">finally</span> {-                    registered = <span
class="code-keyword">false</span>;-                }-            }+            <span
class="code-comment">// DefaultIoFilterChain.CONNECT_FUTURE is cleared inside</span>+  
         <span class="code-comment">// here</span>+            <span
class="code-comment">// in AbstractIoFilterChain.fireSessionOpened().</span>+           
<span class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>+            IoServiceListenerSupport listeners = ((AbstractIoService)
session+                .getService()).getListeners();+           
listeners.fireSessionCreated(session);+        }+        } <span
class="code-keyword">catch</span> (Exception e) {+      
 ExceptionMonitor.getInstance().exceptionCaught(e);++        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+            <span
class="code-keyword">try</span> {+            destroy(session);+            } <span
class="code-keyword">catch</span> (Exception e1) {+          
 ExceptionMonitor.getInstance().exceptionCaught(e1);+            } <span
class="code-keyword">finally</span> {+            registered = <span
class="code-keyword">false</span>;+            }+        }+        }              <span
class="code-keyword">return</span> registered;         }@@ -850,40 +858,36 @@        
<span class="code-keyword">private</span> <span class="code-object">int</span>
removeSessions() {             <span class="code-object">int</span> removedSessions =
0; -            <span class="code-keyword">for</span> (S session =
removingSessions.poll(); session != <span class="code-keyword">null</span>; session =
removingSessions.poll()) {-                SessionState state = getState(session);+       
<span class="code-keyword">for</span> (S session = removingSessions.poll(); session !=
<span class="code-keyword">null</span>; session = removingSessions .poll()) {+      
 SessionState state = getState(session); -                <span class="code-comment">//
Now deal with the removal accordingly to the session's state</span>-                <span
class="code-keyword">switch</span> (state) {-                <span
class="code-keyword">case</span> OPENED:-                    <span class="code-comment">//
Try to remove <span class="code-keyword">this</span> session</span>-                   
<span class="code-keyword">if</span> (removeNow(session)) {-                       
removedSessions++;-                    }+        <span class="code-comment">// Now deal
with the removal accordingly to the session's</span>+        <span class="code-comment">//
state</span>+        <span class="code-keyword">switch</span> (state) {+        <span
class="code-keyword">case</span> OPENED:+        <span class="code-keyword">case</span>
CLOSING:+            <span class="code-comment">// Try to remove <span
class="code-keyword">this</span> session</span>+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">break</span>;+            <span
class="code-keyword">break</span>; -                <span class="code-keyword">case</span>
CLOSING:-                    <span class="code-comment">// Skip <span
class="code-keyword">if</span> channel is already closed</span>-                    <span
class="code-comment">// In any <span class="code-keyword">case</span>, remove the session
from the queue</span>-                    removedSessions++;-                    <span
class="code-keyword">break</span>;+        <span class="code-keyword">case</span>
OPENING:+            <span class="code-comment">// Remove session from the newSessions
queue and</span>+            <span class="code-comment">// remove it</span>+           
newSessions.remove(session); -                <span class="code-keyword">case</span>
OPENING:-                    <span class="code-comment">// Remove session from the
newSessions queue and</span>-                    <span class="code-comment">// remove
it</span>-                    newSessions.remove(session);+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">if</span> (removeNow(session))
{-                        removedSessions++;-                    }+            <span
class="code-keyword">break</span>; -                    <span
class="code-keyword">break</span>;--                <span
class="code-keyword">default</span>:-                    <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span
class="code-object">String</span>.valueOf(state));-                }-            }+      
 <span class="code-keyword">default</span>:+            <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span class="code-object">String</span>.valueOf(state));+      
 }+        }              <span class="code-keyword">return</span>
removedSessions;         }@@ -1145,27 +1149,32 @@         }          <span
class="code-keyword">private</span> <span class="code-object">boolean</span> removeNow(S
session) {-            clearWriteRequestQueue(session);+        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+      
 clearWriteRequestQueue(session); -            <span class="code-keyword">try</span>
{-                destroy(session);-                <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;-            }
<span class="code-keyword">catch</span> (Exception e) {-                IoFilterChain
filterChain = session.getFilterChain();-               
filterChain.fireExceptionCaught(e);-            } <span
class="code-keyword">finally</span> {-                <span
class="code-keyword">try</span> {-                   
clearWriteRequestQueue(session);-                    ((AbstractIoService)
session.getService()).getListeners().fireSessionDestroyed(session);-                }
<span class="code-keyword">catch</span> (Exception e) {-                    <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span> point.</span>-                    <span
class="code-comment">// We <span class="code-keyword">do</span> not want any exception
thrown from <span class="code-keyword">this</span> <span
class="code-quote">"cleanup"</span> code</span>-                    <span
class="code-comment">// to change</span>-                    <span class="code-comment">//
the <span class="code-keyword">return</span> value by bubbling
up.</span>-                    IoFilterChain filterChain =
session.getFilterChain();-                   
filterChain.fireExceptionCaught(e);-                }-            }+        <span
class="code-keyword">try</span> {+            destroy(session);+            <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;+        } <span
class="code-keyword">catch</span> (Exception e) {+            IoFilterChain filterChain =
session.getFilterChain();+            filterChain.fireExceptionCaught(e);+        } <span
class="code-keyword">finally</span> {+            <span class="code-keyword">try</span>
{+            clearWriteRequestQueue(session);+            ((AbstractIoService)
session.getService())+                .getListeners().fireSessionDestroyed(session);+  
         } <span class="code-keyword">catch</span> (Exception e) {+            <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span></span>+            <span class="code-comment">//
point.</span>+            <span class="code-comment">// We <span
class="code-keyword">do</span> not want any exception thrown from <span
class="code-keyword">this</span></span>+            <span class="code-comment">// <span
class="code-quote">"cleanup"</span> code</span>+            <span class="code-comment">//
to change</span>+            <span class="code-comment">// the <span
class="code-keyword">return</span> value by bubbling up.</span>+            IoFilterChain
filterChain = session.getFilterChain();+            filterChain.fireExceptionCaught(e);+  
         }+        }+        }              <span class="code-keyword">return</span> <span
class="code-keyword">false</span>;         }diff --git
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.javaindex
3b0fa40..fc60124 100644---
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java@@ -149,15
+149,20 @@         }     } +<span class="code-comment">//    @Override</span>+<span
class="code-comment">//    <span class="code-keyword">protected</span>
Iterator&lt;NioSession&gt; allSessions() {</span>+<span class="code-comment">//       
selectorLock.readLock().lock();</span>+<span class="code-comment">//        </span>+<span
class="code-comment">//        <span class="code-keyword">try</span> {</span>+<span
class="code-comment">//            <span class="code-keyword">return</span> <span
class="code-keyword">new</span> IoSessionIterator(selector.keys());</span>+<span
class="code-comment">//        } <span class="code-keyword">finally</span> {</span>+<span
class="code-comment">//            selectorLock.readLock().unlock();</span>+<span
class="code-comment">//        }</span>+<span class="code-comment">//    }</span>+        
@Override     <span class="code-keyword">protected</span> Iterator&lt;NioSession&gt;
allSessions() {-        selectorLock.readLock().lock();-        -        <span
class="code-keyword">try</span> {-            <span class="code-keyword">return</span>
<span class="code-keyword">new</span> IoSessionIterator(selector.keys());-        } <span
class="code-keyword">finally</span> {-           
selectorLock.readLock().unlock();-        }+        <span
class="code-keyword">return</span> <span
class="code-keyword">super</span>.allSessions();     }      @SuppressWarnings(<span
class="code-quote">"synthetic-access"</span>)@@ -182,14 +187,13 @@     @Override     <span
class="code-keyword">protected</span> void destroy(NioSession session) <span
class="code-keyword">throws</span> Exception {         ByteChannel ch =
session.getChannel();-                 SelectionKey key =
session.getSelectionKey();                  <span class="code-keyword">if</span> (key !=
<span class="code-keyword">null</span>) {             key.cancel();         }       
 -        <span class="code-keyword">if</span> ( ch.isOpen() ) {+        <span
class="code-keyword">if</span> (ch.isOpen() ) {             ch.close();         }    
}</pre></div></div> 
==============================

On issue key DIRMINA-1076 the Builder pattern might have been discussed on the following comment: 
==============================
<b>Why Patch 2.0 doesn't fully work</b>Seems like <tt>Patch 2.0</tt> had a problem where
<tt>scheduleRemove(Session)</tt> would be called concurrently and have it added to the
<tt>removingSessions</tt> queue twice despite the check for <tt>contains(Session)</tt>
because both threads could check for contains(Session) and return a false-negative which
caused the <tt>Session</tt> to be added twice.  <tt>Queue</tt> lacks atomic operations
like <tt>putIfAbsent</tt> which makes it harder to solve the problem. <b>Option 1</b>One
option would be to <tt>synchronize</tt> the entire code-block; however, I felt that it
wasn't the safest option available because <tt>scheduleRemove(Session)</tt> could still be
called by an external actor after the <tt>Processor</tt> has executed
<tt>removeSessions()</tt> but before the <tt>for(...)</tt> loop cycles causing the
<tt>Session</tt> to be removed twice again even if <tt>selector.keys()</tt> was used as a
reference point.  The sequential operations would not be concurrent relative to each other
unless <tt>synchronize</tt> blocks were added all over the place.<b>Option 2</b>The safest
option to avoid this is to create a new <tt>queue</tt> which contains the active sessions
only.  The new queue serves as an atomic reference of whether a <tt>Session</tt> was
already removed or not.<b>Option 2, Liability</b>The new <tt>Queue</tt> could become a
memory leak if <tt>Sessions</tt> are added or removed in some way without calling
<tt>addNow(Session)</tt> or <tt>removeNow(Session)</tt>.<b>Patch 3.0 (Option 2) - Passes
Unit Tests</b><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..27e7d76 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-23,6 +23,7 @@ <span class="code-keyword">import</span>
java.net.PortUnreachableException; <span class="code-keyword">import</span>
java.nio.channels.ClosedSelectorException; <span class="code-keyword">import</span>
java.util.ArrayList;+<span class="code-keyword">import</span> java.util.Collections; <span
class="code-keyword">import</span> java.util.Iterator; <span
class="code-keyword">import</span> java.util.List; <span
class="code-keyword">import</span> java.util.Queue;@@ -86,6 +87,9 @@      <span
class="code-comment">/** A Session queue containing the newly created sessions
*/</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; newSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();+    +    <span
class="code-comment">/** A queue used to store all active sessions */</span>+    <span
class="code-keyword">private</span> <span class="code-keyword">final</span> Queue&lt;S&gt;
activeSessions = <span class="code-keyword">new</span>
ConcurrentLinkedQueue&lt;&gt;();      <span class="code-comment">/** A queue used to store
the sessions to be removed */</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; removingSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();@@ -239,7 +243,9 @@     
*      * @<span class="code-keyword">return</span> {@link Iterator} of {@link
IoSession}      */-    <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> Iterator&lt;S&gt; allSessions();+    <span
class="code-keyword">protected</span> Iterator&lt;S&gt; allSessions() {+        <span
class="code-keyword">return</span>
Collections.unmodifiableCollection(activeSessions).iterator();+    }      /**      * Get
an {@link Iterator} <span class="code-keyword">for</span> the list of {@link IoSession}
found selected@@ -411,7 +417,7 @@     }      <span class="code-keyword">private</span>
void scheduleRemove(S session) {-        <span class="code-keyword">if</span>
(!removingSessions.contains(session)) {+        <span class="code-keyword">if</span>
(!removingSessions.contains(session) &amp;&amp; activeSessions.contains(session))
{             removingSessions.add(session);         }     }@@ -659,9 +665,20
@@                     <span class="code-object">long</span> currentTime = <span
class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime); +                    <span class="code-comment">// Disconnect all
sessions immediately <span class="code-keyword">if</span> disposal has
been</span>+                    <span class="code-comment">// requested so that we exit
<span class="code-keyword">this</span> loop eventually.</span>+                    <span
class="code-keyword">if</span> (isDisposing()) {+                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{+                            IoSession session = i.next();+                           
scheduleRemove((S) session);+                        }+                   
}+                                         <span class="code-comment">// And manage
removed sessions</span>                     nSessions -=
removeSessions();-+                    +                    <span
class="code-keyword">assert</span> nSessions &gt; -1 : <span class="code-quote">"Internal
Session Count is Negative"</span>;+                                         <span
class="code-comment">// Last, not least, send Idle events to the idle
sessions</span>                     notifyIdleSessions(currentTime); @@ -685,26 +702,6
@@                         }                          <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }--                    <span
class="code-comment">// Disconnect all sessions immediately <span
class="code-keyword">if</span> disposal has been</span>-                    <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>-                    <span class="code-keyword">if</span>
(isDisposing()) {-                        <span class="code-object">boolean</span> hasKeys
= <span class="code-keyword">false</span>;--                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{-                            IoSession session = i.next();--                           
scheduleRemove((S) session);--                            <span
class="code-keyword">if</span> (session.isActive()) {-                               
hasKeys = <span class="code-keyword">true</span>;-                           
}-                        }--                        <span class="code-keyword">if</span>
(hasKeys) {-                            wakeup();-                       
}                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span>@@ -819,30 +816,41 @@         <span
class="code-keyword">private</span> <span class="code-object">boolean</span> addNow(S
session) {             <span class="code-object">boolean</span> registered = <span
class="code-keyword">false</span>; -            <span class="code-keyword">try</span>
{-                init(session);-                registered = <span
class="code-keyword">true</span>;+        <span class="code-keyword">try</span> {+      
 <span class="code-keyword">if</span> (activeSessions.contains(session)) {+           
<span class="code-keyword">return</span> <span class="code-keyword">true</span>;+      
 } -                <span class="code-comment">// Build the filter chain of <span
class="code-keyword">this</span> session.</span>-                IoFilterChainBuilder
chainBuilder = session.getService().getFilterChainBuilder();-               
chainBuilder.buildFilterChain(session.getFilterChain());+        <span
class="code-keyword">if</span> (activeSessions.add(session)) {+           
init(session);+            registered = <span
class="code-keyword">true</span>; -                <span class="code-comment">//
DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here</span>-                <span
class="code-comment">// in
AbstractIoFilterChain.fireSessionOpened().</span>-                <span
class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>-                IoServiceListenerSupport listeners = ((AbstractIoService)
session.getService()).getListeners();-               
listeners.fireSessionCreated(session);-            } <span
class="code-keyword">catch</span> (Exception e) {-               
ExceptionMonitor.getInstance().exceptionCaught(e);+            <span
class="code-comment">// Build the filter chain of <span class="code-keyword">this</span>
session.</span>+            IoFilterChainBuilder chainBuilder = session.getService()+  
             .getFilterChainBuilder();+           
chainBuilder.buildFilterChain(session.getFilterChain()); -                <span
class="code-keyword">try</span> {-                    destroy(session);-                }
<span class="code-keyword">catch</span> (Exception e1) {-                   
ExceptionMonitor.getInstance().exceptionCaught(e1);-                } <span
class="code-keyword">finally</span> {-                    registered = <span
class="code-keyword">false</span>;-                }-            }+            <span
class="code-comment">// DefaultIoFilterChain.CONNECT_FUTURE is cleared inside</span>+  
         <span class="code-comment">// here</span>+            <span
class="code-comment">// in AbstractIoFilterChain.fireSessionOpened().</span>+           
<span class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>+            IoServiceListenerSupport listeners = ((AbstractIoService)
session+                .getService()).getListeners();+           
listeners.fireSessionCreated(session);+        }+        } <span
class="code-keyword">catch</span> (Exception e) {+      
 ExceptionMonitor.getInstance().exceptionCaught(e);++        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+            <span
class="code-keyword">try</span> {+            destroy(session);+            } <span
class="code-keyword">catch</span> (Exception e1) {+          
 ExceptionMonitor.getInstance().exceptionCaught(e1);+            } <span
class="code-keyword">finally</span> {+            registered = <span
class="code-keyword">false</span>;+            }+        }+        }              <span
class="code-keyword">return</span> registered;         }@@ -850,40 +858,36 @@        
<span class="code-keyword">private</span> <span class="code-object">int</span>
removeSessions() {             <span class="code-object">int</span> removedSessions =
0; -            <span class="code-keyword">for</span> (S session =
removingSessions.poll(); session != <span class="code-keyword">null</span>; session =
removingSessions.poll()) {-                SessionState state = getState(session);+       
<span class="code-keyword">for</span> (S session = removingSessions.poll(); session !=
<span class="code-keyword">null</span>; session = removingSessions .poll()) {+      
 SessionState state = getState(session); -                <span class="code-comment">//
Now deal with the removal accordingly to the session's state</span>-                <span
class="code-keyword">switch</span> (state) {-                <span
class="code-keyword">case</span> OPENED:-                    <span class="code-comment">//
Try to remove <span class="code-keyword">this</span> session</span>-                   
<span class="code-keyword">if</span> (removeNow(session)) {-                       
removedSessions++;-                    }+        <span class="code-comment">// Now deal
with the removal accordingly to the session's</span>+        <span class="code-comment">//
state</span>+        <span class="code-keyword">switch</span> (state) {+        <span
class="code-keyword">case</span> OPENED:+        <span class="code-keyword">case</span>
CLOSING:+            <span class="code-comment">// Try to remove <span
class="code-keyword">this</span> session</span>+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">break</span>;+            <span
class="code-keyword">break</span>; -                <span class="code-keyword">case</span>
CLOSING:-                    <span class="code-comment">// Skip <span
class="code-keyword">if</span> channel is already closed</span>-                    <span
class="code-comment">// In any <span class="code-keyword">case</span>, remove the session
from the queue</span>-                    removedSessions++;-                    <span
class="code-keyword">break</span>;+        <span class="code-keyword">case</span>
OPENING:+            <span class="code-comment">// Remove session from the newSessions
queue and</span>+            <span class="code-comment">// remove it</span>+           
newSessions.remove(session); -                <span class="code-keyword">case</span>
OPENING:-                    <span class="code-comment">// Remove session from the
newSessions queue and</span>-                    <span class="code-comment">// remove
it</span>-                    newSessions.remove(session);+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">if</span> (removeNow(session))
{-                        removedSessions++;-                    }+            <span
class="code-keyword">break</span>; -                    <span
class="code-keyword">break</span>;--                <span
class="code-keyword">default</span>:-                    <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span
class="code-object">String</span>.valueOf(state));-                }-            }+      
 <span class="code-keyword">default</span>:+            <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span class="code-object">String</span>.valueOf(state));+      
 }+        }              <span class="code-keyword">return</span>
removedSessions;         }@@ -1145,27 +1149,32 @@         }          <span
class="code-keyword">private</span> <span class="code-object">boolean</span> removeNow(S
session) {-            clearWriteRequestQueue(session);+        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+      
 clearWriteRequestQueue(session); -            <span class="code-keyword">try</span>
{-                destroy(session);-                <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;-            }
<span class="code-keyword">catch</span> (Exception e) {-                IoFilterChain
filterChain = session.getFilterChain();-               
filterChain.fireExceptionCaught(e);-            } <span
class="code-keyword">finally</span> {-                <span
class="code-keyword">try</span> {-                   
clearWriteRequestQueue(session);-                    ((AbstractIoService)
session.getService()).getListeners().fireSessionDestroyed(session);-                }
<span class="code-keyword">catch</span> (Exception e) {-                    <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span> point.</span>-                    <span
class="code-comment">// We <span class="code-keyword">do</span> not want any exception
thrown from <span class="code-keyword">this</span> <span
class="code-quote">"cleanup"</span> code</span>-                    <span
class="code-comment">// to change</span>-                    <span class="code-comment">//
the <span class="code-keyword">return</span> value by bubbling
up.</span>-                    IoFilterChain filterChain =
session.getFilterChain();-                   
filterChain.fireExceptionCaught(e);-                }-            }+        <span
class="code-keyword">try</span> {+            destroy(session);+            <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;+        } <span
class="code-keyword">catch</span> (Exception e) {+            IoFilterChain filterChain =
session.getFilterChain();+            filterChain.fireExceptionCaught(e);+        } <span
class="code-keyword">finally</span> {+            <span class="code-keyword">try</span>
{+            clearWriteRequestQueue(session);+            ((AbstractIoService)
session.getService())+                .getListeners().fireSessionDestroyed(session);+  
         } <span class="code-keyword">catch</span> (Exception e) {+            <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span></span>+            <span class="code-comment">//
point.</span>+            <span class="code-comment">// We <span
class="code-keyword">do</span> not want any exception thrown from <span
class="code-keyword">this</span></span>+            <span class="code-comment">// <span
class="code-quote">"cleanup"</span> code</span>+            <span class="code-comment">//
to change</span>+            <span class="code-comment">// the <span
class="code-keyword">return</span> value by bubbling up.</span>+            IoFilterChain
filterChain = session.getFilterChain();+            filterChain.fireExceptionCaught(e);+  
         }+        }+        }              <span class="code-keyword">return</span> <span
class="code-keyword">false</span>;         }diff --git
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.javaindex
3b0fa40..fc60124 100644---
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java@@ -149,15
+149,20 @@         }     } +<span class="code-comment">//    @Override</span>+<span
class="code-comment">//    <span class="code-keyword">protected</span>
Iterator&lt;NioSession&gt; allSessions() {</span>+<span class="code-comment">//       
selectorLock.readLock().lock();</span>+<span class="code-comment">//        </span>+<span
class="code-comment">//        <span class="code-keyword">try</span> {</span>+<span
class="code-comment">//            <span class="code-keyword">return</span> <span
class="code-keyword">new</span> IoSessionIterator(selector.keys());</span>+<span
class="code-comment">//        } <span class="code-keyword">finally</span> {</span>+<span
class="code-comment">//            selectorLock.readLock().unlock();</span>+<span
class="code-comment">//        }</span>+<span class="code-comment">//    }</span>+        
@Override     <span class="code-keyword">protected</span> Iterator&lt;NioSession&gt;
allSessions() {-        selectorLock.readLock().lock();-        -        <span
class="code-keyword">try</span> {-            <span class="code-keyword">return</span>
<span class="code-keyword">new</span> IoSessionIterator(selector.keys());-        } <span
class="code-keyword">finally</span> {-           
selectorLock.readLock().unlock();-        }+        <span
class="code-keyword">return</span> <span
class="code-keyword">super</span>.allSessions();     }      @SuppressWarnings(<span
class="code-quote">"synthetic-access"</span>)@@ -182,14 +187,13 @@     @Override     <span
class="code-keyword">protected</span> void destroy(NioSession session) <span
class="code-keyword">throws</span> Exception {         ByteChannel ch =
session.getChannel();-                 SelectionKey key =
session.getSelectionKey();                  <span class="code-keyword">if</span> (key !=
<span class="code-keyword">null</span>) {             key.cancel();         }       
 -        <span class="code-keyword">if</span> ( ch.isOpen() ) {+        <span
class="code-keyword">if</span> (ch.isOpen() ) {             ch.close();         }    
}</pre></div></div> 
==============================

On issue key DIRMINA-1076 the Iterator pattern might have been discussed on the following comment: 
==============================
<b>Why Patch 2.0 doesn't fully work</b>Seems like <tt>Patch 2.0</tt> had a problem where
<tt>scheduleRemove(Session)</tt> would be called concurrently and have it added to the
<tt>removingSessions</tt> queue twice despite the check for <tt>contains(Session)</tt>
because both threads could check for contains(Session) and return a false-negative which
caused the <tt>Session</tt> to be added twice.  <tt>Queue</tt> lacks atomic operations
like <tt>putIfAbsent</tt> which makes it harder to solve the problem. <b>Option 1</b>One
option would be to <tt>synchronize</tt> the entire code-block; however, I felt that it
wasn't the safest option available because <tt>scheduleRemove(Session)</tt> could still be
called by an external actor after the <tt>Processor</tt> has executed
<tt>removeSessions()</tt> but before the <tt>for(...)</tt> loop cycles causing the
<tt>Session</tt> to be removed twice again even if <tt>selector.keys()</tt> was used as a
reference point.  The sequential operations would not be concurrent relative to each other
unless <tt>synchronize</tt> blocks were added all over the place.<b>Option 2</b>The safest
option to avoid this is to create a new <tt>queue</tt> which contains the active sessions
only.  The new queue serves as an atomic reference of whether a <tt>Session</tt> was
already removed or not.<b>Option 2, Liability</b>The new <tt>Queue</tt> could become a
memory leak if <tt>Sessions</tt> are added or removed in some way without calling
<tt>addNow(Session)</tt> or <tt>removeNow(Session)</tt>.<b>Patch 3.0 (Option 2) - Passes
Unit Tests</b><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..27e7d76 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-23,6 +23,7 @@ <span class="code-keyword">import</span>
java.net.PortUnreachableException; <span class="code-keyword">import</span>
java.nio.channels.ClosedSelectorException; <span class="code-keyword">import</span>
java.util.ArrayList;+<span class="code-keyword">import</span> java.util.Collections; <span
class="code-keyword">import</span> java.util.Iterator; <span
class="code-keyword">import</span> java.util.List; <span
class="code-keyword">import</span> java.util.Queue;@@ -86,6 +87,9 @@      <span
class="code-comment">/** A Session queue containing the newly created sessions
*/</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; newSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();+    +    <span
class="code-comment">/** A queue used to store all active sessions */</span>+    <span
class="code-keyword">private</span> <span class="code-keyword">final</span> Queue&lt;S&gt;
activeSessions = <span class="code-keyword">new</span>
ConcurrentLinkedQueue&lt;&gt;();      <span class="code-comment">/** A queue used to store
the sessions to be removed */</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; removingSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();@@ -239,7 +243,9 @@     
*      * @<span class="code-keyword">return</span> {@link Iterator} of {@link
IoSession}      */-    <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> Iterator&lt;S&gt; allSessions();+    <span
class="code-keyword">protected</span> Iterator&lt;S&gt; allSessions() {+        <span
class="code-keyword">return</span>
Collections.unmodifiableCollection(activeSessions).iterator();+    }      /**      * Get
an {@link Iterator} <span class="code-keyword">for</span> the list of {@link IoSession}
found selected@@ -411,7 +417,7 @@     }      <span class="code-keyword">private</span>
void scheduleRemove(S session) {-        <span class="code-keyword">if</span>
(!removingSessions.contains(session)) {+        <span class="code-keyword">if</span>
(!removingSessions.contains(session) &amp;&amp; activeSessions.contains(session))
{             removingSessions.add(session);         }     }@@ -659,9 +665,20
@@                     <span class="code-object">long</span> currentTime = <span
class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime); +                    <span class="code-comment">// Disconnect all
sessions immediately <span class="code-keyword">if</span> disposal has
been</span>+                    <span class="code-comment">// requested so that we exit
<span class="code-keyword">this</span> loop eventually.</span>+                    <span
class="code-keyword">if</span> (isDisposing()) {+                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{+                            IoSession session = i.next();+                           
scheduleRemove((S) session);+                        }+                   
}+                                         <span class="code-comment">// And manage
removed sessions</span>                     nSessions -=
removeSessions();-+                    +                    <span
class="code-keyword">assert</span> nSessions &gt; -1 : <span class="code-quote">"Internal
Session Count is Negative"</span>;+                                         <span
class="code-comment">// Last, not least, send Idle events to the idle
sessions</span>                     notifyIdleSessions(currentTime); @@ -685,26 +702,6
@@                         }                          <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }--                    <span
class="code-comment">// Disconnect all sessions immediately <span
class="code-keyword">if</span> disposal has been</span>-                    <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>-                    <span class="code-keyword">if</span>
(isDisposing()) {-                        <span class="code-object">boolean</span> hasKeys
= <span class="code-keyword">false</span>;--                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{-                            IoSession session = i.next();--                           
scheduleRemove((S) session);--                            <span
class="code-keyword">if</span> (session.isActive()) {-                               
hasKeys = <span class="code-keyword">true</span>;-                           
}-                        }--                        <span class="code-keyword">if</span>
(hasKeys) {-                            wakeup();-                       
}                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span>@@ -819,30 +816,41 @@         <span
class="code-keyword">private</span> <span class="code-object">boolean</span> addNow(S
session) {             <span class="code-object">boolean</span> registered = <span
class="code-keyword">false</span>; -            <span class="code-keyword">try</span>
{-                init(session);-                registered = <span
class="code-keyword">true</span>;+        <span class="code-keyword">try</span> {+      
 <span class="code-keyword">if</span> (activeSessions.contains(session)) {+           
<span class="code-keyword">return</span> <span class="code-keyword">true</span>;+      
 } -                <span class="code-comment">// Build the filter chain of <span
class="code-keyword">this</span> session.</span>-                IoFilterChainBuilder
chainBuilder = session.getService().getFilterChainBuilder();-               
chainBuilder.buildFilterChain(session.getFilterChain());+        <span
class="code-keyword">if</span> (activeSessions.add(session)) {+           
init(session);+            registered = <span
class="code-keyword">true</span>; -                <span class="code-comment">//
DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here</span>-                <span
class="code-comment">// in
AbstractIoFilterChain.fireSessionOpened().</span>-                <span
class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>-                IoServiceListenerSupport listeners = ((AbstractIoService)
session.getService()).getListeners();-               
listeners.fireSessionCreated(session);-            } <span
class="code-keyword">catch</span> (Exception e) {-               
ExceptionMonitor.getInstance().exceptionCaught(e);+            <span
class="code-comment">// Build the filter chain of <span class="code-keyword">this</span>
session.</span>+            IoFilterChainBuilder chainBuilder = session.getService()+  
             .getFilterChainBuilder();+           
chainBuilder.buildFilterChain(session.getFilterChain()); -                <span
class="code-keyword">try</span> {-                    destroy(session);-                }
<span class="code-keyword">catch</span> (Exception e1) {-                   
ExceptionMonitor.getInstance().exceptionCaught(e1);-                } <span
class="code-keyword">finally</span> {-                    registered = <span
class="code-keyword">false</span>;-                }-            }+            <span
class="code-comment">// DefaultIoFilterChain.CONNECT_FUTURE is cleared inside</span>+  
         <span class="code-comment">// here</span>+            <span
class="code-comment">// in AbstractIoFilterChain.fireSessionOpened().</span>+           
<span class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>+            IoServiceListenerSupport listeners = ((AbstractIoService)
session+                .getService()).getListeners();+           
listeners.fireSessionCreated(session);+        }+        } <span
class="code-keyword">catch</span> (Exception e) {+      
 ExceptionMonitor.getInstance().exceptionCaught(e);++        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+            <span
class="code-keyword">try</span> {+            destroy(session);+            } <span
class="code-keyword">catch</span> (Exception e1) {+          
 ExceptionMonitor.getInstance().exceptionCaught(e1);+            } <span
class="code-keyword">finally</span> {+            registered = <span
class="code-keyword">false</span>;+            }+        }+        }              <span
class="code-keyword">return</span> registered;         }@@ -850,40 +858,36 @@        
<span class="code-keyword">private</span> <span class="code-object">int</span>
removeSessions() {             <span class="code-object">int</span> removedSessions =
0; -            <span class="code-keyword">for</span> (S session =
removingSessions.poll(); session != <span class="code-keyword">null</span>; session =
removingSessions.poll()) {-                SessionState state = getState(session);+       
<span class="code-keyword">for</span> (S session = removingSessions.poll(); session !=
<span class="code-keyword">null</span>; session = removingSessions .poll()) {+      
 SessionState state = getState(session); -                <span class="code-comment">//
Now deal with the removal accordingly to the session's state</span>-                <span
class="code-keyword">switch</span> (state) {-                <span
class="code-keyword">case</span> OPENED:-                    <span class="code-comment">//
Try to remove <span class="code-keyword">this</span> session</span>-                   
<span class="code-keyword">if</span> (removeNow(session)) {-                       
removedSessions++;-                    }+        <span class="code-comment">// Now deal
with the removal accordingly to the session's</span>+        <span class="code-comment">//
state</span>+        <span class="code-keyword">switch</span> (state) {+        <span
class="code-keyword">case</span> OPENED:+        <span class="code-keyword">case</span>
CLOSING:+            <span class="code-comment">// Try to remove <span
class="code-keyword">this</span> session</span>+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">break</span>;+            <span
class="code-keyword">break</span>; -                <span class="code-keyword">case</span>
CLOSING:-                    <span class="code-comment">// Skip <span
class="code-keyword">if</span> channel is already closed</span>-                    <span
class="code-comment">// In any <span class="code-keyword">case</span>, remove the session
from the queue</span>-                    removedSessions++;-                    <span
class="code-keyword">break</span>;+        <span class="code-keyword">case</span>
OPENING:+            <span class="code-comment">// Remove session from the newSessions
queue and</span>+            <span class="code-comment">// remove it</span>+           
newSessions.remove(session); -                <span class="code-keyword">case</span>
OPENING:-                    <span class="code-comment">// Remove session from the
newSessions queue and</span>-                    <span class="code-comment">// remove
it</span>-                    newSessions.remove(session);+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">if</span> (removeNow(session))
{-                        removedSessions++;-                    }+            <span
class="code-keyword">break</span>; -                    <span
class="code-keyword">break</span>;--                <span
class="code-keyword">default</span>:-                    <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span
class="code-object">String</span>.valueOf(state));-                }-            }+      
 <span class="code-keyword">default</span>:+            <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span class="code-object">String</span>.valueOf(state));+      
 }+        }              <span class="code-keyword">return</span>
removedSessions;         }@@ -1145,27 +1149,32 @@         }          <span
class="code-keyword">private</span> <span class="code-object">boolean</span> removeNow(S
session) {-            clearWriteRequestQueue(session);+        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+      
 clearWriteRequestQueue(session); -            <span class="code-keyword">try</span>
{-                destroy(session);-                <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;-            }
<span class="code-keyword">catch</span> (Exception e) {-                IoFilterChain
filterChain = session.getFilterChain();-               
filterChain.fireExceptionCaught(e);-            } <span
class="code-keyword">finally</span> {-                <span
class="code-keyword">try</span> {-                   
clearWriteRequestQueue(session);-                    ((AbstractIoService)
session.getService()).getListeners().fireSessionDestroyed(session);-                }
<span class="code-keyword">catch</span> (Exception e) {-                    <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span> point.</span>-                    <span
class="code-comment">// We <span class="code-keyword">do</span> not want any exception
thrown from <span class="code-keyword">this</span> <span
class="code-quote">"cleanup"</span> code</span>-                    <span
class="code-comment">// to change</span>-                    <span class="code-comment">//
the <span class="code-keyword">return</span> value by bubbling
up.</span>-                    IoFilterChain filterChain =
session.getFilterChain();-                   
filterChain.fireExceptionCaught(e);-                }-            }+        <span
class="code-keyword">try</span> {+            destroy(session);+            <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;+        } <span
class="code-keyword">catch</span> (Exception e) {+            IoFilterChain filterChain =
session.getFilterChain();+            filterChain.fireExceptionCaught(e);+        } <span
class="code-keyword">finally</span> {+            <span class="code-keyword">try</span>
{+            clearWriteRequestQueue(session);+            ((AbstractIoService)
session.getService())+                .getListeners().fireSessionDestroyed(session);+  
         } <span class="code-keyword">catch</span> (Exception e) {+            <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span></span>+            <span class="code-comment">//
point.</span>+            <span class="code-comment">// We <span
class="code-keyword">do</span> not want any exception thrown from <span
class="code-keyword">this</span></span>+            <span class="code-comment">// <span
class="code-quote">"cleanup"</span> code</span>+            <span class="code-comment">//
to change</span>+            <span class="code-comment">// the <span
class="code-keyword">return</span> value by bubbling up.</span>+            IoFilterChain
filterChain = session.getFilterChain();+            filterChain.fireExceptionCaught(e);+  
         }+        }+        }              <span class="code-keyword">return</span> <span
class="code-keyword">false</span>;         }diff --git
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.javaindex
3b0fa40..fc60124 100644---
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java@@ -149,15
+149,20 @@         }     } +<span class="code-comment">//    @Override</span>+<span
class="code-comment">//    <span class="code-keyword">protected</span>
Iterator&lt;NioSession&gt; allSessions() {</span>+<span class="code-comment">//       
selectorLock.readLock().lock();</span>+<span class="code-comment">//        </span>+<span
class="code-comment">//        <span class="code-keyword">try</span> {</span>+<span
class="code-comment">//            <span class="code-keyword">return</span> <span
class="code-keyword">new</span> IoSessionIterator(selector.keys());</span>+<span
class="code-comment">//        } <span class="code-keyword">finally</span> {</span>+<span
class="code-comment">//            selectorLock.readLock().unlock();</span>+<span
class="code-comment">//        }</span>+<span class="code-comment">//    }</span>+        
@Override     <span class="code-keyword">protected</span> Iterator&lt;NioSession&gt;
allSessions() {-        selectorLock.readLock().lock();-        -        <span
class="code-keyword">try</span> {-            <span class="code-keyword">return</span>
<span class="code-keyword">new</span> IoSessionIterator(selector.keys());-        } <span
class="code-keyword">finally</span> {-           
selectorLock.readLock().unlock();-        }+        <span
class="code-keyword">return</span> <span
class="code-keyword">super</span>.allSessions();     }      @SuppressWarnings(<span
class="code-quote">"synthetic-access"</span>)@@ -182,14 +187,13 @@     @Override     <span
class="code-keyword">protected</span> void destroy(NioSession session) <span
class="code-keyword">throws</span> Exception {         ByteChannel ch =
session.getChannel();-                 SelectionKey key =
session.getSelectionKey();                  <span class="code-keyword">if</span> (key !=
<span class="code-keyword">null</span>) {             key.cancel();         }       
 -        <span class="code-keyword">if</span> ( ch.isOpen() ) {+        <span
class="code-keyword">if</span> (ch.isOpen() ) {             ch.close();         }    
}</pre></div></div> 
==============================

On issue key DIRMINA-1076 the iterator pattern might have been discussed on the following comment: 
==============================
<b>Why Patch 2.0 doesn't fully work</b>Seems like <tt>Patch 2.0</tt> had a problem where
<tt>scheduleRemove(Session)</tt> would be called concurrently and have it added to the
<tt>removingSessions</tt> queue twice despite the check for <tt>contains(Session)</tt>
because both threads could check for contains(Session) and return a false-negative which
caused the <tt>Session</tt> to be added twice.  <tt>Queue</tt> lacks atomic operations
like <tt>putIfAbsent</tt> which makes it harder to solve the problem. <b>Option 1</b>One
option would be to <tt>synchronize</tt> the entire code-block; however, I felt that it
wasn't the safest option available because <tt>scheduleRemove(Session)</tt> could still be
called by an external actor after the <tt>Processor</tt> has executed
<tt>removeSessions()</tt> but before the <tt>for(...)</tt> loop cycles causing the
<tt>Session</tt> to be removed twice again even if <tt>selector.keys()</tt> was used as a
reference point.  The sequential operations would not be concurrent relative to each other
unless <tt>synchronize</tt> blocks were added all over the place.<b>Option 2</b>The safest
option to avoid this is to create a new <tt>queue</tt> which contains the active sessions
only.  The new queue serves as an atomic reference of whether a <tt>Session</tt> was
already removed or not.<b>Option 2, Liability</b>The new <tt>Queue</tt> could become a
memory leak if <tt>Sessions</tt> are added or removed in some way without calling
<tt>addNow(Session)</tt> or <tt>removeNow(Session)</tt>.<b>Patch 3.0 (Option 2) - Passes
Unit Tests</b><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..27e7d76 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-23,6 +23,7 @@ <span class="code-keyword">import</span>
java.net.PortUnreachableException; <span class="code-keyword">import</span>
java.nio.channels.ClosedSelectorException; <span class="code-keyword">import</span>
java.util.ArrayList;+<span class="code-keyword">import</span> java.util.Collections; <span
class="code-keyword">import</span> java.util.Iterator; <span
class="code-keyword">import</span> java.util.List; <span
class="code-keyword">import</span> java.util.Queue;@@ -86,6 +87,9 @@      <span
class="code-comment">/** A Session queue containing the newly created sessions
*/</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; newSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();+    +    <span
class="code-comment">/** A queue used to store all active sessions */</span>+    <span
class="code-keyword">private</span> <span class="code-keyword">final</span> Queue&lt;S&gt;
activeSessions = <span class="code-keyword">new</span>
ConcurrentLinkedQueue&lt;&gt;();      <span class="code-comment">/** A queue used to store
the sessions to be removed */</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; removingSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();@@ -239,7 +243,9 @@     
*      * @<span class="code-keyword">return</span> {@link Iterator} of {@link
IoSession}      */-    <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> Iterator&lt;S&gt; allSessions();+    <span
class="code-keyword">protected</span> Iterator&lt;S&gt; allSessions() {+        <span
class="code-keyword">return</span>
Collections.unmodifiableCollection(activeSessions).iterator();+    }      /**      * Get
an {@link Iterator} <span class="code-keyword">for</span> the list of {@link IoSession}
found selected@@ -411,7 +417,7 @@     }      <span class="code-keyword">private</span>
void scheduleRemove(S session) {-        <span class="code-keyword">if</span>
(!removingSessions.contains(session)) {+        <span class="code-keyword">if</span>
(!removingSessions.contains(session) &amp;&amp; activeSessions.contains(session))
{             removingSessions.add(session);         }     }@@ -659,9 +665,20
@@                     <span class="code-object">long</span> currentTime = <span
class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime); +                    <span class="code-comment">// Disconnect all
sessions immediately <span class="code-keyword">if</span> disposal has
been</span>+                    <span class="code-comment">// requested so that we exit
<span class="code-keyword">this</span> loop eventually.</span>+                    <span
class="code-keyword">if</span> (isDisposing()) {+                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{+                            IoSession session = i.next();+                           
scheduleRemove((S) session);+                        }+                   
}+                                         <span class="code-comment">// And manage
removed sessions</span>                     nSessions -=
removeSessions();-+                    +                    <span
class="code-keyword">assert</span> nSessions &gt; -1 : <span class="code-quote">"Internal
Session Count is Negative"</span>;+                                         <span
class="code-comment">// Last, not least, send Idle events to the idle
sessions</span>                     notifyIdleSessions(currentTime); @@ -685,26 +702,6
@@                         }                          <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }--                    <span
class="code-comment">// Disconnect all sessions immediately <span
class="code-keyword">if</span> disposal has been</span>-                    <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>-                    <span class="code-keyword">if</span>
(isDisposing()) {-                        <span class="code-object">boolean</span> hasKeys
= <span class="code-keyword">false</span>;--                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{-                            IoSession session = i.next();--                           
scheduleRemove((S) session);--                            <span
class="code-keyword">if</span> (session.isActive()) {-                               
hasKeys = <span class="code-keyword">true</span>;-                           
}-                        }--                        <span class="code-keyword">if</span>
(hasKeys) {-                            wakeup();-                       
}                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span>@@ -819,30 +816,41 @@         <span
class="code-keyword">private</span> <span class="code-object">boolean</span> addNow(S
session) {             <span class="code-object">boolean</span> registered = <span
class="code-keyword">false</span>; -            <span class="code-keyword">try</span>
{-                init(session);-                registered = <span
class="code-keyword">true</span>;+        <span class="code-keyword">try</span> {+      
 <span class="code-keyword">if</span> (activeSessions.contains(session)) {+           
<span class="code-keyword">return</span> <span class="code-keyword">true</span>;+      
 } -                <span class="code-comment">// Build the filter chain of <span
class="code-keyword">this</span> session.</span>-                IoFilterChainBuilder
chainBuilder = session.getService().getFilterChainBuilder();-               
chainBuilder.buildFilterChain(session.getFilterChain());+        <span
class="code-keyword">if</span> (activeSessions.add(session)) {+           
init(session);+            registered = <span
class="code-keyword">true</span>; -                <span class="code-comment">//
DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here</span>-                <span
class="code-comment">// in
AbstractIoFilterChain.fireSessionOpened().</span>-                <span
class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>-                IoServiceListenerSupport listeners = ((AbstractIoService)
session.getService()).getListeners();-               
listeners.fireSessionCreated(session);-            } <span
class="code-keyword">catch</span> (Exception e) {-               
ExceptionMonitor.getInstance().exceptionCaught(e);+            <span
class="code-comment">// Build the filter chain of <span class="code-keyword">this</span>
session.</span>+            IoFilterChainBuilder chainBuilder = session.getService()+  
             .getFilterChainBuilder();+           
chainBuilder.buildFilterChain(session.getFilterChain()); -                <span
class="code-keyword">try</span> {-                    destroy(session);-                }
<span class="code-keyword">catch</span> (Exception e1) {-                   
ExceptionMonitor.getInstance().exceptionCaught(e1);-                } <span
class="code-keyword">finally</span> {-                    registered = <span
class="code-keyword">false</span>;-                }-            }+            <span
class="code-comment">// DefaultIoFilterChain.CONNECT_FUTURE is cleared inside</span>+  
         <span class="code-comment">// here</span>+            <span
class="code-comment">// in AbstractIoFilterChain.fireSessionOpened().</span>+           
<span class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>+            IoServiceListenerSupport listeners = ((AbstractIoService)
session+                .getService()).getListeners();+           
listeners.fireSessionCreated(session);+        }+        } <span
class="code-keyword">catch</span> (Exception e) {+      
 ExceptionMonitor.getInstance().exceptionCaught(e);++        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+            <span
class="code-keyword">try</span> {+            destroy(session);+            } <span
class="code-keyword">catch</span> (Exception e1) {+          
 ExceptionMonitor.getInstance().exceptionCaught(e1);+            } <span
class="code-keyword">finally</span> {+            registered = <span
class="code-keyword">false</span>;+            }+        }+        }              <span
class="code-keyword">return</span> registered;         }@@ -850,40 +858,36 @@        
<span class="code-keyword">private</span> <span class="code-object">int</span>
removeSessions() {             <span class="code-object">int</span> removedSessions =
0; -            <span class="code-keyword">for</span> (S session =
removingSessions.poll(); session != <span class="code-keyword">null</span>; session =
removingSessions.poll()) {-                SessionState state = getState(session);+       
<span class="code-keyword">for</span> (S session = removingSessions.poll(); session !=
<span class="code-keyword">null</span>; session = removingSessions .poll()) {+      
 SessionState state = getState(session); -                <span class="code-comment">//
Now deal with the removal accordingly to the session's state</span>-                <span
class="code-keyword">switch</span> (state) {-                <span
class="code-keyword">case</span> OPENED:-                    <span class="code-comment">//
Try to remove <span class="code-keyword">this</span> session</span>-                   
<span class="code-keyword">if</span> (removeNow(session)) {-                       
removedSessions++;-                    }+        <span class="code-comment">// Now deal
with the removal accordingly to the session's</span>+        <span class="code-comment">//
state</span>+        <span class="code-keyword">switch</span> (state) {+        <span
class="code-keyword">case</span> OPENED:+        <span class="code-keyword">case</span>
CLOSING:+            <span class="code-comment">// Try to remove <span
class="code-keyword">this</span> session</span>+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">break</span>;+            <span
class="code-keyword">break</span>; -                <span class="code-keyword">case</span>
CLOSING:-                    <span class="code-comment">// Skip <span
class="code-keyword">if</span> channel is already closed</span>-                    <span
class="code-comment">// In any <span class="code-keyword">case</span>, remove the session
from the queue</span>-                    removedSessions++;-                    <span
class="code-keyword">break</span>;+        <span class="code-keyword">case</span>
OPENING:+            <span class="code-comment">// Remove session from the newSessions
queue and</span>+            <span class="code-comment">// remove it</span>+           
newSessions.remove(session); -                <span class="code-keyword">case</span>
OPENING:-                    <span class="code-comment">// Remove session from the
newSessions queue and</span>-                    <span class="code-comment">// remove
it</span>-                    newSessions.remove(session);+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">if</span> (removeNow(session))
{-                        removedSessions++;-                    }+            <span
class="code-keyword">break</span>; -                    <span
class="code-keyword">break</span>;--                <span
class="code-keyword">default</span>:-                    <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span
class="code-object">String</span>.valueOf(state));-                }-            }+      
 <span class="code-keyword">default</span>:+            <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span class="code-object">String</span>.valueOf(state));+      
 }+        }              <span class="code-keyword">return</span>
removedSessions;         }@@ -1145,27 +1149,32 @@         }          <span
class="code-keyword">private</span> <span class="code-object">boolean</span> removeNow(S
session) {-            clearWriteRequestQueue(session);+        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+      
 clearWriteRequestQueue(session); -            <span class="code-keyword">try</span>
{-                destroy(session);-                <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;-            }
<span class="code-keyword">catch</span> (Exception e) {-                IoFilterChain
filterChain = session.getFilterChain();-               
filterChain.fireExceptionCaught(e);-            } <span
class="code-keyword">finally</span> {-                <span
class="code-keyword">try</span> {-                   
clearWriteRequestQueue(session);-                    ((AbstractIoService)
session.getService()).getListeners().fireSessionDestroyed(session);-                }
<span class="code-keyword">catch</span> (Exception e) {-                    <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span> point.</span>-                    <span
class="code-comment">// We <span class="code-keyword">do</span> not want any exception
thrown from <span class="code-keyword">this</span> <span
class="code-quote">"cleanup"</span> code</span>-                    <span
class="code-comment">// to change</span>-                    <span class="code-comment">//
the <span class="code-keyword">return</span> value by bubbling
up.</span>-                    IoFilterChain filterChain =
session.getFilterChain();-                   
filterChain.fireExceptionCaught(e);-                }-            }+        <span
class="code-keyword">try</span> {+            destroy(session);+            <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;+        } <span
class="code-keyword">catch</span> (Exception e) {+            IoFilterChain filterChain =
session.getFilterChain();+            filterChain.fireExceptionCaught(e);+        } <span
class="code-keyword">finally</span> {+            <span class="code-keyword">try</span>
{+            clearWriteRequestQueue(session);+            ((AbstractIoService)
session.getService())+                .getListeners().fireSessionDestroyed(session);+  
         } <span class="code-keyword">catch</span> (Exception e) {+            <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span></span>+            <span class="code-comment">//
point.</span>+            <span class="code-comment">// We <span
class="code-keyword">do</span> not want any exception thrown from <span
class="code-keyword">this</span></span>+            <span class="code-comment">// <span
class="code-quote">"cleanup"</span> code</span>+            <span class="code-comment">//
to change</span>+            <span class="code-comment">// the <span
class="code-keyword">return</span> value by bubbling up.</span>+            IoFilterChain
filterChain = session.getFilterChain();+            filterChain.fireExceptionCaught(e);+  
         }+        }+        }              <span class="code-keyword">return</span> <span
class="code-keyword">false</span>;         }diff --git
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.javaindex
3b0fa40..fc60124 100644---
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java@@ -149,15
+149,20 @@         }     } +<span class="code-comment">//    @Override</span>+<span
class="code-comment">//    <span class="code-keyword">protected</span>
Iterator&lt;NioSession&gt; allSessions() {</span>+<span class="code-comment">//       
selectorLock.readLock().lock();</span>+<span class="code-comment">//        </span>+<span
class="code-comment">//        <span class="code-keyword">try</span> {</span>+<span
class="code-comment">//            <span class="code-keyword">return</span> <span
class="code-keyword">new</span> IoSessionIterator(selector.keys());</span>+<span
class="code-comment">//        } <span class="code-keyword">finally</span> {</span>+<span
class="code-comment">//            selectorLock.readLock().unlock();</span>+<span
class="code-comment">//        }</span>+<span class="code-comment">//    }</span>+        
@Override     <span class="code-keyword">protected</span> Iterator&lt;NioSession&gt;
allSessions() {-        selectorLock.readLock().lock();-        -        <span
class="code-keyword">try</span> {-            <span class="code-keyword">return</span>
<span class="code-keyword">new</span> IoSessionIterator(selector.keys());-        } <span
class="code-keyword">finally</span> {-           
selectorLock.readLock().unlock();-        }+        <span
class="code-keyword">return</span> <span
class="code-keyword">super</span>.allSessions();     }      @SuppressWarnings(<span
class="code-quote">"synthetic-access"</span>)@@ -182,14 +187,13 @@     @Override     <span
class="code-keyword">protected</span> void destroy(NioSession session) <span
class="code-keyword">throws</span> Exception {         ByteChannel ch =
session.getChannel();-                 SelectionKey key =
session.getSelectionKey();                  <span class="code-keyword">if</span> (key !=
<span class="code-keyword">null</span>) {             key.cancel();         }       
 -        <span class="code-keyword">if</span> ( ch.isOpen() ) {+        <span
class="code-keyword">if</span> (ch.isOpen() ) {             ch.close();         }    
}</pre></div></div> 
==============================

On issue key DIRMINA-1076 the chain pattern might have been discussed on the following comment: 
==============================
<b>Why Patch 2.0 doesn't fully work</b>Seems like <tt>Patch 2.0</tt> had a problem where
<tt>scheduleRemove(Session)</tt> would be called concurrently and have it added to the
<tt>removingSessions</tt> queue twice despite the check for <tt>contains(Session)</tt>
because both threads could check for contains(Session) and return a false-negative which
caused the <tt>Session</tt> to be added twice.  <tt>Queue</tt> lacks atomic operations
like <tt>putIfAbsent</tt> which makes it harder to solve the problem. <b>Option 1</b>One
option would be to <tt>synchronize</tt> the entire code-block; however, I felt that it
wasn't the safest option available because <tt>scheduleRemove(Session)</tt> could still be
called by an external actor after the <tt>Processor</tt> has executed
<tt>removeSessions()</tt> but before the <tt>for(...)</tt> loop cycles causing the
<tt>Session</tt> to be removed twice again even if <tt>selector.keys()</tt> was used as a
reference point.  The sequential operations would not be concurrent relative to each other
unless <tt>synchronize</tt> blocks were added all over the place.<b>Option 2</b>The safest
option to avoid this is to create a new <tt>queue</tt> which contains the active sessions
only.  The new queue serves as an atomic reference of whether a <tt>Session</tt> was
already removed or not.<b>Option 2, Liability</b>The new <tt>Queue</tt> could become a
memory leak if <tt>Sessions</tt> are added or removed in some way without calling
<tt>addNow(Session)</tt> or <tt>removeNow(Session)</tt>.<b>Patch 3.0 (Option 2) - Passes
Unit Tests</b><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..27e7d76 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-23,6 +23,7 @@ <span class="code-keyword">import</span>
java.net.PortUnreachableException; <span class="code-keyword">import</span>
java.nio.channels.ClosedSelectorException; <span class="code-keyword">import</span>
java.util.ArrayList;+<span class="code-keyword">import</span> java.util.Collections; <span
class="code-keyword">import</span> java.util.Iterator; <span
class="code-keyword">import</span> java.util.List; <span
class="code-keyword">import</span> java.util.Queue;@@ -86,6 +87,9 @@      <span
class="code-comment">/** A Session queue containing the newly created sessions
*/</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; newSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();+    +    <span
class="code-comment">/** A queue used to store all active sessions */</span>+    <span
class="code-keyword">private</span> <span class="code-keyword">final</span> Queue&lt;S&gt;
activeSessions = <span class="code-keyword">new</span>
ConcurrentLinkedQueue&lt;&gt;();      <span class="code-comment">/** A queue used to store
the sessions to be removed */</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; removingSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();@@ -239,7 +243,9 @@     
*      * @<span class="code-keyword">return</span> {@link Iterator} of {@link
IoSession}      */-    <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> Iterator&lt;S&gt; allSessions();+    <span
class="code-keyword">protected</span> Iterator&lt;S&gt; allSessions() {+        <span
class="code-keyword">return</span>
Collections.unmodifiableCollection(activeSessions).iterator();+    }      /**      * Get
an {@link Iterator} <span class="code-keyword">for</span> the list of {@link IoSession}
found selected@@ -411,7 +417,7 @@     }      <span class="code-keyword">private</span>
void scheduleRemove(S session) {-        <span class="code-keyword">if</span>
(!removingSessions.contains(session)) {+        <span class="code-keyword">if</span>
(!removingSessions.contains(session) &amp;&amp; activeSessions.contains(session))
{             removingSessions.add(session);         }     }@@ -659,9 +665,20
@@                     <span class="code-object">long</span> currentTime = <span
class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime); +                    <span class="code-comment">// Disconnect all
sessions immediately <span class="code-keyword">if</span> disposal has
been</span>+                    <span class="code-comment">// requested so that we exit
<span class="code-keyword">this</span> loop eventually.</span>+                    <span
class="code-keyword">if</span> (isDisposing()) {+                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{+                            IoSession session = i.next();+                           
scheduleRemove((S) session);+                        }+                   
}+                                         <span class="code-comment">// And manage
removed sessions</span>                     nSessions -=
removeSessions();-+                    +                    <span
class="code-keyword">assert</span> nSessions &gt; -1 : <span class="code-quote">"Internal
Session Count is Negative"</span>;+                                         <span
class="code-comment">// Last, not least, send Idle events to the idle
sessions</span>                     notifyIdleSessions(currentTime); @@ -685,26 +702,6
@@                         }                          <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }--                    <span
class="code-comment">// Disconnect all sessions immediately <span
class="code-keyword">if</span> disposal has been</span>-                    <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>-                    <span class="code-keyword">if</span>
(isDisposing()) {-                        <span class="code-object">boolean</span> hasKeys
= <span class="code-keyword">false</span>;--                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{-                            IoSession session = i.next();--                           
scheduleRemove((S) session);--                            <span
class="code-keyword">if</span> (session.isActive()) {-                               
hasKeys = <span class="code-keyword">true</span>;-                           
}-                        }--                        <span class="code-keyword">if</span>
(hasKeys) {-                            wakeup();-                       
}                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span>@@ -819,30 +816,41 @@         <span
class="code-keyword">private</span> <span class="code-object">boolean</span> addNow(S
session) {             <span class="code-object">boolean</span> registered = <span
class="code-keyword">false</span>; -            <span class="code-keyword">try</span>
{-                init(session);-                registered = <span
class="code-keyword">true</span>;+        <span class="code-keyword">try</span> {+      
 <span class="code-keyword">if</span> (activeSessions.contains(session)) {+           
<span class="code-keyword">return</span> <span class="code-keyword">true</span>;+      
 } -                <span class="code-comment">// Build the filter chain of <span
class="code-keyword">this</span> session.</span>-                IoFilterChainBuilder
chainBuilder = session.getService().getFilterChainBuilder();-               
chainBuilder.buildFilterChain(session.getFilterChain());+        <span
class="code-keyword">if</span> (activeSessions.add(session)) {+           
init(session);+            registered = <span
class="code-keyword">true</span>; -                <span class="code-comment">//
DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here</span>-                <span
class="code-comment">// in
AbstractIoFilterChain.fireSessionOpened().</span>-                <span
class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>-                IoServiceListenerSupport listeners = ((AbstractIoService)
session.getService()).getListeners();-               
listeners.fireSessionCreated(session);-            } <span
class="code-keyword">catch</span> (Exception e) {-               
ExceptionMonitor.getInstance().exceptionCaught(e);+            <span
class="code-comment">// Build the filter chain of <span class="code-keyword">this</span>
session.</span>+            IoFilterChainBuilder chainBuilder = session.getService()+  
             .getFilterChainBuilder();+           
chainBuilder.buildFilterChain(session.getFilterChain()); -                <span
class="code-keyword">try</span> {-                    destroy(session);-                }
<span class="code-keyword">catch</span> (Exception e1) {-                   
ExceptionMonitor.getInstance().exceptionCaught(e1);-                } <span
class="code-keyword">finally</span> {-                    registered = <span
class="code-keyword">false</span>;-                }-            }+            <span
class="code-comment">// DefaultIoFilterChain.CONNECT_FUTURE is cleared inside</span>+  
         <span class="code-comment">// here</span>+            <span
class="code-comment">// in AbstractIoFilterChain.fireSessionOpened().</span>+           
<span class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>+            IoServiceListenerSupport listeners = ((AbstractIoService)
session+                .getService()).getListeners();+           
listeners.fireSessionCreated(session);+        }+        } <span
class="code-keyword">catch</span> (Exception e) {+      
 ExceptionMonitor.getInstance().exceptionCaught(e);++        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+            <span
class="code-keyword">try</span> {+            destroy(session);+            } <span
class="code-keyword">catch</span> (Exception e1) {+          
 ExceptionMonitor.getInstance().exceptionCaught(e1);+            } <span
class="code-keyword">finally</span> {+            registered = <span
class="code-keyword">false</span>;+            }+        }+        }              <span
class="code-keyword">return</span> registered;         }@@ -850,40 +858,36 @@        
<span class="code-keyword">private</span> <span class="code-object">int</span>
removeSessions() {             <span class="code-object">int</span> removedSessions =
0; -            <span class="code-keyword">for</span> (S session =
removingSessions.poll(); session != <span class="code-keyword">null</span>; session =
removingSessions.poll()) {-                SessionState state = getState(session);+       
<span class="code-keyword">for</span> (S session = removingSessions.poll(); session !=
<span class="code-keyword">null</span>; session = removingSessions .poll()) {+      
 SessionState state = getState(session); -                <span class="code-comment">//
Now deal with the removal accordingly to the session's state</span>-                <span
class="code-keyword">switch</span> (state) {-                <span
class="code-keyword">case</span> OPENED:-                    <span class="code-comment">//
Try to remove <span class="code-keyword">this</span> session</span>-                   
<span class="code-keyword">if</span> (removeNow(session)) {-                       
removedSessions++;-                    }+        <span class="code-comment">// Now deal
with the removal accordingly to the session's</span>+        <span class="code-comment">//
state</span>+        <span class="code-keyword">switch</span> (state) {+        <span
class="code-keyword">case</span> OPENED:+        <span class="code-keyword">case</span>
CLOSING:+            <span class="code-comment">// Try to remove <span
class="code-keyword">this</span> session</span>+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">break</span>;+            <span
class="code-keyword">break</span>; -                <span class="code-keyword">case</span>
CLOSING:-                    <span class="code-comment">// Skip <span
class="code-keyword">if</span> channel is already closed</span>-                    <span
class="code-comment">// In any <span class="code-keyword">case</span>, remove the session
from the queue</span>-                    removedSessions++;-                    <span
class="code-keyword">break</span>;+        <span class="code-keyword">case</span>
OPENING:+            <span class="code-comment">// Remove session from the newSessions
queue and</span>+            <span class="code-comment">// remove it</span>+           
newSessions.remove(session); -                <span class="code-keyword">case</span>
OPENING:-                    <span class="code-comment">// Remove session from the
newSessions queue and</span>-                    <span class="code-comment">// remove
it</span>-                    newSessions.remove(session);+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">if</span> (removeNow(session))
{-                        removedSessions++;-                    }+            <span
class="code-keyword">break</span>; -                    <span
class="code-keyword">break</span>;--                <span
class="code-keyword">default</span>:-                    <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span
class="code-object">String</span>.valueOf(state));-                }-            }+      
 <span class="code-keyword">default</span>:+            <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span class="code-object">String</span>.valueOf(state));+      
 }+        }              <span class="code-keyword">return</span>
removedSessions;         }@@ -1145,27 +1149,32 @@         }          <span
class="code-keyword">private</span> <span class="code-object">boolean</span> removeNow(S
session) {-            clearWriteRequestQueue(session);+        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+      
 clearWriteRequestQueue(session); -            <span class="code-keyword">try</span>
{-                destroy(session);-                <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;-            }
<span class="code-keyword">catch</span> (Exception e) {-                IoFilterChain
filterChain = session.getFilterChain();-               
filterChain.fireExceptionCaught(e);-            } <span
class="code-keyword">finally</span> {-                <span
class="code-keyword">try</span> {-                   
clearWriteRequestQueue(session);-                    ((AbstractIoService)
session.getService()).getListeners().fireSessionDestroyed(session);-                }
<span class="code-keyword">catch</span> (Exception e) {-                    <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span> point.</span>-                    <span
class="code-comment">// We <span class="code-keyword">do</span> not want any exception
thrown from <span class="code-keyword">this</span> <span
class="code-quote">"cleanup"</span> code</span>-                    <span
class="code-comment">// to change</span>-                    <span class="code-comment">//
the <span class="code-keyword">return</span> value by bubbling
up.</span>-                    IoFilterChain filterChain =
session.getFilterChain();-                   
filterChain.fireExceptionCaught(e);-                }-            }+        <span
class="code-keyword">try</span> {+            destroy(session);+            <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;+        } <span
class="code-keyword">catch</span> (Exception e) {+            IoFilterChain filterChain =
session.getFilterChain();+            filterChain.fireExceptionCaught(e);+        } <span
class="code-keyword">finally</span> {+            <span class="code-keyword">try</span>
{+            clearWriteRequestQueue(session);+            ((AbstractIoService)
session.getService())+                .getListeners().fireSessionDestroyed(session);+  
         } <span class="code-keyword">catch</span> (Exception e) {+            <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span></span>+            <span class="code-comment">//
point.</span>+            <span class="code-comment">// We <span
class="code-keyword">do</span> not want any exception thrown from <span
class="code-keyword">this</span></span>+            <span class="code-comment">// <span
class="code-quote">"cleanup"</span> code</span>+            <span class="code-comment">//
to change</span>+            <span class="code-comment">// the <span
class="code-keyword">return</span> value by bubbling up.</span>+            IoFilterChain
filterChain = session.getFilterChain();+            filterChain.fireExceptionCaught(e);+  
         }+        }+        }              <span class="code-keyword">return</span> <span
class="code-keyword">false</span>;         }diff --git
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.javaindex
3b0fa40..fc60124 100644---
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java@@ -149,15
+149,20 @@         }     } +<span class="code-comment">//    @Override</span>+<span
class="code-comment">//    <span class="code-keyword">protected</span>
Iterator&lt;NioSession&gt; allSessions() {</span>+<span class="code-comment">//       
selectorLock.readLock().lock();</span>+<span class="code-comment">//        </span>+<span
class="code-comment">//        <span class="code-keyword">try</span> {</span>+<span
class="code-comment">//            <span class="code-keyword">return</span> <span
class="code-keyword">new</span> IoSessionIterator(selector.keys());</span>+<span
class="code-comment">//        } <span class="code-keyword">finally</span> {</span>+<span
class="code-comment">//            selectorLock.readLock().unlock();</span>+<span
class="code-comment">//        }</span>+<span class="code-comment">//    }</span>+        
@Override     <span class="code-keyword">protected</span> Iterator&lt;NioSession&gt;
allSessions() {-        selectorLock.readLock().lock();-        -        <span
class="code-keyword">try</span> {-            <span class="code-keyword">return</span>
<span class="code-keyword">new</span> IoSessionIterator(selector.keys());-        } <span
class="code-keyword">finally</span> {-           
selectorLock.readLock().unlock();-        }+        <span
class="code-keyword">return</span> <span
class="code-keyword">super</span>.allSessions();     }      @SuppressWarnings(<span
class="code-quote">"synthetic-access"</span>)@@ -182,14 +187,13 @@     @Override     <span
class="code-keyword">protected</span> void destroy(NioSession session) <span
class="code-keyword">throws</span> Exception {         ByteChannel ch =
session.getChannel();-                 SelectionKey key =
session.getSelectionKey();                  <span class="code-keyword">if</span> (key !=
<span class="code-keyword">null</span>) {             key.cancel();         }       
 -        <span class="code-keyword">if</span> ( ch.isOpen() ) {+        <span
class="code-keyword">if</span> (ch.isOpen() ) {             ch.close();         }    
}</pre></div></div> 
==============================

On issue key DIRMINA-1076 the Chain pattern might have been discussed on the following comment: 
==============================
<b>Why Patch 2.0 doesn't fully work</b>Seems like <tt>Patch 2.0</tt> had a problem where
<tt>scheduleRemove(Session)</tt> would be called concurrently and have it added to the
<tt>removingSessions</tt> queue twice despite the check for <tt>contains(Session)</tt>
because both threads could check for contains(Session) and return a false-negative which
caused the <tt>Session</tt> to be added twice.  <tt>Queue</tt> lacks atomic operations
like <tt>putIfAbsent</tt> which makes it harder to solve the problem. <b>Option 1</b>One
option would be to <tt>synchronize</tt> the entire code-block; however, I felt that it
wasn't the safest option available because <tt>scheduleRemove(Session)</tt> could still be
called by an external actor after the <tt>Processor</tt> has executed
<tt>removeSessions()</tt> but before the <tt>for(...)</tt> loop cycles causing the
<tt>Session</tt> to be removed twice again even if <tt>selector.keys()</tt> was used as a
reference point.  The sequential operations would not be concurrent relative to each other
unless <tt>synchronize</tt> blocks were added all over the place.<b>Option 2</b>The safest
option to avoid this is to create a new <tt>queue</tt> which contains the active sessions
only.  The new queue serves as an atomic reference of whether a <tt>Session</tt> was
already removed or not.<b>Option 2, Liability</b>The new <tt>Queue</tt> could become a
memory leak if <tt>Sessions</tt> are added or removed in some way without calling
<tt>addNow(Session)</tt> or <tt>removeNow(Session)</tt>.<b>Patch 3.0 (Option 2) - Passes
Unit Tests</b><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..27e7d76 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-23,6 +23,7 @@ <span class="code-keyword">import</span>
java.net.PortUnreachableException; <span class="code-keyword">import</span>
java.nio.channels.ClosedSelectorException; <span class="code-keyword">import</span>
java.util.ArrayList;+<span class="code-keyword">import</span> java.util.Collections; <span
class="code-keyword">import</span> java.util.Iterator; <span
class="code-keyword">import</span> java.util.List; <span
class="code-keyword">import</span> java.util.Queue;@@ -86,6 +87,9 @@      <span
class="code-comment">/** A Session queue containing the newly created sessions
*/</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; newSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();+    +    <span
class="code-comment">/** A queue used to store all active sessions */</span>+    <span
class="code-keyword">private</span> <span class="code-keyword">final</span> Queue&lt;S&gt;
activeSessions = <span class="code-keyword">new</span>
ConcurrentLinkedQueue&lt;&gt;();      <span class="code-comment">/** A queue used to store
the sessions to be removed */</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; removingSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();@@ -239,7 +243,9 @@     
*      * @<span class="code-keyword">return</span> {@link Iterator} of {@link
IoSession}      */-    <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> Iterator&lt;S&gt; allSessions();+    <span
class="code-keyword">protected</span> Iterator&lt;S&gt; allSessions() {+        <span
class="code-keyword">return</span>
Collections.unmodifiableCollection(activeSessions).iterator();+    }      /**      * Get
an {@link Iterator} <span class="code-keyword">for</span> the list of {@link IoSession}
found selected@@ -411,7 +417,7 @@     }      <span class="code-keyword">private</span>
void scheduleRemove(S session) {-        <span class="code-keyword">if</span>
(!removingSessions.contains(session)) {+        <span class="code-keyword">if</span>
(!removingSessions.contains(session) &amp;&amp; activeSessions.contains(session))
{             removingSessions.add(session);         }     }@@ -659,9 +665,20
@@                     <span class="code-object">long</span> currentTime = <span
class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime); +                    <span class="code-comment">// Disconnect all
sessions immediately <span class="code-keyword">if</span> disposal has
been</span>+                    <span class="code-comment">// requested so that we exit
<span class="code-keyword">this</span> loop eventually.</span>+                    <span
class="code-keyword">if</span> (isDisposing()) {+                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{+                            IoSession session = i.next();+                           
scheduleRemove((S) session);+                        }+                   
}+                                         <span class="code-comment">// And manage
removed sessions</span>                     nSessions -=
removeSessions();-+                    +                    <span
class="code-keyword">assert</span> nSessions &gt; -1 : <span class="code-quote">"Internal
Session Count is Negative"</span>;+                                         <span
class="code-comment">// Last, not least, send Idle events to the idle
sessions</span>                     notifyIdleSessions(currentTime); @@ -685,26 +702,6
@@                         }                          <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }--                    <span
class="code-comment">// Disconnect all sessions immediately <span
class="code-keyword">if</span> disposal has been</span>-                    <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>-                    <span class="code-keyword">if</span>
(isDisposing()) {-                        <span class="code-object">boolean</span> hasKeys
= <span class="code-keyword">false</span>;--                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{-                            IoSession session = i.next();--                           
scheduleRemove((S) session);--                            <span
class="code-keyword">if</span> (session.isActive()) {-                               
hasKeys = <span class="code-keyword">true</span>;-                           
}-                        }--                        <span class="code-keyword">if</span>
(hasKeys) {-                            wakeup();-                       
}                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span>@@ -819,30 +816,41 @@         <span
class="code-keyword">private</span> <span class="code-object">boolean</span> addNow(S
session) {             <span class="code-object">boolean</span> registered = <span
class="code-keyword">false</span>; -            <span class="code-keyword">try</span>
{-                init(session);-                registered = <span
class="code-keyword">true</span>;+        <span class="code-keyword">try</span> {+      
 <span class="code-keyword">if</span> (activeSessions.contains(session)) {+           
<span class="code-keyword">return</span> <span class="code-keyword">true</span>;+      
 } -                <span class="code-comment">// Build the filter chain of <span
class="code-keyword">this</span> session.</span>-                IoFilterChainBuilder
chainBuilder = session.getService().getFilterChainBuilder();-               
chainBuilder.buildFilterChain(session.getFilterChain());+        <span
class="code-keyword">if</span> (activeSessions.add(session)) {+           
init(session);+            registered = <span
class="code-keyword">true</span>; -                <span class="code-comment">//
DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here</span>-                <span
class="code-comment">// in
AbstractIoFilterChain.fireSessionOpened().</span>-                <span
class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>-                IoServiceListenerSupport listeners = ((AbstractIoService)
session.getService()).getListeners();-               
listeners.fireSessionCreated(session);-            } <span
class="code-keyword">catch</span> (Exception e) {-               
ExceptionMonitor.getInstance().exceptionCaught(e);+            <span
class="code-comment">// Build the filter chain of <span class="code-keyword">this</span>
session.</span>+            IoFilterChainBuilder chainBuilder = session.getService()+  
             .getFilterChainBuilder();+           
chainBuilder.buildFilterChain(session.getFilterChain()); -                <span
class="code-keyword">try</span> {-                    destroy(session);-                }
<span class="code-keyword">catch</span> (Exception e1) {-                   
ExceptionMonitor.getInstance().exceptionCaught(e1);-                } <span
class="code-keyword">finally</span> {-                    registered = <span
class="code-keyword">false</span>;-                }-            }+            <span
class="code-comment">// DefaultIoFilterChain.CONNECT_FUTURE is cleared inside</span>+  
         <span class="code-comment">// here</span>+            <span
class="code-comment">// in AbstractIoFilterChain.fireSessionOpened().</span>+           
<span class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>+            IoServiceListenerSupport listeners = ((AbstractIoService)
session+                .getService()).getListeners();+           
listeners.fireSessionCreated(session);+        }+        } <span
class="code-keyword">catch</span> (Exception e) {+      
 ExceptionMonitor.getInstance().exceptionCaught(e);++        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+            <span
class="code-keyword">try</span> {+            destroy(session);+            } <span
class="code-keyword">catch</span> (Exception e1) {+          
 ExceptionMonitor.getInstance().exceptionCaught(e1);+            } <span
class="code-keyword">finally</span> {+            registered = <span
class="code-keyword">false</span>;+            }+        }+        }              <span
class="code-keyword">return</span> registered;         }@@ -850,40 +858,36 @@        
<span class="code-keyword">private</span> <span class="code-object">int</span>
removeSessions() {             <span class="code-object">int</span> removedSessions =
0; -            <span class="code-keyword">for</span> (S session =
removingSessions.poll(); session != <span class="code-keyword">null</span>; session =
removingSessions.poll()) {-                SessionState state = getState(session);+       
<span class="code-keyword">for</span> (S session = removingSessions.poll(); session !=
<span class="code-keyword">null</span>; session = removingSessions .poll()) {+      
 SessionState state = getState(session); -                <span class="code-comment">//
Now deal with the removal accordingly to the session's state</span>-                <span
class="code-keyword">switch</span> (state) {-                <span
class="code-keyword">case</span> OPENED:-                    <span class="code-comment">//
Try to remove <span class="code-keyword">this</span> session</span>-                   
<span class="code-keyword">if</span> (removeNow(session)) {-                       
removedSessions++;-                    }+        <span class="code-comment">// Now deal
with the removal accordingly to the session's</span>+        <span class="code-comment">//
state</span>+        <span class="code-keyword">switch</span> (state) {+        <span
class="code-keyword">case</span> OPENED:+        <span class="code-keyword">case</span>
CLOSING:+            <span class="code-comment">// Try to remove <span
class="code-keyword">this</span> session</span>+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">break</span>;+            <span
class="code-keyword">break</span>; -                <span class="code-keyword">case</span>
CLOSING:-                    <span class="code-comment">// Skip <span
class="code-keyword">if</span> channel is already closed</span>-                    <span
class="code-comment">// In any <span class="code-keyword">case</span>, remove the session
from the queue</span>-                    removedSessions++;-                    <span
class="code-keyword">break</span>;+        <span class="code-keyword">case</span>
OPENING:+            <span class="code-comment">// Remove session from the newSessions
queue and</span>+            <span class="code-comment">// remove it</span>+           
newSessions.remove(session); -                <span class="code-keyword">case</span>
OPENING:-                    <span class="code-comment">// Remove session from the
newSessions queue and</span>-                    <span class="code-comment">// remove
it</span>-                    newSessions.remove(session);+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">if</span> (removeNow(session))
{-                        removedSessions++;-                    }+            <span
class="code-keyword">break</span>; -                    <span
class="code-keyword">break</span>;--                <span
class="code-keyword">default</span>:-                    <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span
class="code-object">String</span>.valueOf(state));-                }-            }+      
 <span class="code-keyword">default</span>:+            <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span class="code-object">String</span>.valueOf(state));+      
 }+        }              <span class="code-keyword">return</span>
removedSessions;         }@@ -1145,27 +1149,32 @@         }          <span
class="code-keyword">private</span> <span class="code-object">boolean</span> removeNow(S
session) {-            clearWriteRequestQueue(session);+        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+      
 clearWriteRequestQueue(session); -            <span class="code-keyword">try</span>
{-                destroy(session);-                <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;-            }
<span class="code-keyword">catch</span> (Exception e) {-                IoFilterChain
filterChain = session.getFilterChain();-               
filterChain.fireExceptionCaught(e);-            } <span
class="code-keyword">finally</span> {-                <span
class="code-keyword">try</span> {-                   
clearWriteRequestQueue(session);-                    ((AbstractIoService)
session.getService()).getListeners().fireSessionDestroyed(session);-                }
<span class="code-keyword">catch</span> (Exception e) {-                    <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span> point.</span>-                    <span
class="code-comment">// We <span class="code-keyword">do</span> not want any exception
thrown from <span class="code-keyword">this</span> <span
class="code-quote">"cleanup"</span> code</span>-                    <span
class="code-comment">// to change</span>-                    <span class="code-comment">//
the <span class="code-keyword">return</span> value by bubbling
up.</span>-                    IoFilterChain filterChain =
session.getFilterChain();-                   
filterChain.fireExceptionCaught(e);-                }-            }+        <span
class="code-keyword">try</span> {+            destroy(session);+            <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;+        } <span
class="code-keyword">catch</span> (Exception e) {+            IoFilterChain filterChain =
session.getFilterChain();+            filterChain.fireExceptionCaught(e);+        } <span
class="code-keyword">finally</span> {+            <span class="code-keyword">try</span>
{+            clearWriteRequestQueue(session);+            ((AbstractIoService)
session.getService())+                .getListeners().fireSessionDestroyed(session);+  
         } <span class="code-keyword">catch</span> (Exception e) {+            <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span></span>+            <span class="code-comment">//
point.</span>+            <span class="code-comment">// We <span
class="code-keyword">do</span> not want any exception thrown from <span
class="code-keyword">this</span></span>+            <span class="code-comment">// <span
class="code-quote">"cleanup"</span> code</span>+            <span class="code-comment">//
to change</span>+            <span class="code-comment">// the <span
class="code-keyword">return</span> value by bubbling up.</span>+            IoFilterChain
filterChain = session.getFilterChain();+            filterChain.fireExceptionCaught(e);+  
         }+        }+        }              <span class="code-keyword">return</span> <span
class="code-keyword">false</span>;         }diff --git
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.javaindex
3b0fa40..fc60124 100644---
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java@@ -149,15
+149,20 @@         }     } +<span class="code-comment">//    @Override</span>+<span
class="code-comment">//    <span class="code-keyword">protected</span>
Iterator&lt;NioSession&gt; allSessions() {</span>+<span class="code-comment">//       
selectorLock.readLock().lock();</span>+<span class="code-comment">//        </span>+<span
class="code-comment">//        <span class="code-keyword">try</span> {</span>+<span
class="code-comment">//            <span class="code-keyword">return</span> <span
class="code-keyword">new</span> IoSessionIterator(selector.keys());</span>+<span
class="code-comment">//        } <span class="code-keyword">finally</span> {</span>+<span
class="code-comment">//            selectorLock.readLock().unlock();</span>+<span
class="code-comment">//        }</span>+<span class="code-comment">//    }</span>+        
@Override     <span class="code-keyword">protected</span> Iterator&lt;NioSession&gt;
allSessions() {-        selectorLock.readLock().lock();-        -        <span
class="code-keyword">try</span> {-            <span class="code-keyword">return</span>
<span class="code-keyword">new</span> IoSessionIterator(selector.keys());-        } <span
class="code-keyword">finally</span> {-           
selectorLock.readLock().unlock();-        }+        <span
class="code-keyword">return</span> <span
class="code-keyword">super</span>.allSessions();     }      @SuppressWarnings(<span
class="code-quote">"synthetic-access"</span>)@@ -182,14 +187,13 @@     @Override     <span
class="code-keyword">protected</span> void destroy(NioSession session) <span
class="code-keyword">throws</span> Exception {         ByteChannel ch =
session.getChannel();-                 SelectionKey key =
session.getSelectionKey();                  <span class="code-keyword">if</span> (key !=
<span class="code-keyword">null</span>) {             key.cancel();         }       
 -        <span class="code-keyword">if</span> ( ch.isOpen() ) {+        <span
class="code-keyword">if</span> (ch.isOpen() ) {             ch.close();         }    
}</pre></div></div> 
==============================

New Comment: 
<b>Why Patch 2.0 doesn't fully work</b>Seems like <tt>Patch 2.0</tt> had a problem where
<tt>scheduleRemove(Session)</tt> would be called concurrently and have it added to the
<tt>removingSessions</tt> queue twice despite the check for <tt>contains(Session)</tt>
because both threads could check for contains(Session) and return a false-negative which
caused the <tt>Session</tt> to be added twice.  <tt>Queue</tt> lacks atomic operations
like <tt>putIfAbsent</tt> which makes it harder to solve the problem. <b>Option 1</b>One
option would be to <tt>synchronize</tt> the entire code-block; however, I felt that it
wasn't the safest option available because <tt>scheduleRemove(Session)</tt> could still be
called by an external actor after the <tt>Processor</tt> has executed
<tt>removeSessions()</tt> but before the <tt>for(...)</tt> loop cycles causing the
<tt>Session</tt> to be removed twice again even if <tt>selector.keys()</tt> was used as a
reference point.  The sequential operations would not be concurrent relative to each other
unless <tt>synchronize</tt> blocks were added all over the place.<b>Option 2</b>The safest
option to avoid this is to create a new <tt>queue</tt> which contains the active sessions
only.  The new queue serves as an atomic reference of whether a <tt>Session</tt> was
already removed or not.<b>Option 2, Liability</b>The new <tt>Queue</tt> could become a
memory leak if <tt>Sessions</tt> are added or removed in some way without calling
<tt>addNow(Session)</tt> or <tt>removeNow(Session)</tt>.<b>Patch 3.0 (Option 2) - Passes
Unit Tests</b><div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..27e7d76 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-23,6 +23,7 @@ <span class="code-keyword">import</span>
java.net.PortUnreachableException; <span class="code-keyword">import</span>
java.nio.channels.ClosedSelectorException; <span class="code-keyword">import</span>
java.util.ArrayList;+<span class="code-keyword">import</span> java.util.Collections; <span
class="code-keyword">import</span> java.util.Iterator; <span
class="code-keyword">import</span> java.util.List; <span
class="code-keyword">import</span> java.util.Queue;@@ -86,6 +87,9 @@      <span
class="code-comment">/** A Session queue containing the newly created sessions
*/</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; newSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();+    +    <span
class="code-comment">/** A queue used to store all active sessions */</span>+    <span
class="code-keyword">private</span> <span class="code-keyword">final</span> Queue&lt;S&gt;
activeSessions = <span class="code-keyword">new</span>
ConcurrentLinkedQueue&lt;&gt;();      <span class="code-comment">/** A queue used to store
the sessions to be removed */</span>     <span class="code-keyword">private</span> <span
class="code-keyword">final</span> Queue&lt;S&gt; removingSessions = <span
class="code-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();@@ -239,7 +243,9 @@     
*      * @<span class="code-keyword">return</span> {@link Iterator} of {@link
IoSession}      */-    <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> Iterator&lt;S&gt; allSessions();+    <span
class="code-keyword">protected</span> Iterator&lt;S&gt; allSessions() {+        <span
class="code-keyword">return</span>
Collections.unmodifiableCollection(activeSessions).iterator();+    }      /**      * Get
an {@link Iterator} <span class="code-keyword">for</span> the list of {@link IoSession}
found selected@@ -411,7 +417,7 @@     }      <span class="code-keyword">private</span>
void scheduleRemove(S session) {-        <span class="code-keyword">if</span>
(!removingSessions.contains(session)) {+        <span class="code-keyword">if</span>
(!removingSessions.contains(session) &amp;&amp; activeSessions.contains(session))
{             removingSessions.add(session);         }     }@@ -659,9 +665,20
@@                     <span class="code-object">long</span> currentTime = <span
class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime); +                    <span class="code-comment">// Disconnect all
sessions immediately <span class="code-keyword">if</span> disposal has
been</span>+                    <span class="code-comment">// requested so that we exit
<span class="code-keyword">this</span> loop eventually.</span>+                    <span
class="code-keyword">if</span> (isDisposing()) {+                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{+                            IoSession session = i.next();+                           
scheduleRemove((S) session);+                        }+                   
}+                                         <span class="code-comment">// And manage
removed sessions</span>                     nSessions -=
removeSessions();-+                    +                    <span
class="code-keyword">assert</span> nSessions &gt; -1 : <span class="code-quote">"Internal
Session Count is Negative"</span>;+                                         <span
class="code-comment">// Last, not least, send Idle events to the idle
sessions</span>                     notifyIdleSessions(currentTime); @@ -685,26 +702,6
@@                         }                          <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }--                    <span
class="code-comment">// Disconnect all sessions immediately <span
class="code-keyword">if</span> disposal has been</span>-                    <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>-                    <span class="code-keyword">if</span>
(isDisposing()) {-                        <span class="code-object">boolean</span> hasKeys
= <span class="code-keyword">false</span>;--                        <span
class="code-keyword">for</span> (Iterator&lt;S&gt; i = allSessions(); i.hasNext();)
{-                            IoSession session = i.next();--                           
scheduleRemove((S) session);--                            <span
class="code-keyword">if</span> (session.isActive()) {-                               
hasKeys = <span class="code-keyword">true</span>;-                           
}-                        }--                        <span class="code-keyword">if</span>
(hasKeys) {-                            wakeup();-                       
}                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span>@@ -819,30 +816,41 @@         <span
class="code-keyword">private</span> <span class="code-object">boolean</span> addNow(S
session) {             <span class="code-object">boolean</span> registered = <span
class="code-keyword">false</span>; -            <span class="code-keyword">try</span>
{-                init(session);-                registered = <span
class="code-keyword">true</span>;+        <span class="code-keyword">try</span> {+      
 <span class="code-keyword">if</span> (activeSessions.contains(session)) {+           
<span class="code-keyword">return</span> <span class="code-keyword">true</span>;+      
 } -                <span class="code-comment">// Build the filter chain of <span
class="code-keyword">this</span> session.</span>-                IoFilterChainBuilder
chainBuilder = session.getService().getFilterChainBuilder();-               
chainBuilder.buildFilterChain(session.getFilterChain());+        <span
class="code-keyword">if</span> (activeSessions.add(session)) {+           
init(session);+            registered = <span
class="code-keyword">true</span>; -                <span class="code-comment">//
DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here</span>-                <span
class="code-comment">// in
AbstractIoFilterChain.fireSessionOpened().</span>-                <span
class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>-                IoServiceListenerSupport listeners = ((AbstractIoService)
session.getService()).getListeners();-               
listeners.fireSessionCreated(session);-            } <span
class="code-keyword">catch</span> (Exception e) {-               
ExceptionMonitor.getInstance().exceptionCaught(e);+            <span
class="code-comment">// Build the filter chain of <span class="code-keyword">this</span>
session.</span>+            IoFilterChainBuilder chainBuilder = session.getService()+  
             .getFilterChainBuilder();+           
chainBuilder.buildFilterChain(session.getFilterChain()); -                <span
class="code-keyword">try</span> {-                    destroy(session);-                }
<span class="code-keyword">catch</span> (Exception e1) {-                   
ExceptionMonitor.getInstance().exceptionCaught(e1);-                } <span
class="code-keyword">finally</span> {-                    registered = <span
class="code-keyword">false</span>;-                }-            }+            <span
class="code-comment">// DefaultIoFilterChain.CONNECT_FUTURE is cleared inside</span>+  
         <span class="code-comment">// here</span>+            <span
class="code-comment">// in AbstractIoFilterChain.fireSessionOpened().</span>+           
<span class="code-comment">// Propagate the SESSION_CREATED event up to the
chain</span>+            IoServiceListenerSupport listeners = ((AbstractIoService)
session+                .getService()).getListeners();+           
listeners.fireSessionCreated(session);+        }+        } <span
class="code-keyword">catch</span> (Exception e) {+      
 ExceptionMonitor.getInstance().exceptionCaught(e);++        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+            <span
class="code-keyword">try</span> {+            destroy(session);+            } <span
class="code-keyword">catch</span> (Exception e1) {+          
 ExceptionMonitor.getInstance().exceptionCaught(e1);+            } <span
class="code-keyword">finally</span> {+            registered = <span
class="code-keyword">false</span>;+            }+        }+        }              <span
class="code-keyword">return</span> registered;         }@@ -850,40 +858,36 @@        
<span class="code-keyword">private</span> <span class="code-object">int</span>
removeSessions() {             <span class="code-object">int</span> removedSessions =
0; -            <span class="code-keyword">for</span> (S session =
removingSessions.poll(); session != <span class="code-keyword">null</span>; session =
removingSessions.poll()) {-                SessionState state = getState(session);+       
<span class="code-keyword">for</span> (S session = removingSessions.poll(); session !=
<span class="code-keyword">null</span>; session = removingSessions .poll()) {+      
 SessionState state = getState(session); -                <span class="code-comment">//
Now deal with the removal accordingly to the session's state</span>-                <span
class="code-keyword">switch</span> (state) {-                <span
class="code-keyword">case</span> OPENED:-                    <span class="code-comment">//
Try to remove <span class="code-keyword">this</span> session</span>-                   
<span class="code-keyword">if</span> (removeNow(session)) {-                       
removedSessions++;-                    }+        <span class="code-comment">// Now deal
with the removal accordingly to the session's</span>+        <span class="code-comment">//
state</span>+        <span class="code-keyword">switch</span> (state) {+        <span
class="code-keyword">case</span> OPENED:+        <span class="code-keyword">case</span>
CLOSING:+            <span class="code-comment">// Try to remove <span
class="code-keyword">this</span> session</span>+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">break</span>;+            <span
class="code-keyword">break</span>; -                <span class="code-keyword">case</span>
CLOSING:-                    <span class="code-comment">// Skip <span
class="code-keyword">if</span> channel is already closed</span>-                    <span
class="code-comment">// In any <span class="code-keyword">case</span>, remove the session
from the queue</span>-                    removedSessions++;-                    <span
class="code-keyword">break</span>;+        <span class="code-keyword">case</span>
OPENING:+            <span class="code-comment">// Remove session from the newSessions
queue and</span>+            <span class="code-comment">// remove it</span>+           
newSessions.remove(session); -                <span class="code-keyword">case</span>
OPENING:-                    <span class="code-comment">// Remove session from the
newSessions queue and</span>-                    <span class="code-comment">// remove
it</span>-                    newSessions.remove(session);+            <span
class="code-keyword">if</span> (removeNow(session)) {+            removedSessions++;+  
         } -                    <span class="code-keyword">if</span> (removeNow(session))
{-                        removedSessions++;-                    }+            <span
class="code-keyword">break</span>; -                    <span
class="code-keyword">break</span>;--                <span
class="code-keyword">default</span>:-                    <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span
class="code-object">String</span>.valueOf(state));-                }-            }+      
 <span class="code-keyword">default</span>:+            <span
class="code-keyword">throw</span> <span class="code-keyword">new</span>
IllegalStateException(<span class="code-object">String</span>.valueOf(state));+      
 }+        }              <span class="code-keyword">return</span>
removedSessions;         }@@ -1145,27 +1149,32 @@         }          <span
class="code-keyword">private</span> <span class="code-object">boolean</span> removeNow(S
session) {-            clearWriteRequestQueue(session);+        <span
class="code-keyword">if</span> (activeSessions.remove(session)) {+      
 clearWriteRequestQueue(session); -            <span class="code-keyword">try</span>
{-                destroy(session);-                <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;-            }
<span class="code-keyword">catch</span> (Exception e) {-                IoFilterChain
filterChain = session.getFilterChain();-               
filterChain.fireExceptionCaught(e);-            } <span
class="code-keyword">finally</span> {-                <span
class="code-keyword">try</span> {-                   
clearWriteRequestQueue(session);-                    ((AbstractIoService)
session.getService()).getListeners().fireSessionDestroyed(session);-                }
<span class="code-keyword">catch</span> (Exception e) {-                    <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span> point.</span>-                    <span
class="code-comment">// We <span class="code-keyword">do</span> not want any exception
thrown from <span class="code-keyword">this</span> <span
class="code-quote">"cleanup"</span> code</span>-                    <span
class="code-comment">// to change</span>-                    <span class="code-comment">//
the <span class="code-keyword">return</span> value by bubbling
up.</span>-                    IoFilterChain filterChain =
session.getFilterChain();-                   
filterChain.fireExceptionCaught(e);-                }-            }+        <span
class="code-keyword">try</span> {+            destroy(session);+            <span
class="code-keyword">return</span> <span class="code-keyword">true</span>;+        } <span
class="code-keyword">catch</span> (Exception e) {+            IoFilterChain filterChain =
session.getFilterChain();+            filterChain.fireExceptionCaught(e);+        } <span
class="code-keyword">finally</span> {+            <span class="code-keyword">try</span>
{+            clearWriteRequestQueue(session);+            ((AbstractIoService)
session.getService())+                .getListeners().fireSessionDestroyed(session);+  
         } <span class="code-keyword">catch</span> (Exception e) {+            <span
class="code-comment">// The session was either destroyed or not at <span
class="code-keyword">this</span></span>+            <span class="code-comment">//
point.</span>+            <span class="code-comment">// We <span
class="code-keyword">do</span> not want any exception thrown from <span
class="code-keyword">this</span></span>+            <span class="code-comment">// <span
class="code-quote">"cleanup"</span> code</span>+            <span class="code-comment">//
to change</span>+            <span class="code-comment">// the <span
class="code-keyword">return</span> value by bubbling up.</span>+            IoFilterChain
filterChain = session.getFilterChain();+            filterChain.fireExceptionCaught(e);+  
         }+        }+        }              <span class="code-keyword">return</span> <span
class="code-keyword">false</span>;         }diff --git
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.javaindex
3b0fa40..fc60124 100644---
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java@@ -149,15
+149,20 @@         }     } +<span class="code-comment">//    @Override</span>+<span
class="code-comment">//    <span class="code-keyword">protected</span>
Iterator&lt;NioSession&gt; allSessions() {</span>+<span class="code-comment">//       
selectorLock.readLock().lock();</span>+<span class="code-comment">//        </span>+<span
class="code-comment">//        <span class="code-keyword">try</span> {</span>+<span
class="code-comment">//            <span class="code-keyword">return</span> <span
class="code-keyword">new</span> IoSessionIterator(selector.keys());</span>+<span
class="code-comment">//        } <span class="code-keyword">finally</span> {</span>+<span
class="code-comment">//            selectorLock.readLock().unlock();</span>+<span
class="code-comment">//        }</span>+<span class="code-comment">//    }</span>+        
@Override     <span class="code-keyword">protected</span> Iterator&lt;NioSession&gt;
allSessions() {-        selectorLock.readLock().lock();-        -        <span
class="code-keyword">try</span> {-            <span class="code-keyword">return</span>
<span class="code-keyword">new</span> IoSessionIterator(selector.keys());-        } <span
class="code-keyword">finally</span> {-           
selectorLock.readLock().unlock();-        }+        <span
class="code-keyword">return</span> <span
class="code-keyword">super</span>.allSessions();     }      @SuppressWarnings(<span
class="code-quote">"synthetic-access"</span>)@@ -182,14 +187,13 @@     @Override     <span
class="code-keyword">protected</span> void destroy(NioSession session) <span
class="code-keyword">throws</span> Exception {         ByteChannel ch =
session.getChannel();-                 SelectionKey key =
session.getSelectionKey();                  <span class="code-keyword">if</span> (key !=
<span class="code-keyword">null</span>) {             key.cancel();         }       
 -        <span class="code-keyword">if</span> ( ch.isOpen() ) {+        <span
class="code-keyword">if</span> (ch.isOpen() ) {             ch.close();         }    
}</pre></div></div> 


New Comment: 
A question : if the pb is the <tt>scheduleRemove()</tt> method being called twice, leading
to the session being added twice from the queue, why don't we protect the queue by adding
a lock around it, making the <tt>contains</tt> and <tt>remove</tt> calls tied ? Something
like :<div class="preformatted panel" style="border-width: 1px;"><div
class="preformattedContent panelContent"><pre>    private Lock sessionQueueLock = new
ReentrantLock();...    private void scheduleRemove(S session) {        lock.lock();       
try {            if (!removingSessions.contains(session)) {               
removingSessions.add(session);        } finally {            lock.unlock();        }   
}</pre></div></div>This way, you can't add a session to the queue if it's already
contained i the queue.WDYT ? 


New Comment: 
The problem is no atomic method of knowing of an <tt>Session</tt> has already been removed
or not.  Its more than just "duplicates" inside of the queue because it could be added
back to the queue after it was removed.  The tests are showing that it is very possible to
add to the remove queue, remove, then another thread add it back to the remove queue.I
covered that as an option under the heading <b>Option 1</b>.  The problem cannot be fixed
using locks unless both the <tt>scheduleRemove()</tt> and everything after
<tt>select()</tt> inside of <tt>processor.run()</tt> to be inside of the lock.  It would
require that <tt>scheduleRemove()</tt> only happen while the processor is performing a
<tt>select()</tt> in order to guarantee order.  Even with two large critical sections,
there is the nasty problem of being able to use selector.keys{{()}} to verify if the
<tt>session</tt> is actually registered with that <tt>processor</tt>.  To correctly fix it
with locks might require extra <tt>selectNow()</tt> calls in order to update
<tt>selector.keys()</tt>.  Its just ugly. The other alternative might be to completely gut
the <tt>nSessions</tt> mechanic and just use <tt>selector.keys().size()</tt> to determine
when to dispose of the processor. 


On issue key DIRMINA-1076 the  state  pattern might have been discussed on the following comment: 
==============================
Right. One of the problem is that the session state is always computed, it's never hold by
the session, otherwise we would have been able to check if the session is currently being
removing, forbidding another removal to be done... Option 2 is trying to mimic
that.Another possibility might be to rethink the way the session state is handled :
<ul>	<li>we add a new state (REMOVING) in the <tt>SessionState</tt> enum</li>	<li>We add a
field in the <tt>NioSession</tt> class which holds the session's state</li>	<li>We
set/check this state when we call <tt>getState</tt> or when we call
<tt>scheduleRemove</tt></li></ul>It may be less likely to create a memory leak. At this
point, it's just an idea, I don't foresee all the pros and cons of this approach, I need
to sleep over it (it's 5AM atm...) 
==============================

New Comment: 
Right. One of the problem is that the session state is always computed, it's never hold by
the session, otherwise we would have been able to check if the session is currently being
removing, forbidding another removal to be done... Option 2 is trying to mimic
that.Another possibility might be to rethink the way the session state is handled :
<ul>	<li>we add a new state (REMOVING) in the <tt>SessionState</tt> enum</li>	<li>We add a
field in the <tt>NioSession</tt> class which holds the session's state</li>	<li>We
set/check this state when we call <tt>getState</tt> or when we call
<tt>scheduleRemove</tt></li></ul>It may be less likely to create a memory leak. At this
point, it's just an idea, I don't foresee all the pros and cons of this approach, I need
to sleep over it (it's 5AM atm...) 


On issue key DIRMINA-1076 the  state  pattern might have been discussed on the following comment: 
==============================
In the previous post, I mentioned the possibility of totally removing the
<tt>nSession</tt> state.<b>Option 3</b><br/>Completely removes the <tt>nSession</tt> state
because it is corruptible.  Relies entirely on <tt>selector.keys().size()</tt> for the
state.  This is actually the most simple of all the alternatives as it requires no new
atomic mechanisms.  Only drawback is that it might take longer to <tt>dispose()</tt> the
<tt>IoProcessor</tt> due the extra <tt>select()</tt> cycle that must occur to update the
session count.<div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..c807bf1 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-240,6 +240,13 @@      * @<span class="code-keyword">return</span> {@link Iterator} of
{@link IoSession}      */     <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> Iterator&lt;S&gt; allSessions();+    +    /**+     *
Get the number of {@Link IoSession} polled by <span class="code-keyword">this</span>
{@Link IoProcessor}+     *+     * @<span class="code-keyword">return</span> the number of
sessions attached to <span class="code-keyword">this</span> {@Link IoProcessor}+    
*/+    <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> <span class="code-object">int</span>
allSessionsCount();      /**      * Get an {@link Iterator} <span
class="code-keyword">for</span> the list of {@link IoSession} found selected@@ -596,7
+603,6 @@         <span class="code-keyword">public</span> void run() {             <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>; -            <span class="code-object">int</span>
nSessions = 0;             lastIdleCheckTime = <span
class="code-object">System</span>.currentTimeMillis();             <span
class="code-object">int</span> nbTries = 10; @@ -641,9 +647,31 @@                     }
<span class="code-keyword">else</span> {                         nbTries =
10;                     }-+                                         <span
class="code-comment">// Manage newly created session first</span>-                   
nSessions += handleNewSessions();+                    <span
class="code-keyword">if</span>(handleNewSessions() == 0) {+                        <span
class="code-comment">// Get a chance to exit the infinite loop <span
class="code-keyword">if</span> there are no</span>+                        <span
class="code-comment">// more sessions on <span class="code-keyword">this</span>
Processor</span>+                        <span class="code-keyword">if</span>
(allSessionsCount() == 0) {+                            processorRef.set(<span
class="code-keyword">null</span>);++                            <span
class="code-keyword">if</span> (newSessions.isEmpty() &amp;&amp; isSelectorEmpty())
{+                                <span class="code-comment">// newSessions.add() precedes
startupProcessor</span>+                                <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;+                                <span
class="code-keyword">break</span>;+                           
}++                            <span class="code-keyword">assert</span> processorRef.get()
!= <span class="code-keyword">this</span>;++                            <span
class="code-keyword">if</span> (!processorRef.compareAndSet(<span
class="code-keyword">null</span>, <span class="code-keyword">this</span>))
{+                                <span class="code-comment">// startupProcessor won race,
so must exit processor</span>+                                <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;+                                <span
class="code-keyword">break</span>;+                           
}++                            <span class="code-keyword">assert</span> processorRef.get()
== <span class="code-keyword">this</span>;+                        }+                   
}                      updateTrafficMask(); @@ -654,39 +682,17 @@                        
<span class="code-comment">// the MDCFilter test...</span>                        
process();                     }-+                                         <span
class="code-comment">// Write the pending requests</span>                     <span
class="code-object">long</span> currentTime = <span
class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime);--                    <span class="code-comment">// And manage removed
sessions</span>-                    nSessions -= removeSessions();-+                  
                      <span class="code-comment">// Last, not least, send Idle events to
the idle sessions</span>                    
notifyIdleSessions(currentTime);--                    <span class="code-comment">// Get a
chance to exit the infinite loop <span class="code-keyword">if</span> there are
no</span>-                    <span class="code-comment">// more sessions on <span
class="code-keyword">this</span> Processor</span>-                    <span
class="code-keyword">if</span> (nSessions == 0) {-                       
processorRef.set(<span class="code-keyword">null</span>);--                        <span
class="code-keyword">if</span> (newSessions.isEmpty() &amp;&amp; isSelectorEmpty())
{-                            <span class="code-comment">// newSessions.add() precedes
startupProcessor</span>-                            <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;-                            <span
class="code-keyword">break</span>;-                        }--                       
<span class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;--                        <span
class="code-keyword">if</span> (!processorRef.compareAndSet(<span
class="code-keyword">null</span>, <span class="code-keyword">this</span>))
{-                            <span class="code-comment">// startupProcessor won race, so
must exit processor</span>-                            <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;-                            <span
class="code-keyword">break</span>;-                        }--                       
<span class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }-+                  
 +                    <span class="code-comment">// And manage removed
sessions</span>+                    removeSessions();+                  
                      <span class="code-comment">// Disconnect all sessions immediately
<span class="code-keyword">if</span> disposal has been</span>                     <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>                     <span class="code-keyword">if</span>
(isDisposing()) {@@ -702,9 +708,7 @@                             }                        
} -                        <span class="code-keyword">if</span> (hasKeys)
{-                            wakeup();-                        }+                       
wakeup();                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span>diff --git
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.javaindex
3b0fa40..9948d7a 100644---
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java@@ -159,6
+159,12 @@             selectorLock.readLock().unlock();         }     }+    +   
@Override+    <span class="code-keyword">protected</span> <span
class="code-object">int</span> allSessionsCount()+    {+        <span
class="code-keyword">return</span> selector.keys().size();+    }     
@SuppressWarnings(<span class="code-quote">"synthetic-access"</span>)     @Overridediff
--git
a/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.java
b/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.javaindex
379f55b..f289aaf 100644---
a/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.java+++
b/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.java@@
-61,6 +61,11 @@             <span class="code-keyword">protected</span>
Iterator&lt;NioSession&gt; allSessions() {                 <span
class="code-keyword">return</span> proc.allSessions();             }+          
 +            @Override+            <span class="code-keyword">protected</span> <span
class="code-object">int</span> allSessionsCount() {+                <span
class="code-keyword">return</span> proc.allSessionsCount();+            }             
@Override             <span class="code-keyword">protected</span> void destroy(NioSession
session) <span class="code-keyword">throws</span> Exception {</pre></div></div> 
==============================

On issue key DIRMINA-1076 the mediate pattern might have been discussed on the following comment: 
==============================
In the previous post, I mentioned the possibility of totally removing the
<tt>nSession</tt> state.<b>Option 3</b><br/>Completely removes the <tt>nSession</tt> state
because it is corruptible.  Relies entirely on <tt>selector.keys().size()</tt> for the
state.  This is actually the most simple of all the alternatives as it requires no new
atomic mechanisms.  Only drawback is that it might take longer to <tt>dispose()</tt> the
<tt>IoProcessor</tt> due the extra <tt>select()</tt> cycle that must occur to update the
session count.<div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..c807bf1 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-240,6 +240,13 @@      * @<span class="code-keyword">return</span> {@link Iterator} of
{@link IoSession}      */     <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> Iterator&lt;S&gt; allSessions();+    +    /**+     *
Get the number of {@Link IoSession} polled by <span class="code-keyword">this</span>
{@Link IoProcessor}+     *+     * @<span class="code-keyword">return</span> the number of
sessions attached to <span class="code-keyword">this</span> {@Link IoProcessor}+    
*/+    <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> <span class="code-object">int</span>
allSessionsCount();      /**      * Get an {@link Iterator} <span
class="code-keyword">for</span> the list of {@link IoSession} found selected@@ -596,7
+603,6 @@         <span class="code-keyword">public</span> void run() {             <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>; -            <span class="code-object">int</span>
nSessions = 0;             lastIdleCheckTime = <span
class="code-object">System</span>.currentTimeMillis();             <span
class="code-object">int</span> nbTries = 10; @@ -641,9 +647,31 @@                     }
<span class="code-keyword">else</span> {                         nbTries =
10;                     }-+                                         <span
class="code-comment">// Manage newly created session first</span>-                   
nSessions += handleNewSessions();+                    <span
class="code-keyword">if</span>(handleNewSessions() == 0) {+                        <span
class="code-comment">// Get a chance to exit the infinite loop <span
class="code-keyword">if</span> there are no</span>+                        <span
class="code-comment">// more sessions on <span class="code-keyword">this</span>
Processor</span>+                        <span class="code-keyword">if</span>
(allSessionsCount() == 0) {+                            processorRef.set(<span
class="code-keyword">null</span>);++                            <span
class="code-keyword">if</span> (newSessions.isEmpty() &amp;&amp; isSelectorEmpty())
{+                                <span class="code-comment">// newSessions.add() precedes
startupProcessor</span>+                                <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;+                                <span
class="code-keyword">break</span>;+                           
}++                            <span class="code-keyword">assert</span> processorRef.get()
!= <span class="code-keyword">this</span>;++                            <span
class="code-keyword">if</span> (!processorRef.compareAndSet(<span
class="code-keyword">null</span>, <span class="code-keyword">this</span>))
{+                                <span class="code-comment">// startupProcessor won race,
so must exit processor</span>+                                <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;+                                <span
class="code-keyword">break</span>;+                           
}++                            <span class="code-keyword">assert</span> processorRef.get()
== <span class="code-keyword">this</span>;+                        }+                   
}                      updateTrafficMask(); @@ -654,39 +682,17 @@                        
<span class="code-comment">// the MDCFilter test...</span>                        
process();                     }-+                                         <span
class="code-comment">// Write the pending requests</span>                     <span
class="code-object">long</span> currentTime = <span
class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime);--                    <span class="code-comment">// And manage removed
sessions</span>-                    nSessions -= removeSessions();-+                  
                      <span class="code-comment">// Last, not least, send Idle events to
the idle sessions</span>                    
notifyIdleSessions(currentTime);--                    <span class="code-comment">// Get a
chance to exit the infinite loop <span class="code-keyword">if</span> there are
no</span>-                    <span class="code-comment">// more sessions on <span
class="code-keyword">this</span> Processor</span>-                    <span
class="code-keyword">if</span> (nSessions == 0) {-                       
processorRef.set(<span class="code-keyword">null</span>);--                        <span
class="code-keyword">if</span> (newSessions.isEmpty() &amp;&amp; isSelectorEmpty())
{-                            <span class="code-comment">// newSessions.add() precedes
startupProcessor</span>-                            <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;-                            <span
class="code-keyword">break</span>;-                        }--                       
<span class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;--                        <span
class="code-keyword">if</span> (!processorRef.compareAndSet(<span
class="code-keyword">null</span>, <span class="code-keyword">this</span>))
{-                            <span class="code-comment">// startupProcessor won race, so
must exit processor</span>-                            <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;-                            <span
class="code-keyword">break</span>;-                        }--                       
<span class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }-+                  
 +                    <span class="code-comment">// And manage removed
sessions</span>+                    removeSessions();+                  
                      <span class="code-comment">// Disconnect all sessions immediately
<span class="code-keyword">if</span> disposal has been</span>                     <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>                     <span class="code-keyword">if</span>
(isDisposing()) {@@ -702,9 +708,7 @@                             }                        
} -                        <span class="code-keyword">if</span> (hasKeys)
{-                            wakeup();-                        }+                       
wakeup();                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span>diff --git
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.javaindex
3b0fa40..9948d7a 100644---
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java@@ -159,6
+159,12 @@             selectorLock.readLock().unlock();         }     }+    +   
@Override+    <span class="code-keyword">protected</span> <span
class="code-object">int</span> allSessionsCount()+    {+        <span
class="code-keyword">return</span> selector.keys().size();+    }     
@SuppressWarnings(<span class="code-quote">"synthetic-access"</span>)     @Overridediff
--git
a/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.java
b/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.javaindex
379f55b..f289aaf 100644---
a/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.java+++
b/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.java@@
-61,6 +61,11 @@             <span class="code-keyword">protected</span>
Iterator&lt;NioSession&gt; allSessions() {                 <span
class="code-keyword">return</span> proc.allSessions();             }+          
 +            @Override+            <span class="code-keyword">protected</span> <span
class="code-object">int</span> allSessionsCount() {+                <span
class="code-keyword">return</span> proc.allSessionsCount();+            }             
@Override             <span class="code-keyword">protected</span> void destroy(NioSession
session) <span class="code-keyword">throws</span> Exception {</pre></div></div> 
==============================

On issue key DIRMINA-1076 the Iterator pattern might have been discussed on the following comment: 
==============================
In the previous post, I mentioned the possibility of totally removing the
<tt>nSession</tt> state.<b>Option 3</b><br/>Completely removes the <tt>nSession</tt> state
because it is corruptible.  Relies entirely on <tt>selector.keys().size()</tt> for the
state.  This is actually the most simple of all the alternatives as it requires no new
atomic mechanisms.  Only drawback is that it might take longer to <tt>dispose()</tt> the
<tt>IoProcessor</tt> due the extra <tt>select()</tt> cycle that must occur to update the
session count.<div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..c807bf1 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-240,6 +240,13 @@      * @<span class="code-keyword">return</span> {@link Iterator} of
{@link IoSession}      */     <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> Iterator&lt;S&gt; allSessions();+    +    /**+     *
Get the number of {@Link IoSession} polled by <span class="code-keyword">this</span>
{@Link IoProcessor}+     *+     * @<span class="code-keyword">return</span> the number of
sessions attached to <span class="code-keyword">this</span> {@Link IoProcessor}+    
*/+    <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> <span class="code-object">int</span>
allSessionsCount();      /**      * Get an {@link Iterator} <span
class="code-keyword">for</span> the list of {@link IoSession} found selected@@ -596,7
+603,6 @@         <span class="code-keyword">public</span> void run() {             <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>; -            <span class="code-object">int</span>
nSessions = 0;             lastIdleCheckTime = <span
class="code-object">System</span>.currentTimeMillis();             <span
class="code-object">int</span> nbTries = 10; @@ -641,9 +647,31 @@                     }
<span class="code-keyword">else</span> {                         nbTries =
10;                     }-+                                         <span
class="code-comment">// Manage newly created session first</span>-                   
nSessions += handleNewSessions();+                    <span
class="code-keyword">if</span>(handleNewSessions() == 0) {+                        <span
class="code-comment">// Get a chance to exit the infinite loop <span
class="code-keyword">if</span> there are no</span>+                        <span
class="code-comment">// more sessions on <span class="code-keyword">this</span>
Processor</span>+                        <span class="code-keyword">if</span>
(allSessionsCount() == 0) {+                            processorRef.set(<span
class="code-keyword">null</span>);++                            <span
class="code-keyword">if</span> (newSessions.isEmpty() &amp;&amp; isSelectorEmpty())
{+                                <span class="code-comment">// newSessions.add() precedes
startupProcessor</span>+                                <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;+                                <span
class="code-keyword">break</span>;+                           
}++                            <span class="code-keyword">assert</span> processorRef.get()
!= <span class="code-keyword">this</span>;++                            <span
class="code-keyword">if</span> (!processorRef.compareAndSet(<span
class="code-keyword">null</span>, <span class="code-keyword">this</span>))
{+                                <span class="code-comment">// startupProcessor won race,
so must exit processor</span>+                                <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;+                                <span
class="code-keyword">break</span>;+                           
}++                            <span class="code-keyword">assert</span> processorRef.get()
== <span class="code-keyword">this</span>;+                        }+                   
}                      updateTrafficMask(); @@ -654,39 +682,17 @@                        
<span class="code-comment">// the MDCFilter test...</span>                        
process();                     }-+                                         <span
class="code-comment">// Write the pending requests</span>                     <span
class="code-object">long</span> currentTime = <span
class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime);--                    <span class="code-comment">// And manage removed
sessions</span>-                    nSessions -= removeSessions();-+                  
                      <span class="code-comment">// Last, not least, send Idle events to
the idle sessions</span>                    
notifyIdleSessions(currentTime);--                    <span class="code-comment">// Get a
chance to exit the infinite loop <span class="code-keyword">if</span> there are
no</span>-                    <span class="code-comment">// more sessions on <span
class="code-keyword">this</span> Processor</span>-                    <span
class="code-keyword">if</span> (nSessions == 0) {-                       
processorRef.set(<span class="code-keyword">null</span>);--                        <span
class="code-keyword">if</span> (newSessions.isEmpty() &amp;&amp; isSelectorEmpty())
{-                            <span class="code-comment">// newSessions.add() precedes
startupProcessor</span>-                            <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;-                            <span
class="code-keyword">break</span>;-                        }--                       
<span class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;--                        <span
class="code-keyword">if</span> (!processorRef.compareAndSet(<span
class="code-keyword">null</span>, <span class="code-keyword">this</span>))
{-                            <span class="code-comment">// startupProcessor won race, so
must exit processor</span>-                            <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;-                            <span
class="code-keyword">break</span>;-                        }--                       
<span class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }-+                  
 +                    <span class="code-comment">// And manage removed
sessions</span>+                    removeSessions();+                  
                      <span class="code-comment">// Disconnect all sessions immediately
<span class="code-keyword">if</span> disposal has been</span>                     <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>                     <span class="code-keyword">if</span>
(isDisposing()) {@@ -702,9 +708,7 @@                             }                        
} -                        <span class="code-keyword">if</span> (hasKeys)
{-                            wakeup();-                        }+                       
wakeup();                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span>diff --git
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.javaindex
3b0fa40..9948d7a 100644---
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java@@ -159,6
+159,12 @@             selectorLock.readLock().unlock();         }     }+    +   
@Override+    <span class="code-keyword">protected</span> <span
class="code-object">int</span> allSessionsCount()+    {+        <span
class="code-keyword">return</span> selector.keys().size();+    }     
@SuppressWarnings(<span class="code-quote">"synthetic-access"</span>)     @Overridediff
--git
a/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.java
b/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.javaindex
379f55b..f289aaf 100644---
a/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.java+++
b/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.java@@
-61,6 +61,11 @@             <span class="code-keyword">protected</span>
Iterator&lt;NioSession&gt; allSessions() {                 <span
class="code-keyword">return</span> proc.allSessions();             }+          
 +            @Override+            <span class="code-keyword">protected</span> <span
class="code-object">int</span> allSessionsCount() {+                <span
class="code-keyword">return</span> proc.allSessionsCount();+            }             
@Override             <span class="code-keyword">protected</span> void destroy(NioSession
session) <span class="code-keyword">throws</span> Exception {</pre></div></div> 
==============================

New Comment: 
In the previous post, I mentioned the possibility of totally removing the
<tt>nSession</tt> state.<b>Option 3</b><br/>Completely removes the <tt>nSession</tt> state
because it is corruptible.  Relies entirely on <tt>selector.keys().size()</tt> for the
state.  This is actually the most simple of all the alternatives as it requires no new
atomic mechanisms.  Only drawback is that it might take longer to <tt>dispose()</tt> the
<tt>IoProcessor</tt> due the extra <tt>select()</tt> cycle that must occur to update the
session count.<div class="code panel" style="border-width: 1px;"><div class="codeContent
panelContent"><pre class="code-java">diff --git
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.javaindex
79885fa..c807bf1 100644---
a/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/core/polling/AbstractPollingIoProcessor.java@@
-240,6 +240,13 @@      * @<span class="code-keyword">return</span> {@link Iterator} of
{@link IoSession}      */     <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> Iterator&lt;S&gt; allSessions();+    +    /**+     *
Get the number of {@Link IoSession} polled by <span class="code-keyword">this</span>
{@Link IoProcessor}+     *+     * @<span class="code-keyword">return</span> the number of
sessions attached to <span class="code-keyword">this</span> {@Link IoProcessor}+    
*/+    <span class="code-keyword">protected</span> <span
class="code-keyword">abstract</span> <span class="code-object">int</span>
allSessionsCount();      /**      * Get an {@link Iterator} <span
class="code-keyword">for</span> the list of {@link IoSession} found selected@@ -596,7
+603,6 @@         <span class="code-keyword">public</span> void run() {             <span
class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>; -            <span class="code-object">int</span>
nSessions = 0;             lastIdleCheckTime = <span
class="code-object">System</span>.currentTimeMillis();             <span
class="code-object">int</span> nbTries = 10; @@ -641,9 +647,31 @@                     }
<span class="code-keyword">else</span> {                         nbTries =
10;                     }-+                                         <span
class="code-comment">// Manage newly created session first</span>-                   
nSessions += handleNewSessions();+                    <span
class="code-keyword">if</span>(handleNewSessions() == 0) {+                        <span
class="code-comment">// Get a chance to exit the infinite loop <span
class="code-keyword">if</span> there are no</span>+                        <span
class="code-comment">// more sessions on <span class="code-keyword">this</span>
Processor</span>+                        <span class="code-keyword">if</span>
(allSessionsCount() == 0) {+                            processorRef.set(<span
class="code-keyword">null</span>);++                            <span
class="code-keyword">if</span> (newSessions.isEmpty() &amp;&amp; isSelectorEmpty())
{+                                <span class="code-comment">// newSessions.add() precedes
startupProcessor</span>+                                <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;+                                <span
class="code-keyword">break</span>;+                           
}++                            <span class="code-keyword">assert</span> processorRef.get()
!= <span class="code-keyword">this</span>;++                            <span
class="code-keyword">if</span> (!processorRef.compareAndSet(<span
class="code-keyword">null</span>, <span class="code-keyword">this</span>))
{+                                <span class="code-comment">// startupProcessor won race,
so must exit processor</span>+                                <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;+                                <span
class="code-keyword">break</span>;+                           
}++                            <span class="code-keyword">assert</span> processorRef.get()
== <span class="code-keyword">this</span>;+                        }+                   
}                      updateTrafficMask(); @@ -654,39 +682,17 @@                        
<span class="code-comment">// the MDCFilter test...</span>                        
process();                     }-+                                         <span
class="code-comment">// Write the pending requests</span>                     <span
class="code-object">long</span> currentTime = <span
class="code-object">System</span>.currentTimeMillis();                    
flush(currentTime);--                    <span class="code-comment">// And manage removed
sessions</span>-                    nSessions -= removeSessions();-+                  
                      <span class="code-comment">// Last, not least, send Idle events to
the idle sessions</span>                    
notifyIdleSessions(currentTime);--                    <span class="code-comment">// Get a
chance to exit the infinite loop <span class="code-keyword">if</span> there are
no</span>-                    <span class="code-comment">// more sessions on <span
class="code-keyword">this</span> Processor</span>-                    <span
class="code-keyword">if</span> (nSessions == 0) {-                       
processorRef.set(<span class="code-keyword">null</span>);--                        <span
class="code-keyword">if</span> (newSessions.isEmpty() &amp;&amp; isSelectorEmpty())
{-                            <span class="code-comment">// newSessions.add() precedes
startupProcessor</span>-                            <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;-                            <span
class="code-keyword">break</span>;-                        }--                       
<span class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;--                        <span
class="code-keyword">if</span> (!processorRef.compareAndSet(<span
class="code-keyword">null</span>, <span class="code-keyword">this</span>))
{-                            <span class="code-comment">// startupProcessor won race, so
must exit processor</span>-                            <span
class="code-keyword">assert</span> processorRef.get() != <span
class="code-keyword">this</span>;-                            <span
class="code-keyword">break</span>;-                        }--                       
<span class="code-keyword">assert</span> processorRef.get() == <span
class="code-keyword">this</span>;-                    }-+                  
 +                    <span class="code-comment">// And manage removed
sessions</span>+                    removeSessions();+                  
                      <span class="code-comment">// Disconnect all sessions immediately
<span class="code-keyword">if</span> disposal has been</span>                     <span
class="code-comment">// requested so that we exit <span class="code-keyword">this</span>
loop eventually.</span>                     <span class="code-keyword">if</span>
(isDisposing()) {@@ -702,9 +708,7 @@                             }                        
} -                        <span class="code-keyword">if</span> (hasKeys)
{-                            wakeup();-                        }+                       
wakeup();                     }                 } <span class="code-keyword">catch</span>
(ClosedSelectorException cse) {                     <span class="code-comment">// If the
selector has been closed, we can exit the loop</span>diff --git
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.javaindex
3b0fa40..9948d7a 100644---
a/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java+++
b/mina-core/src/main/java/org/apache/mina/transport/socket/nio/NioProcessor.java@@ -159,6
+159,12 @@             selectorLock.readLock().unlock();         }     }+    +   
@Override+    <span class="code-keyword">protected</span> <span
class="code-object">int</span> allSessionsCount()+    {+        <span
class="code-keyword">return</span> selector.keys().size();+    }     
@SuppressWarnings(<span class="code-quote">"synthetic-access"</span>)     @Overridediff
--git
a/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.java
b/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.javaindex
379f55b..f289aaf 100644---
a/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.java+++
b/mina-core/src/test/java/org/apache/mina/transport/socket/nio/PollingIoProcessorTest.java@@
-61,6 +61,11 @@             <span class="code-keyword">protected</span>
Iterator&lt;NioSession&gt; allSessions() {                 <span
class="code-keyword">return</span> proc.allSessions();             }+          
 +            @Override+            <span class="code-keyword">protected</span> <span
class="code-object">int</span> allSessionsCount() {+                <span
class="code-keyword">return</span> proc.allSessionsCount();+            }             
@Override             <span class="code-keyword">protected</span> void destroy(NioSession
session) <span class="code-keyword">throws</span> Exception {</pre></div></div> 


New Comment: 
The pb is that <tt>selector.keys()</tt> is not thread safe :/ There is no guarantee that a
call to <tt>size()</tt> will return the correct number of active sessions... 


New Comment: 
When called from the <tt>IoProcessor</tt> worker thread, it is safe. All additions and
removals must occur from the <tt>IoProcessor</tt> worker thread.  <tt>Session</tt> are
atomically queued for add and remove, all of which occurs inside of the
<tt>IoProcessor</tt> worker thread.  If you were to call <tt>selector.keys().size()</tt>
anywhere else, it would not be safe. 


New Comment: 
Right, right. I kind of like this option 3. Regarding the extra <tt>select()</tt> call
when disposing the selector, not sure we need to do an extra select loop : the count
should be 0 when we dispose the selector anyway... Or maybe I'm missing sometjing ? 


New Comment: 
<tt>selector.close()</tt> occurs inside of the <tt>IoProcessor</tt> worker thread. And it
only happens when the event loop exits (unless called directly through a non public
function), therefore, the number of keys must be 0 before <tt>IoProcessor</tt> will call
<tt>selector.close()</tt>.  The extra <tt>select()</tt> loop is to cause the
<tt>selector</tt> to update <tt>selector.keys().size()</tt>.  I think its fine the way it
is.  If it concerns you, we can change the loop timeout to something smaller, like 250ms. 


New Comment: 
Calling <tt>wakeup()</tt> should make the next call to <tt>select()</tt> non blocking, so
the extra <tt>select()</tt> loop would not be an issue.Have you tested option 3 against
unit tests ? 


New Comment: 
<tt>wakeup()</tt> actually doesn't mitigate the next <tt>select()</tt> at all; looking at
the code in <tt>NioProcessor#select(timeout)</tt> the <tt>wakeupCalled</tt> isn't even
referenced at all.  I did force an <tt>wakeup()</tt> inside of the <tt>isDisposing()</tt>
block at the end of the loop to mitigate the next <tt>select()</tt> in the event I was
misunderstanding it.  If you were to mitigate the next <tt>select()</tt> then you would
have to call <tt>selectNow()</tt> instead.  It has to be called, one way or another. 
Would be pretty simple to add <tt>wakeupCalled</tt> then <tt>selectNow()</tt> else
<tt>select()</tt>. 


New Comment: 
<a href="https://issues.apache.org/jira/secure/ViewProfile.jspa?name=chrjohn"
class="user-hover" rel="chrjohn">Christoph John</a> Please apply the patch for Option 3 to
your workspace and run it through all of your tests.  It passes the Unit Tests and the
examples you provided in both <a href="https://issues.apache.org/jira/browse/DIRMINA-1076"
title="Leaking NioProcessors/NioSocketConnectors hanging in call to dispose"
class="issue-link" data-issue-key="DIRMINA-1076"><del>DIRMINA-1076</del></a> and <a
href="https://issues.apache.org/jira/browse/DIRMINA-1077" title="Threads hanging in
dispose() on SSLHandshakeException" class="issue-link"
data-issue-key="DIRMINA